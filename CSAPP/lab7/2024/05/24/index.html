<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.jpg">
  <link rel="mask-icon" href="/images/avatar.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":10,"offset":10,"onmobile":true},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这是一场和计算机的邂逅.">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP的lab7-malloclab">
<meta property="og:url" content="http://example.com/CSAPP/lab7/2024/05/24/index.html">
<meta property="og:site_name" content="Vite">
<meta property="og:description" content="这是一场和计算机的邂逅.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/zhzvite/picgoroom/img/img/202406110118910.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202407110613115.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202407110613160.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202407110613195.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202407110613228.png">
<meta property="article:published_time" content="2024-05-24T04:00:00.000Z">
<meta property="article:modified_time" content="2024-07-10T22:00:00.000Z">
<meta property="article:author" content="zhz_vite">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="csapp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhzvite/picgoroom/img/img/202406110118910.png">

<link rel="canonical" href="http://example.com/CSAPP/lab7/2024/05/24/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>CSAPP的lab7-malloclab | Vite</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Vite</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-study">

    <a href="/study/" rel="section"><i class="fa fa-anchor fa-fw"></i>不周山</a>

  </li>
        <li class="menu-item menu-item-create">

    <a href="/create/" rel="section"><i class="fa fa-sitemap fa-fw"></i>登天路</a>

  </li>
        <li class="menu-item menu-item-pure">

    <a href="/pure/" rel="section"><i class="fa fa-calendar fa-fw"></i>彼岸花</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/zhzvite" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/CSAPP/lab7/2024/05/24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="zhz_vite">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vite">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CSAPP的lab7-malloclab
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-24 12:00:00" itemprop="dateCreated datePublished" datetime="2024-05-24T12:00:00+08:00">2024-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-11 06:00:00" itemprop="dateModified" datetime="2024-07-11T06:00:00+08:00">2024-07-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index"><span itemprop="name">CSAPP</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/CSAPP/lab7/2024/05/24/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/CSAPP/lab7/2024/05/24/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>33k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:01</span>
            </span>
            <div class="post-description">这是一场和计算机的邂逅.</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>充满惰性，在一日又一日的刷视频，一日又一日的打游戏中虚度时间，时不时搞一些表面功夫来打发时间，将本该完成的工作一拖再拖，没有plan，也没有Execution ability，永远在编译，动态调整属于自己的ddl时间，这距离也就一天天拉远，反思！</p>
</blockquote>
<h1 id="Lab前瞻"><a href="#Lab前瞻" class="headerlink" title="Lab前瞻"></a>Lab前瞻</h1><p>在CSAPP的课本中第九章(虚拟内存）9.9.1开始提及malloc函数和free函数，虚拟内存还不甚了解。<del>我都没怎么看这一章，是直接跳过来的emm</del>，malloc不初始化它返回的内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>在这里同时介绍了<code>sbrk</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> incr)</span>;</span><br></pre></td></tr></table></figure>

<p><code>sbrk</code> 函数通过将内核的 <code>brk</code> 指针增加<code>incr</code> 来扩展和收缩堆。如果成功，它就返回<code>brk</code> 的旧值，否则，它就返回 <code>-1</code>,并将 <code>errno</code> 设置为 <code>ENOMEM</code> 。如果 <code>incr</code> 为零，那么<code>sbrk</code> 就返回 <code>brk</code> 的当前值。用一个负的<code>incr</code>来调用<code>sbrk</code>是合法的，而且很巧妙，因为返回值 (<code>brk</code> 的旧值）指向距新堆顶向上 <code>abs(incr)</code> 字节处。如果<code>incr</code>是正值就往上涨不然就往下降，幅度是<code>abs(incr)</code>.</p>
<p>程序通过<code>free</code>函数来时想释放已分配的堆块.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br></pre></td></tr></table></figure>

<p>他不返回任何值且ptr必须指向已分配块的起始位置.不然就是未定义undefined.</p>
<p>malloc性能衡量指标:</p>
<ul>
<li><p>最大化吞吐率</p>
</li>
<li><p>最大化利用率</p>
<p>之所以会出现利用率这个点是因为你不知道什么时候会释放哪一个内存块,有可能总空闲空间足够但是空闲空间因为不合理的分配导致其分离无法被使用,即存在更加合理的分配方式使得内存被分配.</p>
</li>
</ul>
<p>碎片:</p>
<p>Internal fragmentation:简单量化,其就是已分配块的大小和有效载荷大小之差的和</p>
<p>External fragmentation:难以被量化,因为其还要考虑未来的请求</p>
<p>需要解决问题:</p>
<ul>
<li><p>空闲块组织free_list</p>
</li>
<li><p>放置:</p>
<ul>
<li>first fit:在靠近链表起始处留下碎片</li>
<li>next fit:经过研究发现其比上不足比下也不足,所以一般情况下不用</li>
<li>best fit:需要耗费较多的时间,因为其要进行彻底的堆搜索,但是能做出更优秀的决策(在当前状态下)</li>
</ul>
</li>
<li><p>分割</p>
</li>
<li><p>合并coalescing:即存在多个fragmentation靠在一起,可以合并成为一个大的块</p>
<ol>
<li>immediate coalescing</li>
</ol>
<p>每次都进行合并相邻块</p>
<ol start="2">
<li>deferred coalescing</li>
</ol>
<p> 分配失败的时候再选择合并,扫描整个堆</p>
</li>
</ul>
<p>带边界标记进行合并:(boundary tag)</p>
<p>预处理:每个块的头部生成一个脚部,脚部为头部的副本,便于下面的子块往上快速的识别上面的块是否空闲.</p>
<p><strong>看不懂以下部分:空闲块,已分配,</strong></p>
<blockquote>
<p>幸运的是，有一种非常聪明的边界标记的优化方法，能够使得在已分配块中不再需要脚部 。回想一下，当我们试图在内存中合并当前块以及前面的块和后面的块时，只有在前面的块是空闲时，才会需要用到它的脚部。如果我们把前面块的已分配／空闲位存放在当前块中多出来的低位中，那么已分配的块就不需要脚部了，这样我们就可以将这个多出来的空间用作有效载荷了。不过请注意，空闲块仍然需要脚部 。</p>
</blockquote>
<p>最小块大小可以在不同时刻被分配或者被释放,故最小块大小是max(最小分配块大小,最小空闲块大小)</p>
<h1 id="Lab预备"><a href="#Lab预备" class="headerlink" title="Lab预备"></a>Lab预备</h1><h2 id="lab前置工作"><a href="#lab前置工作" class="headerlink" title="lab前置工作"></a><strong>lab前置工作</strong></h2><ol>
<li>对于M芯片的mac，在开始实验前需要修改<code>config.h</code>文件,修改这一行</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AVG_LIBC_THRUPUT      600E3  <span class="comment">/* 600 Kops/sec */</span></span></span><br></pre></td></tr></table></figure>

<p>将本来的600E3改成128E3,是由于mac上的运行环境和该实验的设定环境不一致，所以要进行一些调控否则实验分数不正常！<strong>注意，这样子修改也只是勉强做做实验，知足！</strong></p>
<p>可以以三种方式组织malloclab 分别是数组结构，隐式空闲列表，显式空闲列表</p>
<ol start="2">
<li>下载traces文件并且更改makefile的trace文件路径，<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42241839/article/details/123697377">参考下文</a></li>
</ol>
<h2 id="lab结构"><a href="#lab结构" class="headerlink" title="lab结构"></a>lab结构</h2><ol>
<li><p>数组结构：最低效，最直接emm</p>
</li>
<li><p>隐式空闲链表（Implicit Free List）：把所有的块连接起来，而且是通过头部中的大小字段隐含地连接着的，每次都需要遍历所有块来找到合适的空闲块。</p>
</li>
</ol>
<p>我们将基于隐式空闲链表，使用立即边界标记合并方式，从头至尾地讲述一个简单分配器的实现。最大的块大小为2^32^ &#x3D;4GB。代码是 64 位干净的，即代码能不加修改地运行在 32 位 (gcc -m32) 或 64 位 (gcc -m64) 的进程中。</p>
<p><img src="https://raw.githubusercontent.com/zhzvite/picgoroom/img/img/202406110118910.png"><br>一个块包含了头部，有效载荷，空闲块，和脚部（可能会有)，块大小即为整个块的大小，脚部是头部的副本，和头部一样，头部中分为块大小和填充位两个信息，</p>
<ol start="3">
<li>显式空闲链表（Explicit Free Lists）：在空闲块中增加两个指针，分别指向链表中前一块和后一块，这样就不需要遍历所有块，只需要遍历空闲块。</li>
</ol>
<h2 id="Lab解法"><a href="#Lab解法" class="headerlink" title="Lab解法"></a>Lab解法</h2><h3 id="1-数组结构"><a href="#1-数组结构" class="headerlink" title="1.数组结构"></a>1.数组结构</h3><p>以数组结构组织malloc，只用malloc 和 realloc函数，只需要开辟新空间，对于realloc，也只需要开辟新空间，简要判断size大小。</p>
<p>即不需要free空间，只需要使用malloc开辟新空间即可，对于内存调整大小，则直接开辟新空间然后复制数据即可，不用考虑新老空间大小的关系</p>
<p><strong>注意header存的size值表示的是包括header（footer），有效载荷，填充区块的总和，而ptr指向的是有效载荷的起始位置。</strong></p>
<p>数组结构代码：</p>
<p>这个代码是<code>mm.c</code>文件中给定的,仅作为加深对malloc的理解，明白工作流程而已。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm-naive.c - The fastest, least memory-efficient malloc package.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * In this naive approach, a block is allocated by simply incrementing</span></span><br><span class="line"><span class="comment"> * the brk pointer.  A block is pure payload. There are no headers or</span></span><br><span class="line"><span class="comment"> * footers.  Blocks are never coalesced or reused. Realloc is</span></span><br><span class="line"><span class="comment"> * implemented directly using mm_malloc and mm_free.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE TO STUDENTS: Replace this header comment with your own header</span></span><br><span class="line"><span class="comment"> * comment that gives a high level description of your solution.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment"> * NOTE TO STUDENTS: Before you do anything else, please</span></span><br><span class="line"><span class="comment"> * provide your team information in the following struct.</span></span><br><span class="line"><span class="comment"> ********************************************************/</span></span><br><span class="line"><span class="type">team_t</span> team = &#123;</span><br><span class="line">    <span class="comment">/* Team name */</span></span><br><span class="line">    <span class="string">&quot;Vite Fuck&quot;</span>,</span><br><span class="line">    <span class="comment">/* First member&#x27;s full name */</span></span><br><span class="line">    <span class="string">&quot;zhz_vite&quot;</span>,</span><br><span class="line">    <span class="comment">/* First member&#x27;s email address */</span></span><br><span class="line">    <span class="string">&quot;2811215248@qq.com&quot;</span>,</span><br><span class="line">    <span class="comment">/* Second member&#x27;s full name (leave blank if none) */</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">/* Second member&#x27;s email address (leave blank if none) */</span></span><br><span class="line">    <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* single word (4) or double word (8) alignment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)<span class="comment">//会得到大于等于size的最小整数</span></span></span><br><span class="line"><span class="comment">//(size) + (ALIGNMENT-1)会得到最接近但不大于其alignment的倍数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_init - initialize the malloc package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//数组结构不用初始化</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span></span><br><span class="line"><span class="comment"> *     Always allocate a block whose size is a multiple of the alignment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> newsize = ALIGN(size + SIZE_T_SIZE);<span class="comment">//首先将size进行字节对齐</span></span><br><span class="line">    <span class="type">void</span> *p = mem_sbrk(newsize);<span class="comment">//开辟新空间</span></span><br><span class="line">    <span class="keyword">if</span> (p == (<span class="type">void</span> *)<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        *(<span class="type">size_t</span> *)p = size;<span class="comment">//填入数值</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span> *)((<span class="type">char</span> *)p + SIZE_T_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="type">void</span> *oldptr = ptr;</span><br><span class="line">  <span class="type">void</span> *newptr;</span><br><span class="line">  <span class="type">size_t</span> copySize;</span><br><span class="line"><span class="comment">// 使用 mm_malloc(size) 分配新的内存区域</span></span><br><span class="line">newptr = mm_malloc(size);</span><br><span class="line"><span class="keyword">if</span> (newptr == <span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 从原始指针 oldptr 中获取复制的大小</span></span><br><span class="line">copySize = *(<span class="type">size_t</span> *)((<span class="type">char</span> *)oldptr - SIZE_T_SIZE);</span><br><span class="line"><span class="comment">// 如果新分配的内存大小 size 小于复制大小 copySize，则选择较小的值</span></span><br><span class="line"><span class="keyword">if</span> (size &lt; copySize)</span><br><span class="line">  copySize = size;</span><br><span class="line"><span class="comment">// 使用 memcpy 函数将原始指针 oldptr 的数据复制到新分配的内存区域 newptr</span></span><br><span class="line"><span class="built_in">memcpy</span>(newptr, oldptr, copySize);</span><br><span class="line"><span class="comment">// 释放原始的内存区域 oldptr</span></span><br><span class="line">mm_free(oldptr);</span><br><span class="line"><span class="comment">// 返回新分配的内存区域 newptr</span></span><br><span class="line"><span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1隐式空闲列表-First-Fit"><a href="#2-1隐式空闲列表-First-Fit" class="headerlink" title="2.1隐式空闲列表+First Fit"></a>2.1隐式空闲列表+First Fit</h3><p><strong>基本函数定义</strong></p>
<p>在编程中为了避免出现多次对(void*)dp指针的强转和引用(void *)指针不能间接引用，所以为了减轻负担以及多次的简洁使用，故采取多个宏定义减轻后期编写函数会出现的各种各样的负担。</p>
<p>书上给的函数定义，之后的编程会为了方便补充宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* $begin mallocmacros */</span></span><br><span class="line"><span class="comment">/* Basic constants and macros */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE       4       <span class="comment">/* Word and header/footer size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE       8       <span class="comment">/* Double word size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE  (1&lt;&lt;12)  <span class="comment">/* Extend heap by this amount (bytes) */</span>  </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) ((x) &gt; (y)? (x) : (y))  </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Pack a size and allocated bit into a word */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc)  ((size) | (alloc)) <span class="comment">//打包头部的值，再用PUT（p,PACK(size,alloc)),之类的函数把他丢进header/footer</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Read and write a word at address p */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p)       (*(unsigned int *)(p)) 	<span class="comment">//获得p指向的值           </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val)  (*(unsigned int *)(p) = (val))    <span class="comment">//写入val与p指向地址</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Read the size and allocated fields from address p */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p)  (GET(p) &amp; ~0x7)                   <span class="comment">//由于双字对齐条件约束，故释放最低三位，即得到的unsigned int 值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)                    <span class="comment">//有无分配</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of its header and footer */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp)       ((char *)(bp) - WSIZE)                      <span class="comment">//the address of the header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp)       ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE) <span class="comment">//the address of the footer</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of next and previous blocks */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp)  ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE))) <span class="comment">//next blocks pointer</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp)  ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE))) <span class="comment">//prev blocks pointer</span></span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><strong>函数实现</strong></p>
<p>要实现的函数</p>
<ol>
<li>int mm_init(void)extend_heap</li>
</ol>
<p>初始化函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>  ((heap_listp = mem_sbrk(<span class="number">4</span>*WSIZE)) == (<span class="type">void</span>*)<span class="number">-1</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_listp,<span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">    PUT(heap_listp+WSIZE,PACK(DSIZE,<span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp+<span class="number">2</span>*WSIZE,PACK(DSIZE,<span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp+<span class="number">3</span>*WSIZE,PACK(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    heap_listp+=<span class="number">2</span>*WSIZE;<span class="comment">//将heap_listp指针移到序言和结尾块之间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(extend_heap(CHUNKSIZE)==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>void *mm_malloc(size_t size)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *bp=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> extendsize;</span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(size&lt;=DSIZE)&#123;</span><br><span class="line">        size=<span class="number">2</span>*DSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        size=ALIGN(size+DSIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(((bp=find_fit(size))!=<span class="literal">NULL</span>))&#123;</span><br><span class="line">        place((<span class="type">char</span>* )bp,size);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    extendsize = MAX(size,CHUNKSIZE); <span class="comment">//扩展堆</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap (extendsize)) == <span class="literal">NULL</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    place(bp, size); </span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>void mm_free(void *ptr)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> size =GET_SIZE(HDRP(ptr));</span><br><span class="line">    PUT(HDRP(ptr),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr),PACK(size,<span class="number">0</span>));</span><br><span class="line">    coalesce(ptr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>void *mm_realloc(void *ptr, size_t size)</li>
</ol>
<p>重新组织内存，分配空间，统一调用free和malloc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *oldptr=ptr;</span><br><span class="line">    <span class="type">void</span> *newptr;</span><br><span class="line">    <span class="type">size_t</span> new_size,old_size,extend_size;</span><br><span class="line">    <span class="keyword">if</span>(ptr==<span class="literal">NULL</span>)<span class="keyword">return</span> mm_malloc(size);</span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">0</span>)&#123;</span><br><span class="line">        mm_free(ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    new_size=ALIGN(size+DSIZE);</span><br><span class="line">    old_size=GET_SIZE(HDRP(ptr));</span><br><span class="line"><span class="keyword">if</span>(old_size&gt;=new_size)&#123;<span class="comment">//只需要在原有空间上释放后面的一部分空间就可以了，其实可以直接用place语句替换ifelse</span></span><br><span class="line">    <span class="keyword">if</span>(old_size-new_size&gt;=MINBLOCK)</span><br><span class="line">    &#123;</span><br><span class="line">        place(oldptr,new_size);</span><br><span class="line">    <span class="keyword">return</span> oldptr;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> oldptr;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//太小了，只能释放内存，重新找一块新的</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((newptr=find_fit(new_size))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        extend_size=MAX(new_size,CHUNKSIZE);</span><br><span class="line">        <span class="keyword">if</span>((newptr=extend_heap(extend_size))==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    place(newptr,new_size);</span><br><span class="line">    <span class="built_in">memcpy</span>(newptr,oldptr,old_size<span class="number">-2</span>*WSIZE);</span><br><span class="line">    mm_free(oldptr);</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>static void *extend_heap(size_t words);</li>
</ol>
<p>扩展堆函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span>&#123;<span class="comment">//扩展堆函数,开一个新的空闲块</span></span><br><span class="line">    <span class="type">void</span> *bp;<span class="comment">//</span></span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    size=ALIGN(words);<span class="comment">//填充</span></span><br><span class="line">   <span class="keyword">if</span>( (<span class="type">long</span>)(bp=mem_sbrk(size))==<span class="number">-1</span>)<span class="comment">//注意这个（void*)</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    PUT(HDRP(bp),PACK(size,<span class="number">0</span>));<span class="comment">//</span></span><br><span class="line">    PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)),PACK(<span class="number">0</span>,<span class="number">1</span>));<span class="comment">//创建一个新的结尾块</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);<span class="comment">//开完后看能不能和前面的合并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>static void <em>find_fit(size_t size);</em></li>
</ol>
<p>找空余空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> size)</span>&#123;<span class="comment">//在空闲块中看能否找到一个&gt;=size的块，first fit</span></span><br><span class="line">    <span class="type">void</span> *ffbp;</span><br><span class="line">    <span class="keyword">for</span>(ffbp=heap_listp;GET_SIZE(HDRP(ffbp))&gt;<span class="number">0</span>;ffbp=NEXT_BLKP(ffbp))&#123;</span><br><span class="line">        <span class="keyword">if</span>(GET_ALLOC(HDRP(ffbp))==<span class="number">0</span>&amp;&amp;GET_SIZE(HDRP(ffbp))&gt;=size)</span><br><span class="line">        <span class="keyword">return</span> ffbp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><em>static void place(char</em>bp,size_t size);</li>
</ol>
<p>分割函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span>  <span class="type">void</span>  <span class="title function_">place</span><span class="params">(<span class="type">char</span> *bp,<span class="type">size_t</span> size)</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> asize =GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="type">size_t</span> resize =asize-size;</span><br><span class="line">    <span class="keyword">if</span>(resize&gt;=MINBLOCK)&#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(size,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">1</span>));</span><br><span class="line">        bp=NEXT_BLKP(bp);</span><br><span class="line">        PUT(HDRP(bp),PACK(resize,<span class="number">0</span>));<span class="comment">//后部分置为空</span></span><br><span class="line">        PUT(FTRP(bp),PACK(resize,<span class="number">0</span>));    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>static void <em>coalesce(void</em>bp);</li>
</ol>
<p>合并空余空间函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> prev_alloc=GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> next_alloc=GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> size =GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="keyword">if</span>(prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(prev_alloc ==<span class="number">1</span> &amp;&amp;next_alloc==<span class="number">0</span>)&#123;<span class="comment">//后面的块是空闲块，则指针不变，合并后面的块</span></span><br><span class="line">        size+=GET_SIZE(HDRP(NEXT_BLKP(bp)));<span class="comment">//</span></span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(next_alloc==<span class="number">1</span> &amp;&amp; prev_alloc==<span class="number">0</span>)&#123;<span class="comment">//前面的块空闲</span></span><br><span class="line">        size+=GET_SIZE(FTRP(PREV_BLKP(bp)));</span><br><span class="line">        bp=PREV_BLKP(bp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        size+=GET_SIZE(FTRP(PREV_BLKP(bp)));</span><br><span class="line">        size+=GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        bp=PREV_BLKP(bp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    PUT(HDRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">     <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>完整代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm-naive.c - The fastest, least memory-efficient malloc package.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * In this naive approach, a block is allocated by simply incrementing</span></span><br><span class="line"><span class="comment"> * the brk pointer.  A block is pure payload. There are no headers or</span></span><br><span class="line"><span class="comment"> * footers.  Blocks are never coalesced or reused. Realloc is</span></span><br><span class="line"><span class="comment"> * implemented directly using mm_malloc and mm_free.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE TO STUDENTS: Replace this header comment with your own header</span></span><br><span class="line"><span class="comment"> * comment that gives a high level description of your solution.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment"> * NOTE TO STUDENTS: Before you do anything else, please</span></span><br><span class="line"><span class="comment"> * provide your team information in the following struct.</span></span><br><span class="line"><span class="comment"> ********************************************************/</span></span><br><span class="line"><span class="type">team_t</span> team = &#123;</span><br><span class="line">    <span class="comment">/* Team name */</span></span><br><span class="line">    <span class="string">&quot;Vite Fuck&quot;</span>,</span><br><span class="line">    <span class="comment">/* First member&#x27;s full name */</span></span><br><span class="line">    <span class="string">&quot;zhz_vite&quot;</span>,</span><br><span class="line">    <span class="comment">/* First member&#x27;s email address */</span></span><br><span class="line">    <span class="string">&quot;2811215248@qq.com&quot;</span>,</span><br><span class="line">    <span class="comment">/* Second member&#x27;s full name (leave blank if none) */</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">/* Second member&#x27;s email address (leave blank if none) */</span></span><br><span class="line">    <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* single word (4) or double word (8) alignment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)<span class="comment">//会得到大于等于size的最小整数</span></span></span><br><span class="line"><span class="comment">//(size) + (ALIGNMENT-1)会得到最接近但不大于其alignment的倍数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span></span><br><span class="line"><span class="comment">/* $begin mallocmacros */</span></span><br><span class="line"><span class="comment">/* Basic constants and macros */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE       4       <span class="comment">/* Word and header/footer size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE       8       <span class="comment">/* Double word size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE  (1&lt;&lt;12)  <span class="comment">/* Extend heap by this amount (bytes) */</span>  </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) ((x) &gt; (y)? (x) : (y))  </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Pack a size and allocated bit into a word */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc)  ((size) | (alloc)) <span class="comment">//打包头部的值，再用PUT（p,PACK(size,alloc)),之类的函数把他丢进header/footer</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Read and write a word at address p */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p)       (*(unsigned int *)(p)) 	<span class="comment">//获得p指向的值           </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val)  (*(unsigned int *)(p) = (val))    <span class="comment">//写入val与p指向地址</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Read the size and allocated fields from address p */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p)  (GET(p) &amp; ~0x7)                   <span class="comment">//由于双字对齐条件约束，故释放最低三位，即得到的unsigned int 值为多少倍的DSIZE</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)                    <span class="comment">//有无分配</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of its header and footer */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp)       ((char *)(bp) - WSIZE)                      <span class="comment">//the address of the header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp)       ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE) <span class="comment">//the address of the footer</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of next and previous blocks */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp)  ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE))) <span class="comment">//next blocks pointer</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp)  ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE))) <span class="comment">//prev blocks pointer</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINBLOCK (DSIZE+2*WSIZE)</span></span><br><span class="line"> <span class="type">static</span> <span class="type">void</span> *heap_listp;</span><br><span class="line"></span><br><span class="line"> <span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span>;</span><br><span class="line"> <span class="type">static</span> <span class="type">void</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"> <span class="type">static</span> <span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">char</span>*bp,<span class="type">size_t</span> size)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span>*bp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_init - initialize the malloc package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>  ((heap_listp = mem_sbrk(<span class="number">4</span>*WSIZE)) == (<span class="type">void</span>*)<span class="number">-1</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_listp,<span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">    PUT(heap_listp+WSIZE,PACK(DSIZE,<span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp+<span class="number">2</span>*WSIZE,PACK(DSIZE,<span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp+<span class="number">3</span>*WSIZE,PACK(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    heap_listp+=<span class="number">2</span>*WSIZE;<span class="comment">//将heap_listp指针移到序言和结尾块之间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(extend_heap(CHUNKSIZE)==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span>&#123;<span class="comment">//扩展堆函数,开一个新的空闲块</span></span><br><span class="line">    <span class="type">void</span> *bp;<span class="comment">//</span></span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    size=ALIGN(words);<span class="comment">//填充</span></span><br><span class="line">   <span class="keyword">if</span>( (<span class="type">long</span>)(bp=mem_sbrk(size))==<span class="number">-1</span>)<span class="comment">//注意这个（void*)</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    PUT(HDRP(bp),PACK(size,<span class="number">0</span>));<span class="comment">//</span></span><br><span class="line">    PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)),PACK(<span class="number">0</span>,<span class="number">1</span>));<span class="comment">//创建一个新的结尾块</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);<span class="comment">//开完后看能不能和前面的合并</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> size)</span>&#123;<span class="comment">//在空闲块中看能否找到一个&gt;=size的块，first fit</span></span><br><span class="line">    <span class="type">void</span> *ffbp;</span><br><span class="line">    <span class="keyword">for</span>(ffbp=heap_listp;GET_SIZE(HDRP(ffbp))&gt;<span class="number">0</span>;ffbp=NEXT_BLKP(ffbp))&#123;</span><br><span class="line">        <span class="keyword">if</span>(GET_ALLOC(HDRP(ffbp))==<span class="number">0</span>&amp;&amp;GET_SIZE(HDRP(ffbp))&gt;=size)</span><br><span class="line">        <span class="keyword">return</span> ffbp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span>  <span class="type">void</span>  <span class="title function_">place</span><span class="params">(<span class="type">char</span> *bp,<span class="type">size_t</span> size)</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> asize =GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="type">size_t</span> resize =asize-size;</span><br><span class="line">    <span class="keyword">if</span>(resize&gt;=MINBLOCK)&#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(size,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">1</span>));</span><br><span class="line">        bp=NEXT_BLKP(bp);</span><br><span class="line">        PUT(HDRP(bp),PACK(resize,<span class="number">0</span>));<span class="comment">//后部分置为空</span></span><br><span class="line">        PUT(FTRP(bp),PACK(resize,<span class="number">0</span>));    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span></span><br><span class="line"><span class="comment"> *     Always allocate a block whose size is a multiple of the alignment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *bp=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> extendsize;</span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(size&lt;=DSIZE)&#123;</span><br><span class="line">        size=<span class="number">2</span>*DSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        size=ALIGN(size+DSIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(((bp=find_fit(size))!=<span class="literal">NULL</span>))&#123;</span><br><span class="line">        place((<span class="type">char</span>* )bp,size);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    extendsize = MAX(size,CHUNKSIZE); <span class="comment">//扩展堆</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap (extendsize)) == <span class="literal">NULL</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    place(bp, size); </span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> size =GET_SIZE(HDRP(ptr));</span><br><span class="line">    PUT(HDRP(ptr),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr),PACK(size,<span class="number">0</span>));</span><br><span class="line">    coalesce(ptr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> prev_alloc=GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> next_alloc=GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> size =GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="keyword">if</span>(prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(prev_alloc ==<span class="number">1</span> &amp;&amp;next_alloc==<span class="number">0</span>)&#123;<span class="comment">//后面的块是空闲块，则指针不变，合并后面的块</span></span><br><span class="line">        size+=GET_SIZE(HDRP(NEXT_BLKP(bp)));<span class="comment">//</span></span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(next_alloc==<span class="number">1</span> &amp;&amp; prev_alloc==<span class="number">0</span>)&#123;<span class="comment">//前面的块空闲</span></span><br><span class="line">        size+=GET_SIZE(FTRP(PREV_BLKP(bp)));</span><br><span class="line">        bp=PREV_BLKP(bp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        size+=GET_SIZE(FTRP(PREV_BLKP(bp)));</span><br><span class="line">        size+=GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        bp=PREV_BLKP(bp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    PUT(HDRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> bp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *oldptr=ptr;</span><br><span class="line">    <span class="type">void</span> *newptr;</span><br><span class="line">    <span class="type">size_t</span> new_size,old_size,extend_size;</span><br><span class="line">    <span class="keyword">if</span>(ptr==<span class="literal">NULL</span>)<span class="keyword">return</span> mm_malloc(size);</span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">0</span>)&#123;</span><br><span class="line">        mm_free(ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    new_size=ALIGN(size+DSIZE);</span><br><span class="line">    old_size=GET_SIZE(HDRP(ptr));</span><br><span class="line"><span class="keyword">if</span>(old_size&gt;=new_size)&#123;<span class="comment">//只需要在原有空间上释放后面的一部分空间就可以了，其实可以直接用place语句替换ifelse</span></span><br><span class="line">    <span class="keyword">if</span>(old_size-new_size&gt;=MINBLOCK)</span><br><span class="line">    &#123;</span><br><span class="line">        place(oldptr,new_size);</span><br><span class="line">    <span class="keyword">return</span> oldptr;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> oldptr;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//太小了，只能释放内存，重新找一块新的</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((newptr=find_fit(new_size))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        extend_size=MAX(new_size,CHUNKSIZE);</span><br><span class="line">        <span class="keyword">if</span>((newptr=extend_heap(extend_size))==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    place(newptr,new_size);</span><br><span class="line">    <span class="built_in">memcpy</span>(newptr,oldptr,old_size<span class="number">-2</span>*WSIZE);</span><br><span class="line">    mm_free(oldptr);</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>得分如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202407110613115.png" alt="image-20240711060851381"></p>
<h3 id="2-2优化next-fit"><a href="#2-2优化next-fit" class="headerlink" title="2.2优化next fit"></a>2.2优化next fit</h3><p>首次适配：</p>
<p>优点：趋向于将大的空闲块保留在链表的后面<br>缺点：趋向于在靠近链表起始处留下小空闲块的“碎片”，增加了对较大块的搜索时间。<br>下一次适配：</p>
<p>优点：上一次在某个空闲块中发现匹配，下一次也有可能（倾向于）在这个剩余块中发现匹配。<br>缺点：研究表明，下一次适配的内存利用率要比首次适配低得多。<br>针对得到的两次分数，可以明显的看到下一次适配的吞吐率比首次适配高很多，这方面next fit优势明显，但内存利用率要低。</p>
<p>优化方向：</p>
<p>first–&gt; next fit(即从上一次匹配的地方先寻找)</p>
<p>修改find_fit函数和colaesce函数即可</p>
<p>修改colaesce函数是为了防止出现下一次找上一次的指针不存在这种情况。所以会在<code>colaesce</code>函数中更新<code>next——fitp</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *next_fitp;<span class="comment">//静态变量，在int中赋初值</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> * <span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> size)</span>&#123; </span><br><span class="line"><span class="type">char</span> *lastp;</span><br><span class="line">   next_fitp=NEXT_BLKP(next_fitp);</span><br><span class="line">   lastp=next_fitp;</span><br><span class="line">    <span class="keyword">for</span> (;GET_SIZE(HDRP(next_fitp)) &gt; <span class="number">0</span>; next_fitp = NEXT_BLKP(next_fitp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!GET_ALLOC(HDRP(next_fitp)) &amp;&amp; (GET_SIZE(HDRP(next_fitp)) &gt;= size)) &#123;</span><br><span class="line">            <span class="keyword">return</span> next_fitp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next_fitp = NEXT_BLKP(heap_listp);</span><br><span class="line">    <span class="keyword">for</span> (;next_fitp != lastp; next_fitp = NEXT_BLKP(next_fitp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!GET_ALLOC(HDRP(next_fitp)) &amp;&amp; (GET_SIZE(HDRP(next_fitp)) &gt;= size)) &#123;</span><br><span class="line">            <span class="keyword">return</span> next_fitp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> prev_alloc=GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> next_alloc=GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> size =GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="keyword">if</span>(prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(prev_alloc ==<span class="number">1</span> &amp;&amp;next_alloc==<span class="number">0</span>)&#123;<span class="comment">//后面的块是空闲块，则指针不变，合并后面的块</span></span><br><span class="line">        size+=GET_SIZE(HDRP(NEXT_BLKP(bp)));<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(next_alloc==<span class="number">1</span> &amp;&amp; prev_alloc==<span class="number">0</span>)&#123;<span class="comment">//前面的块空闲</span></span><br><span class="line">        size+=GET_SIZE(FTRP(PREV_BLKP(bp)));</span><br><span class="line">        <span class="keyword">if</span>(bp==next_fitp)</span><br><span class="line">        next_fitp=PREV_BLKP(bp);</span><br><span class="line">        bp=PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        size+=GET_SIZE(FTRP(PREV_BLKP(bp)));</span><br><span class="line">        size+=GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">         <span class="keyword">if</span>(bp==next_fitp)</span><br><span class="line">        next_fitp=PREV_BLKP(bp);</span><br><span class="line">        bp=PREV_BLKP(bp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    PUT(HDRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> bp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>优化得分为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202407110613160.png" alt="image-20240711033445368"></p>
<h3 id="3-1显式空闲列表-LIFO"><a href="#3-1显式空闲列表-LIFO" class="headerlink" title="3.1显式空闲列表+LIFO"></a>3.1显式空闲列表+LIFO</h3><p>一种方法是用后进先出 (LIFO) 的顺序维护链表， 将新释放的块放置在链表的开始处。 使用<code>LIFO</code>的顺序和首次适配的放置策略,分配器会最先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数时间内完成。</p>
<p>另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。 平衡点在于，按照地址排序的首次适配比 按 LIFO 排序的首次适配有更高的内存利用率，接近最佳适配的利用率。 一般而言，显式链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部。这就导致了更大的最小块大小,也潜在地提高了内部碎片的程度。</p>
<p>仅仅需要在隐式空闲列表的基础上添加一个freelist，即添加前驱和后驱，可以套用双向链表的知识模拟malloc。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm-naive.c - The fastest, least memory-efficient malloc package.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * In this naive approach, a block is allocated by simply incrementing</span></span><br><span class="line"><span class="comment"> * the brk pointer.  A block is pure payload. There are no headers or</span></span><br><span class="line"><span class="comment"> * footers.  Blocks are never coalesced or reused. Realloc is</span></span><br><span class="line"><span class="comment"> * implemented directly using mm_malloc and mm_free.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE TO STUDENTS: Replace this header comment with your own header</span></span><br><span class="line"><span class="comment"> * comment that gives a high level description of your solution.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment"> * NOTE TO STUDENTS: Before you do anything else, please</span></span><br><span class="line"><span class="comment"> * provide your team information in the following struct.</span></span><br><span class="line"><span class="comment"> ********************************************************/</span></span><br><span class="line"><span class="type">team_t</span> team = &#123;</span><br><span class="line">    <span class="comment">/* Team name */</span></span><br><span class="line">    <span class="string">&quot;Vite Fuck&quot;</span>,</span><br><span class="line">    <span class="comment">/* First member&#x27;s full name */</span></span><br><span class="line">    <span class="string">&quot;zhz_vite&quot;</span>,</span><br><span class="line">    <span class="comment">/* First member&#x27;s email address */</span></span><br><span class="line">    <span class="string">&quot;2811215248@qq.com&quot;</span>,</span><br><span class="line">    <span class="comment">/* Second member&#x27;s full name (leave blank if none) */</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">/* Second member&#x27;s email address (leave blank if none) */</span></span><br><span class="line">    <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* single word (4) or double word (8) alignment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNMENT 8</span></span><br><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)<span class="comment">//会得到大于等于size的最小整数</span></span></span><br><span class="line"><span class="comment">//(size) + (ALIGNMENT-1)会得到最接近但不大于其alignment的倍数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span></span><br><span class="line"><span class="comment">/* $begin mallocmacros */</span></span><br><span class="line"><span class="comment">/* Basic constants and macros */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE       4       <span class="comment">/* Word and header/footer size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE       8       <span class="comment">/* Double word size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE  (1&lt;&lt;12)  <span class="comment">/* Extend heap by this amount (bytes) */</span>  </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) ((x) &gt; (y)? (x) : (y))  </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Pack a size and allocated bit into a word */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size, alloc)  ((size) | (alloc)) <span class="comment">//打包头部的值，再用PUT（p,PACK(size,alloc)),之类的函数把他丢进header/footer</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Read and write a word at address p */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p)       (*(unsigned int *)(p)) 	<span class="comment">//获得p指向的值           </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val)  (*(unsigned int *)(p) = (val))    <span class="comment">//写入val与p指向地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GETADDR(p)         (*(unsigned int **)(p))   <span class="comment">//读地址p处的一个指针</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTADDR(p,addr)   (*(unsigned int **)(p) = (unsigned int *)(addr))  <span class="comment">//向地址p处写一个指针</span></span></span><br><span class="line"><span class="comment">/* Read the size and allocated fields from address p */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p)  (GET(p) &amp; ~0x7)                   <span class="comment">//由于双字对齐条件约束，故释放最低三位，即得到的unsigned int 值为多少倍的DSIZE</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)                    <span class="comment">//有无分配</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of its header and footer */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp)       ((char *)(bp) - WSIZE)                      <span class="comment">//the address of the header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp)       ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE) <span class="comment">//the address of the footer</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of next and previous blocks */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp)  ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE))) <span class="comment">//next blocks pointer</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp)  ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE))) <span class="comment">//prev blocks pointer</span></span></span><br><span class="line"></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> PRED_POINT(bp)   (bp)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCC_POINT(bp)   ((char*)(bp)+WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINBLOCK (DSIZE+2*WSIZE+2*WSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *heap_listp;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *head_free;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">char</span>*bp,<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span>*bp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_freelist</span><span class="params">(<span class="type">void</span> *bp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remove_freelist</span><span class="params">(<span class="type">void</span> *bp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">place_freelist</span><span class="params">(<span class="type">void</span> *bp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_init - initialize the malloc package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>  ((heap_listp = mem_sbrk(<span class="number">4</span>*WSIZE)) == (<span class="type">void</span>*)<span class="number">-1</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUTADDR(heap_listp,<span class="literal">NULL</span>);</span><br><span class="line">   </span><br><span class="line">    PUT(heap_listp+WSIZE,PACK(DSIZE,<span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp+<span class="number">2</span>*WSIZE,PACK(DSIZE,<span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp+<span class="number">3</span>*WSIZE,PACK(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    head_free=heap_listp;</span><br><span class="line">    PUTADDR(head_free,<span class="literal">NULL</span>);<span class="comment">//point to NULL</span></span><br><span class="line">    heap_listp+=<span class="number">2</span>*WSIZE;<span class="comment">//将heap_listp指针移到序言和结尾块之间</span></span><br><span class="line">    <span class="keyword">if</span>(extend_heap(CHUNKSIZE)==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_freelist</span><span class="params">(<span class="type">void</span> *bp)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(GETADDR(head_free)==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        PUTADDR(SUCC_POINT(bp),<span class="literal">NULL</span>);</span><br><span class="line">        PUTADDR(PRED_POINT(bp), head_free);</span><br><span class="line">        PUTADDR(head_free, bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">void</span> *tmp;</span><br><span class="line">        tmp=GETADDR(head_free);</span><br><span class="line">        PUTADDR(SUCC_POINT(bp),tmp);</span><br><span class="line">        PUTADDR(PRED_POINT(bp),head_free);</span><br><span class="line">        PUTADDR(head_free,bp);</span><br><span class="line">        PUTADDR(PRED_POINT(tmp),bp);</span><br><span class="line">        tmp=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remove_freelist</span><span class="params">(<span class="type">void</span> *bp)</span> &#123;</span><br><span class="line">    <span class="type">void</span> *pre_block, *post_block;</span><br><span class="line">    pre_block = GETADDR(PRED_POINT(bp));</span><br><span class="line">    post_block = GETADDR(SUCC_POINT(bp));</span><br><span class="line">    <span class="comment">//处理前序结点</span></span><br><span class="line">    <span class="keyword">if</span> (pre_block == head_free) &#123;</span><br><span class="line">        PUTADDR(head_free, post_block);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PUTADDR(SUCC_POINT(pre_block), post_block);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理后序结点</span></span><br><span class="line">    <span class="keyword">if</span> (post_block != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PUTADDR(PRED_POINT(post_block), pre_block);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">place_freelist</span><span class="params">(<span class="type">void</span> *bp)</span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="type">void</span> *pre_block, *post_block, *next_bp;</span><br><span class="line">    <span class="comment">//存储前后结点地址</span></span><br><span class="line">    pre_block = GETADDR(PRED_POINT(bp));</span><br><span class="line">    post_block = GETADDR(SUCC_POINT(bp));</span><br><span class="line">    next_bp = NEXT_BLKP(bp);</span><br><span class="line">    <span class="comment">//处理新的bp，进行前后连接</span></span><br><span class="line">    PUTADDR(PRED_POINT(next_bp), pre_block);</span><br><span class="line">    PUTADDR(SUCC_POINT(next_bp), post_block);</span><br><span class="line">    <span class="comment">//处理前序结点  针对head_free是前序结点的特殊处理</span></span><br><span class="line">    <span class="keyword">if</span> (pre_block == head_free) &#123;</span><br><span class="line">        PUTADDR(head_free, next_bp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PUTADDR(SUCC_POINT(pre_block), next_bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理后序结点</span></span><br><span class="line">    <span class="keyword">if</span> (post_block != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PUTADDR(PRED_POINT(post_block), next_bp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span>&#123;<span class="comment">//扩展堆函数,开一个新的空闲块</span></span><br><span class="line">    <span class="type">void</span> *bp;<span class="comment">//</span></span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    size=ALIGN(words);<span class="comment">//填充</span></span><br><span class="line">   <span class="keyword">if</span>( (<span class="type">long</span>)(bp=mem_sbrk(size))==<span class="number">-1</span>)<span class="comment">//注意这个（void*)</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    PUT(HDRP(bp),PACK(size,<span class="number">0</span>));<span class="comment">//</span></span><br><span class="line">    PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)),PACK(<span class="number">0</span>,<span class="number">1</span>));<span class="comment">//创建一个新的结尾块</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);<span class="comment">//开完后看能不能和前面的合并</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> size)</span>&#123;<span class="comment">//在空闲块中看能否找到一个&gt;=size的块，first fit</span></span><br><span class="line">	<span class="type">void</span> *ffbp;</span><br><span class="line">    <span class="keyword">for</span>(ffbp=GETADDR(head_free);ffbp!=<span class="literal">NULL</span>;ffbp=GETADDR(SUCC_POINT(ffbp)))&#123;</span><br><span class="line">        <span class="keyword">if</span>(GET_SIZE(HDRP(ffbp))&gt;=size)</span><br><span class="line">        <span class="keyword">return</span> ffbp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span>  <span class="type">void</span>  <span class="title function_">place</span><span class="params">(<span class="type">char</span> *bp,<span class="type">size_t</span> size)</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> totalsize =GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="type">size_t</span> resize =totalsize-size;</span><br><span class="line">    <span class="keyword">if</span>(resize&gt;=MINBLOCK)&#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(size,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">1</span>));</span><br><span class="line">        <span class="type">void</span> *next_bp = NEXT_BLKP(bp);</span><br><span class="line">        PUT(HDRP(next_bp),PACK(resize,<span class="number">0</span>));<span class="comment">//后部分置为空</span></span><br><span class="line">        PUT(FTRP(next_bp),PACK(resize,<span class="number">0</span>));</span><br><span class="line">        place_freelist(bp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(totalsize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(totalsize,<span class="number">1</span>));</span><br><span class="line">        remove_freelist(bp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span></span><br><span class="line"><span class="comment"> *     Always allocate a block whose size is a multiple of the alignment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *bp=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> extendsize;</span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(size&lt;=DSIZE)&#123;</span><br><span class="line">        size=<span class="number">2</span>*DSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        size=ALIGN(size+DSIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(((bp=find_fit(size))!=<span class="literal">NULL</span>))&#123;</span><br><span class="line">        place((<span class="type">char</span>* )bp,size);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    extendsize = MAX(size,CHUNKSIZE); <span class="comment">//扩展堆</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap (extendsize)) == <span class="literal">NULL</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    place(bp, size); </span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> size =GET_SIZE(HDRP(ptr));</span><br><span class="line">    PUT(HDRP(ptr),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(ptr),PACK(size,<span class="number">0</span>));</span><br><span class="line">    coalesce(ptr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span>&#123;</span><br><span class="line">    <span class="type">char</span> *pre_block,*post_block;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> prev_alloc=GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> next_alloc=GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> size =GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="keyword">if</span>(prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        insert_freelist(bp);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(prev_alloc ==<span class="number">1</span> &amp;&amp;next_alloc==<span class="number">0</span>)&#123;<span class="comment">//后面的块是空闲块，则指针不变，合并后面的块</span></span><br><span class="line">        size+=GET_SIZE(HDRP(NEXT_BLKP(bp)));<span class="comment">//</span></span><br><span class="line">        post_block=NEXT_BLKP(bp);</span><br><span class="line">        remove_freelist(post_block);</span><br><span class="line">        insert_freelist(bp); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(next_alloc==<span class="number">1</span> &amp;&amp; prev_alloc==<span class="number">0</span>)&#123;<span class="comment">//前面的块空闲</span></span><br><span class="line">        size+=GET_SIZE(FTRP(PREV_BLKP(bp)));</span><br><span class="line">        bp=PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        size+=GET_SIZE(FTRP(PREV_BLKP(bp)));</span><br><span class="line">        size+=GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">       <span class="comment">//  if(bp==next_fitp)</span></span><br><span class="line">       <span class="comment">// next_fitp=PREV_BLKP(bp);</span></span><br><span class="line">        pre_block = PREV_BLKP(bp);</span><br><span class="line">        post_block = NEXT_BLKP(bp);</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">        remove_freelist(pre_block);</span><br><span class="line">        remove_freelist(post_block);</span><br><span class="line">        insert_freelist(bp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    PUT(HDRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> bp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *oldptr=ptr;</span><br><span class="line">    <span class="type">void</span> *newptr;</span><br><span class="line">    <span class="type">size_t</span> new_size,old_size,extend_size;</span><br><span class="line">    <span class="keyword">if</span>(ptr==<span class="literal">NULL</span>)<span class="keyword">return</span> mm_malloc(size);</span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">0</span>)&#123;</span><br><span class="line">        mm_free(ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    new_size=ALIGN(size+DSIZE);</span><br><span class="line">    old_size=GET_SIZE(HDRP(ptr));</span><br><span class="line"><span class="keyword">if</span>(old_size&gt;=new_size)&#123;<span class="comment">//只需要在原有空间上释放后面的一部分空间就可以了，其实可以直接用place语句替换ifelse</span></span><br><span class="line">    <span class="keyword">if</span>(old_size-new_size&gt;=MINBLOCK)</span><br><span class="line">    &#123;</span><br><span class="line">        place(oldptr,new_size);</span><br><span class="line">    <span class="keyword">return</span> oldptr;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> oldptr;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//太小了，只能释放内存，重新找一块新的</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((newptr=find_fit(new_size))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        extend_size=MAX(new_size,CHUNKSIZE);</span><br><span class="line">        <span class="keyword">if</span>((newptr=extend_heap(extend_size))==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    place(newptr,new_size);</span><br><span class="line">    <span class="built_in">memcpy</span>(newptr,oldptr,old_size<span class="number">-2</span>*WSIZE);</span><br><span class="line">    mm_free(oldptr);</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>评分如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202407110613195.png" alt="image-20240711051622930"></p>
<h3 id="3-2优化地址维护freelist"><a href="#3-2优化地址维护freelist" class="headerlink" title="3.2优化地址维护freelist"></a>3.2优化地址维护freelist</h3><p>优化代码：</p>
<p>只需要改动insert-freelist，使得插进去时以地址排列从小到的的方式插进去，便于寻找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_freelist</span><span class="params">(<span class="type">void</span> *bp)</span>&#123;</span><br><span class="line">    <span class="type">void</span> *pre_block,*post_block,*tmp;</span><br><span class="line">    tmp=head_free;</span><br><span class="line">    <span class="keyword">for</span>(post_block=GETADDR(head_free);post_block!=<span class="literal">NULL</span>;post_block=GETADDR(SUCC_POINT(post_block)))&#123;</span><br><span class="line">        <span class="keyword">if</span>(post_block&gt;bp)&#123;</span><br><span class="line">            pre_block=GETADDR(PRED_POINT(post_block));</span><br><span class="line">            PUTADDR(PRED_POINT(bp),pre_block);</span><br><span class="line">            PUTADDR(SUCC_POINT(bp),post_block);</span><br><span class="line">            <span class="keyword">if</span>(pre_block==head_free)</span><br><span class="line">            &#123;</span><br><span class="line">                PUTADDR(head_free,bp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                PUTADDR(SUCC_POINT(pre_block),bp);</span><br><span class="line">            &#125;</span><br><span class="line">            PUTADDR(PRED_POINT(post_block),bp);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp=post_block;</span><br><span class="line">    &#125;</span><br><span class="line">    pre_block=tmp;</span><br><span class="line">    PUTADDR(PRED_POINT(bp),pre_block);</span><br><span class="line">    PUTADDR(SUCC_POINT(bp),<span class="literal">NULL</span>);</span><br><span class="line">     <span class="keyword">if</span>(pre_block==head_free)</span><br><span class="line">            &#123;</span><br><span class="line">                PUTADDR(head_free,bp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                PUTADDR(SUCC_POINT(pre_block),bp);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得分如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202407110613228.png" alt="image-20240711061019718"></p>
<h2 id="后期优化"><a href="#后期优化" class="headerlink" title="后期优化"></a>后期优化</h2><h3 id="分配块舍弃脚部，能获得更大的空间利用率"><a href="#分配块舍弃脚部，能获得更大的空间利用率" class="headerlink" title="分配块舍弃脚部，能获得更大的空间利用率"></a>分配块舍弃脚部，能获得更大的空间利用率</h3><h3 id="分离链表"><a href="#分离链表" class="headerlink" title="分离链表"></a>分离链表</h3><p>正如我们在前面所看到的，一个使用单向空闲块链表的分配器需要与空闲块数量呈线性关系的时间来分配块，为了近似达到最佳适配以及更快寻找适配块，可以根据不同的_大小类_来维护多个空闲链表。本代码采用的每个大小类都是2的幂。这样子就是log2级别的了,按理可以提速很多！</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42241839/article/details/123697377">CSAPP(CMU 15-213)：Lab6 Malloclab详解_csapp malloc lab-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hankeke303/p/18155103/csapp-malloclab">CSAPP Lab-7 Malloc Lab - hankeke303 - 博客园 (cnblogs.com)</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"># 学习笔记</a>
              <a href="/tags/csapp/" rel="tag"># csapp</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/CSAPP/lab6/2024/04/25/" rel="prev" title="CSAPP的lab6-shlab">
      <i class="fa fa-chevron-left"></i> CSAPP的lab6-shlab
    </a></div>
      <div class="post-nav-item">
    <a href="/ACM/data_structure_notes/2024/05/25/" rel="next" title="数据结构">
      数据结构 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab%E5%89%8D%E7%9E%BB"><span class="nav-number">1.</span> <span class="nav-text">Lab前瞻</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab%E9%A2%84%E5%A4%87"><span class="nav-number">2.</span> <span class="nav-text">Lab预备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#lab%E5%89%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C"><span class="nav-number">2.1.</span> <span class="nav-text">lab前置工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lab%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.</span> <span class="nav-text">lab结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab%E8%A7%A3%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">Lab解法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.1.</span> <span class="nav-text">1.数组结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E9%9A%90%E5%BC%8F%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8-First-Fit"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.1隐式空闲列表+First Fit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E4%BC%98%E5%8C%96next-fit"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.2优化next fit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E6%98%BE%E5%BC%8F%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8-LIFO"><span class="nav-number">2.3.4.</span> <span class="nav-text">3.1显式空闲列表+LIFO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E4%BC%98%E5%8C%96%E5%9C%B0%E5%9D%80%E7%BB%B4%E6%8A%A4freelist"><span class="nav-number">2.3.5.</span> <span class="nav-text">3.2优化地址维护freelist</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8E%E6%9C%9F%E4%BC%98%E5%8C%96"><span class="nav-number">2.4.</span> <span class="nav-text">后期优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%9D%97%E8%88%8D%E5%BC%83%E8%84%9A%E9%83%A8%EF%BC%8C%E8%83%BD%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A4%A7%E7%9A%84%E7%A9%BA%E9%97%B4%E5%88%A9%E7%94%A8%E7%8E%87"><span class="nav-number">2.4.1.</span> <span class="nav-text">分配块舍弃脚部，能获得更大的空间利用率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%A6%BB%E9%93%BE%E8%A1%A8"><span class="nav-number">2.4.2.</span> <span class="nav-text">分离链表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="nav-number">3.</span> <span class="nav-text">参考文章</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zhz_vite"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">zhz_vite</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhzvite" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhzvite" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2811215248@qq.com" title="E-Mail → mailto:2811215248@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhz_vite</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">328k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">9:55</span>
</div>
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("01/01/2024 00:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已半死不活地运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'FjQmI706XTGQP3WHoYu51jaj-gzGzoHsz',
      appKey     : '7f8iu1agX4mrT7NPuBgu9HVw',
      placeholder: "随便说点吧哥们",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
