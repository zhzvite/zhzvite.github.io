
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>第一个板子 | vite的避难所</title>
    <meta name="author" content="Zhz-Vite" />
    <meta name="description" content="认真做好每件事" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>VITE的避难所</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;VITE的避难所</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>第一个板子</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/10/24
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="color: #00a596">学习笔记</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <p>快读</p>
<pre><code>int read()
&#123;
    int x = 0;
    char c = getchar();
    while(!sidigit(c))
        c = getchar();
    while(isdigit(c))
    &#123;
        x = x * 10 + (c ^ 48);
        c = getchar();
    &#125;
    return x;
&#125;
</code></pre>
<p>快速排序</p>
<pre><code>//l=第一个存放的位置,r=最后一个存放的位置
void quick_sort(long long int a[], int l, int r) &#123;
    int x = a[(r+l)/2];
    int i = l-1;
    int j = r+1 ;
    if (l &gt;= r)return;
    while (i &lt;j) &#123;
        do i++; while (a[i] &lt; x);
        do j--; while (a[j] &gt; x);//一定要记住这个do while他和while 不一样，写while会死，直接咋-1死掉
        if (i &lt; j) &#123;
            swap(a[i], a[j]);
        &#125;
    &#125;quick_sort(a, l, j);
    quick_sort(a, j+1, r);
    
&#125;
</code></pre>
<p>归并排序</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N = 100000;
int n;
int q[N], tmp[N];
void merge_sort(int q[], int l, int r)
&#123;
    if(l &gt;= r) return;
    int mid = l + r &gt;&gt;1;
    merge_sort(q, l, mid);
    merge_sort(q, mid+1, r);
    int k = 0, i = l, j = mid+1;
    while(i &lt;= mid &amp;&amp; j &lt;= r)
    &#123;
        if(q[i] &lt;= q[j]) tmp[k++] = q[i++];
        else tmp[k++] = q[j++];
    &#125;
    while(i &lt;= mid) tmp[k++] = q[i++];
    while(j &lt;= r) tmp[k++] = q[j++];
    for(i = l, j = 0; i &lt;= r; i++, j++) q[i] = tmp[j];
&#125;
int main()
&#123;
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;q[i]);
    merge_sort(q, 0, n-1);
    for(int i = 0; i &lt;n ; i++) printf(&quot;%d&quot;, q[i]);
    return 0;
&#125;
</code></pre>
<p>二分法(整数二分)</p>
<pre><code>sort(a, a + n, less&lt;int&gt;());//进行升序排序
sort(a, a + n, greater&lt;int&gt;());//降序排序
int i = -1, j = n;//这是重点,把起点放在数组外面
if (i + 1 == j)&#123;
    cout &lt;&lt; &quot; false&quot; &lt;&lt; endl; return 0;
  &#125;//判断空

if (k&lt;a[0] || k&gt;a[n - 1]) &#123;
    cout &lt;&lt; &quot; out&quot; &lt;&lt; endl;
    return 0;//判断极端情况,k为flag
&#125;
while (i+1!=j) &#123;
    int x = (i + j) / 2;
    if (k &lt;= a[x])j = x;//这些不等关系要依据条件,根据红区蓝区来分析
    if (k &gt; a[x])i = x;
&#125;
</code></pre>
<p>高精度</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
bool cmp(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)
&#123;
    if(A.size() != B.size()) return A.size() &gt; B.size();
    for(int i = A.size() -1; i &gt;= 0; i--)
        if(A[i] != B[i])
            return A[i] &gt; B[i];
    return true;
&#125;//比较大小
vector&lt;int&gt; div1(vector&lt;int&gt; &amp;A, int b, int&amp; r)
&#123;
    vector&lt;int&gt; C;
    r = 0;
    for(int i = A.size() - 1; i &gt;= 0; i--)
    &#123;
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b; 
    &#125;
    reverse(C.begin(), C.end());
    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back() ;
    return C;
&#125;
vector&lt;int&gt; mul1(vector&lt;int&gt; &amp;A, int b)
&#123;
    vector&lt;int&gt; C;
    int t = 0;
    for(int i = 0; i &lt; A.size() || t; i++)
    &#123;
         if(i &lt; A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10; 
    &#125;
    return C;
&#125;
vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)
&#123;
    vector&lt;int&gt; C;
    for(int i = 0, t = 0; i &lt; A.size(); i++)
    &#123;
        t = A[i] - t;
        if(i &lt; B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if(t &lt; 0) t = 1;
        else t = 0;  
    &#125;
    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();
    return C;
&#125;
vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)
&#123;
    vector&lt;int&gt; C;
    int t = 0;
    for(int i = 0; i &lt; A.size() || i &lt; B.size(); i++)
    &#123;
        if(i &lt; A.size()) t += A[i];
        if(i &lt; B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;  
    &#125;
    if(t) C.push_back(1);
    return C;
&#125;
int main()
&#123;
    string a, b;
    vector&lt;int&gt; A, B;
    cin &gt;&gt; a &gt;&gt; b;
    //scanf(&quot;%s%s&quot;, &amp;a, &amp;b);
    for(int i = a.size() - 1; i &gt;= 0; i--) A.push_back(a[i] - &#39;0&#39;);
    for(int i = b.size() - 1; i &gt;= 0; i--) B.push_back(b[i] - &#39;0&#39;);
    
    vector&lt;int&gt; Ca = add(A, B);
    for(int i = Ca.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, Ca[i]);//+
    printf(&quot;\n&quot;);
    
    if(cmp(A, B))&#123;
        vector&lt;int&gt; Cb = sub(A, B);
        for(int i = Cb.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, Cb[i]);
    &#125; else&#123;
        vector&lt;int&gt; Cb = sub(B, A);
        printf(&quot;-&quot;);
        for(int i = Cb.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, Cb[i]);//-
        printf(&quot;\n&quot;);
    &#125; 
    
    int n = 0;
    scanf(&quot;%d&quot;, &amp;n);
    vector&lt;int&gt; Cc = mul1(A, n);
    for(int i = Cc.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, Cc[i]);//*
    printf(&quot;\n&quot;);
    
    int m = 0, r = 0;
    scanf(&quot;%d&quot;, &amp;m);
    vector&lt;int&gt; Cd = div1(A, m, r);
    for(int i = Cd.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, Cd[i]);///
    printf(&quot; %d\n&quot;, r);
    return 0;
&#125;
</code></pre>
<p>二维前缀和差分</p>
<pre><code>//要有开始，要有结尾
void insert(int x1, int y1, int x2, int y2, int c) &#123;
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;//这是一个重要的预处理步骤
    //不仅在前面完成了b数组的初始化，并且在插入过程中完成的b的增值
&#125;
int main() &#123;
    int n, m,q, x1, x2, y1, y2,c;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
    for (int i = 1; i &lt;= n; i++) &#123;
        for (int j = 1; j &lt;= m; j++) &#123;
            cin &gt;&gt; a[i][j];
        &#125;
    &#125;//初始化a数组
    for (int i = 1; i &lt;= n; i++) &#123;
        for (int j = 1; j &lt;= m; j++) &#123;
            insert( i,  j,  i,  j, a[i][j]);//先遍历一遍数组b，进行插入,使得b是a的差分
        &#125;
    &#125;
    while (q--)
    &#123;
        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;
        insert(x1, y1, x2, y2, c);
        //再求b的前缀和
    &#125;
    for (int i = 1; i &lt;= n; i++) &#123;
        for (int j = 1; j &lt;= m; j++) &#123;
            //求数组b的前缀和
            b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];
            // 因为我们最后要求的是加完了c后的a数组，而b的前缀和是a数组，所以我们直接算出b的前缀和就行
        &#125;
    &#125;
    for (int i = 1; i &lt;= n; i++) &#123;
        for (int j = 1; j &lt;= m; j++) &#123;
            cout &lt;&lt; b[i][j] &lt;&lt; &quot; &quot;;
        &#125;cout &lt;&lt; endl;
    &#125;
&#125;
</code></pre>
<p>最长连续不重复子序列</p>
<pre><code>//用两个指针，降低暴力枚举的O(n^2)的时间复杂度
//解决重复数字，输出不重复数字的总数
int main() &#123;
    int a[N], s[N];
    memset(s,0,sizeof 0);
    int n;
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++)cin &gt;&gt; a[i];
    int res = 0;
    for (int i = 0, j = 0; i &lt; n; i++) &#123;
        s[a[i]]++;
        while (s[a[i]] &gt; 1) &#123;
            s[a[j]]--;//以s的数组来记录次数
            j++;
        &#125;
        res = max(res, i - j + 1);
    &#125;cout &lt;&lt; res &lt;&lt; &quot; &quot;;
&#125;
</code></pre>
<p>位运算</p>
<pre><code>//这里重点记录以下位运算的基本和应用
int lowbit(int x) &#123;
     return x &amp; (-x);
&#125;//巧妙的利用了源码和补码的性质，返回x的二进制最后以一结尾的一串二进制码
int main()
&#123;       int x=10;
for (int i = 0; i &lt; 4; i++) &#123;
cout &lt;&lt; (x &lt;&lt; i)&lt;&lt;endl;//将x左移i位,即以2倍式递增&#125;
        cin &gt;&gt; x;
        int res = 0;
        while (x) &#123;
            x -= lowbit(x);
            res++;
        &#125;
        cout &lt;&lt; res &lt;&lt; &quot; &quot;;//利用此段程序，算出录入的每个数字的二进制一有多少个
&#125;
</code></pre>
<p>离散化(适用于至于很大,数据量很小)</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef pair&lt;int ,int &gt; pii;
vector&lt;int&gt; alls;
vector&lt;pii&gt; add, query;
const int N = 300010;
int n, m;
int a[N], s[N];//a[存放数组离散前的]s算前缀和
int find(int x) &#123;
    int l = -1; int r = alls.size();
    while (l + 1 != r) &#123;//采用二分寻找答案,找到第一个大于等于x的位置
        int mid = (r + l) &gt;&gt; 1;
        if (alls[mid]&gt;=x)r = mid;
        else l = mid;
    &#125;return r + 1;//将x映射到1-alls.size,x表示位置
&#125;
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 0; i &lt; n; i++) &#123;
        int x, c;
        cin &gt;&gt; x &gt;&gt; c;
        alls.push_back(x);
        add.push_back(&#123; x,c &#125;);//数据存入
    &#125;
    for (int i = 0; i &lt; m; i++) &#123;
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        query.push_back(&#123; l,r &#125;);
        alls.push_back(l);
        alls.push_back(r);//将数据分别存到三个数组当中

    &#125;
    //去重
    sort(alls.begin(), alls.end());//排序
    alls.erase(unique(alls.begin(), alls.end()), alls.end());//去重，返回去重完alls的末尾位置,必须要先排序再去重
    for (auto item : add) &#123;//对add中的每个元素进行迭代
        int x = find(item.first);
        a[x] += item.second;

    &#125;
    //预处理前缀和 
    for (int i = 1; i &lt;= alls.size(); i++)s[i] = s[i - 1] + a[i];//位置寄托在alls中，数寄托在a【i】中
    //处理询问
    for (auto item : query) &#123;
        int l = find(item.first), r = find(item.second);//将l和r在alls里面映射
        cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl;
    &#125;
&#125;
</code></pre>
<p>区间合并</p>
<pre><code>typedef pair &lt;int, int &gt;  pii;
const int N = 100010;
int n;
vector&lt;pii&gt; segs;
void merge(vector&lt;pii&gt;&amp; segs) &#123;//解决不同的三种情况分别是无交集，有交集，在里面；(引用,占用空间少一点)
    vector&lt;pii&gt;  res;
    sort(segs.begin(), segs.end());
    int st = -2e9, ed = -2e9;
    for (auto seg : segs)&#123;
        if (ed &lt; seg.first) &#123;
            if (st != -2e9)res.push_back(&#123; st,ed &#125;);
            st = seg.first, ed = seg.second;
            &#125;
        else ed = max(ed, seg.second);
&#125;
        if (st != -2e9)res.push_back(&#123; st,ed &#125;);//用在最后退出循环后，把st和ed的值录进数组
        segs = res;//把res的结果丢到seg里面，即最后合并后的区间数
    
&#125;
int main() &#123;
    cin &gt;&gt; n;
    while (n--) &#123;
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        segs.push_back(&#123; l,r &#125;);//存放的是坐标
    &#125;
    merge(segs);
    cout &lt;&lt; segs.size() &lt;&lt; endl;
&#125;
</code></pre>
<p>单调队列之滑动窗口</p>
<pre><code>int a[N], q[N];//a[N]表示数的存放集合,q[N]表示数的下标的集合
int main() &#123;
    int hh = 0;//hh判断队列长度，hh是队尾
    int tt = -1;//tt表示次序，tt是对头
    for (int i = 0; i &lt; n; i++) &#123;
        //判断对头是否已经滑出窗口
        while (hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh])hh++;//while肯定行,但一次肯定是一个出,所以用if也行
        while (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i])tt--;//要构造一个单调递增数列
        q[++tt] = i;//把下标该放的位置
        if (i &gt;= k - 1)cout &lt;&lt; a[q[hh]] &lt;&lt;&quot; &quot;;
    &#125;
&#125;
</code></pre>
<p>单链表</p>
<pre><code>//这里努力写个程序实现静态链表（以数组构成链表
//还是要画图理解
#include&lt;iostream&gt;
using namespace std;
const int N = 100010;
//head=头结点,e[i]表示节点i的值,ne【i】表示节点i的next指针,idx表示储存的点的次序
int head, e[N], ne[N], idx;
void init() &#123;
    head = -1;
    idx = 0;
&#125;//对head和idx进行初始化
//将x插到头结点
void addhead(int x) &#123;
    e[idx] = x, ne[idx] = head, head = idx++;
&#125;
void addk(int k,int x) &#123;
    e[idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx;
    idx++;
&#125;//将x插到k后面，和头插法没什么区别
//将下标是k后面的一个点删掉
void remove(int k) &#123;
    ne[k] = ne[ne[k]];//链表是一个递归，可以理解为ne记录的是下一个数据的idx
&#125;
</code></pre>
<p>双链表</p>
<pre><code>int m,k,x;
int e[N], l[N], r[N], idx;
//类似单链表进行初始化
void init() &#123;
    //0表示左端点，1表示右端点
    l[1] = 0;
    r[0] = 1;//r表示从左往右，l表示从右往左
    idx = 2;
&#125;
//在下表是k的右边边插入一个点
void addk(int k, int x) &#123;
    e[idx] = x;
    r[idx] = r[k];
    l[idx] = k;
    l[r[k]] = idx;
    r[k] = idx;
    idx++;
&#125;
//删除第k个点
void remove(int k) &#123;
    r[l[k]] = r[k];
    l[r[k]] = l[k];
&#125;
</code></pre>
<p>kmp算法</p>
<pre><code>//p是模板串,s是长文本
char p[N], s[M];
int ne[N];
int main() &#123;
    cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;//p+1是指从第一位开始存
    //求next的过程,模板串
    for (int i = 2, j = 0; i &lt;= n; i++) &#123;//这里的ne【i】指的是前1-i项构成的序列中前缀和后缀相同的长度
        while (j &amp;&amp; p[i] != p[j + 1])j = ne[j];
        if (p[i] == p[j + 1])j++;
        ne[i] = j;
    &#125;
    //kmp 匹配过程
    for (int i = 1, j = 0; i &lt;= m; i++) &#123;
        while (j &amp;&amp; s[i] != p[j + 1])j = ne[j];
        if (s[i] == p[j + 1])j++;
        if (j == n) &#123;
            cout &lt;&lt; i - n&lt;&lt;&quot; &quot;;
            j = ne[j];//匹配成功
        &#125;
    &#125;
    return 0;
&#125;									
</code></pre>
<p>trie树</p>
<pre><code>//高效存储和查询字符串集合的数据结构
//通过一颗多分枝的树来高效存储,每一个分支都是一个字符串
int son[N][26],cnt[N],idx;//下标是0的点,既是空节点,又是根节点
char str[N];//输入字符串
void insert(char str[]) &#123;//输入一整个字符串
    int p = 0;
    for (int i = 0; str[i]; i++) &#123;
        int u = str[i] - &#39;a&#39;;//将字符串转化成数字
        if (!son[p][u])son[p][u] = ++idx;//idx储存的是当前用到的下标,下标唯一，往里面存储位置
        p = son[p][u];
    &#125;
    cnt[p]++;//p是标记，类似于终止标记
    //注意这里son[0][]存的是字符串的第一个字母，之后p会++，若该存的位置有被占用了，则会跳过，p自动继承，进行下一次循环
&#125;
int query(char str[]) &#123;
    int p = 0;
    for (int i = 0; str[i]; i++) &#123;
        int u = str[i] - &#39;a&#39;;
        if (!son[p][u])return 0;
        p = son[p][u];
    &#125;
    return cnt[p];
&#125;
int main() &#123;
    int n;
    cin &gt;&gt; n;//n为n次操作
    while (n--) &#123;
        char op[2];
        cin &gt;&gt; op;
        cin &gt;&gt; str;
        if (op[0] == &#39;I&#39;)insert(str);//执行插入操作
        else cout &lt;&lt; query(str);//执行寻找操作
    &#125;
    return 0;
&#125;
</code></pre>
<p>并查集</p>
<pre><code>//并查集巧妙地利用了递归，每次更新后都会形成新的集合，同时用递归对路迳进行了压缩
int n, m;
int p[N];
int find(int x) &#123;//返回x的祖宗节点,同时对路径进行压缩
    if (p[x] != x)p[x] = find(p[x]);//采用递归,找到他的父节点,同时进行了路径压缩,便于优化后面的索
    return p[x];//最后求出祖宗节点
 &#125;
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++)p[i]=i;//初始化数组p,使得每个都是其父节点,从i等于1开始
    while (m--) &#123;
        char op[2];
        int a, b;
        cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;
        if (op[0] == &#39;M&#39;)p[find(a)] = find(b);//祖宗节点的父节点为b的祖宗节点,使得a的祖宗节点放在b的祖宗节点下达到合并集合的效果
        else &#123;
            if (find(a) == find(b))cout &lt;&lt; &quot;Yes&quot;;
            else cout &lt;&lt; &quot;No&quot;;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<p>size的维护</p>
<pre><code>//p[]存每个点的祖宗节点，size[]只有祖宗节点的有意义，表示祖宗节点所在集合中点的数量
int p[N],size[N];
//返回x的祖宗节点
int find(int x)&#123;
    if(p[x]!=x) p[x]=find(p[x]);
    return p[x];
&#125;
//初始化，假定节点编号为1~n
for(int i=1;i&lt;=n;i++)&#123;
    p[i]=i;
    size[i]=1;
&#125;
//合并a和b所在的两个集合
size[find(b)]+=size[find(a)];
p[find(a)]=find(b);
</code></pre>
<p>堆</p>
<pre><code>int h[N], ph[N], hp[N], s;
void hswap(int a, int b) &#123;
    swap(ph[hp[a]], ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
&#125;
void down(int u) &#123;
    int t = u;
    if (u * 2 &lt;= s &amp;&amp; h[u * 2] &lt; h[t])t == u * 2;
    if (u * 2 + 1 &lt;= s &amp;&amp; h[u * 2 + 1] &lt; h[t])t == u * 2 + 1;
    if (u != t) &#123;
        hswap(t, u);
        down(t);
    &#125;
&#125;
void up(int u) &#123;
    while (u / 2 &amp;&amp; h[u / 2] &gt; h[u])
    &#123;
        hswap(u / 2, u);
        u /= 2;
    &#125;
&#125;
            //插入操作
            cin &gt;&gt; x;
            s++;//在堆中的位置
            m++;//在次序中的位置
            ph[m] = s;
            hp[s] = m;//两者类似反函数，互相映射
            h[s] = x;
            up(s);//最末尾往上up

            cout&lt;&lt; h[1];//输出集合中最小值
            hswap(1, s);
            s--;
            down(1);//删除集合中最小值

            cin &gt;&gt; k; //删除第k个插入的数
            k = ph[k];//新的位置
            hswap(k, s);
            s--;
            down(k), up(k);
         //修改第k个插入的数,改为x
            cin &gt;&gt; k &gt;&gt; x;
            k = ph[k];
            h[k] = x;
            down(k), up(k);		
</code></pre>
<p>一般哈希</p>
<pre><code>//拉链法
const int N = 100003;//一般mol的数要选择一个质数
int h[N],e[N],ne[N],idx;
void insert(int x) &#123;
    //将x映射到哈希函数上
    int k = (x % N + N) % N;
    e[idx] = x, ne[idx] = h[k], h[k] = idx++;//单链表的插入
&#125;
bool find(int x) &#123;
    int k = (x % N + N) % N;//k是映射到哈希函数上的值，使得复数mol完后变成一个整数，在c++中负数mol完会变成负数
    for (int i = h[k]; i != -1; i = ne[i]) &#123;
        if (e[i] == x)
            return true;&#125;
    return false;//return false 是最后的判断，若是找不到就返回false
&#125;
int main() &#123;
    int n;
    cin &gt;&gt; n;
    memset(h, -1, sizeof h);//所有初始化,初始化为-1,拉链法
    while (n--) &#123;
        char op[2];
        int x;
        cin &gt;&gt; op &gt;&gt; x;
        if (op[0] == &#39;I&#39;)insert(x);
        else &#123;
            if (find(x))cout &lt;&lt; &quot;yes&quot;&lt;&lt;endl;
            else cout &lt;&lt; &quot;No&quot;&lt;&lt;endl;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<p>开放寻址法</p>
<pre><code>const int N = 200003, null = 0x3f3f3f3f;//null是数据取不到的，开了两倍的坑位
int h[N];
int find(int x) &#123;//上厕所法，返回要存放的位置或者是他在的地方
    int k = (x % N + N) % N;   
    while (h[k] != null &amp;&amp; h[k] != x) &#123;
        k++;
        if (k == N)k = 0;
    &#125;
    return k;
&#125;
int main() &#123;
    int n;
    cin &gt;&gt; n;
    memset(h, 0x3f, sizeof h);//memset是针对字节memset，h数组有四个字节，每个字节都是ox3f 
    while (n--) &#123;
        char op[2];
        int x;
        cin &gt;&gt; op&gt;&gt;x;
        int k = find(x);
        if (op[0] == &#39;I&#39;)h[k] = x;
        else &#123;
            if (h[k] != null)cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl;
            else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
        &#125;
    &#125;
&#125;
</code></pre>
<p>字符串哈希</p>
<pre><code>//思路。存放str，同时进行m次询问，
//利用前缀和预处理，进行p进制转换
const int N = 100010,t=131;//将字母转化为t进制的数，将字符串的哈希值进行比较
typedef unsigned long long ull;//用ull则溢出的话就认为是取模于2的64次方
int n, m;
char str[N];
ull h[N], p[N];
ull get(int l, int r) &#123;
    return h[r] - h[l - 1] * p[r - l + 1];//求l和r之间字符串的哈希值
&#125;
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; str+1;//str+1表示第0位不放数据
    p[0] = 1;
    for (int i = 1; i &lt;= n; i++) &#123;
        p[i] = p[i - 1] * t;//表示次方
        h[i] = h[i - 1] * t + str[i];//将他变为数字
    //	cout &lt;&lt; str[1] &lt;&lt; &quot; &quot; &lt;&lt; h[1];
    &#125;
    while (m--) &#123;
        int l1, r1, l2, r2;
        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;
        if (get(l1, r1) == get(l2, r2)) cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl;
        else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;	
    &#125;
&#125;
</code></pre>
<p>bfs</p>
<pre><code>const int N = 110;
typedef pair&lt;int, int&gt; pii;
int n, m;
int g[N][N], d[N][N];//g负责存地图，d负责记录有没有走过
pii q[N * N],p[N ][N];
int bfs() &#123;
    int dx[4] = &#123; -1,0,1,0 &#125;, dy[4] = &#123; 0,1,0,-1 &#125;;
    int hh = 0, tt = 0;//采用栈的形式进行数据的堆叠
    memset(d, -1, sizeof d);
    q[0] = &#123; 0,0 &#125;;
    d[0][0] = 0;
    while (hh &lt;= tt) &#123;
        auto t = q[hh++];
        for (int i = 0; i &lt; 4; i++) &#123;
            int x = t.first + dx[i], y = t.second + dy[i];//上下左右遍历
            if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] == 0 &amp;&amp; d[x][y] == -1) &#123;
                d[x][y] = d[t.first][t.second] + 1;//记录他是几号点
            //	d[x][y] = 1;
                p[x][y] = t;//把上一个点塞进去了，类似于递归
                q[++tt] = &#123; x,y &#125;;//满足条件则往栈顶压入数据
            &#125;
        &#125;
    &#125;
    //输出路迳   
    int x = n - 1, y = m - 1;
    while (x || y) &#123;
        cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;
        auto t = p[x][y];
        x = t.first, y = t.second;
    &#125;
    return d[n - 1][m - 1];
&#125;
int main() &#123;
    cin &gt;&gt; n&gt;&gt;m;
    for (int i = 0; i &lt; n; i++) &#123;
        for (int j = 0; j &lt; m; j++)cin &gt;&gt; g[i][j];
    &#125;
    cout&lt;&lt;bfs()&lt;&lt;endl;

&#125;
</code></pre>
<p>图的拓扑排序(有向无环图一定有拓扑序列)</p>
<pre><code>int n, m;
int h[N], e[N], ne[N], idx;
int q[N], d[N];//q[N]为队列，d[N]是入度
void add(int a, int b)
&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
bool topsort() &#123;//队列中hh是对头，tt是队尾
    int hh = 0, tt = -1;
    for (int i = 1; i &lt;= n; i++) &#123;
        if (!d[i])q[++tt] = i;&#125;//将入度为0的点放进队列
        while (hh &lt;= tt) &#123;
            int t = q[hh++];
            for (int i = h[t]; i != -1; i = ne[i]) &#123;
                int j = e[i];
                d[j]--;//让入度减减
                if (d[j] == 0)q[++tt] = j;//当入度减为零了，将他压入队列
            &#125;
        &#125;
    return tt == n - 1;//判断它是不是有向无环图
&#125;//q中存的就是拓扑排好的序列,d存的是每个点的入度
</code></pre>
<p>朴素dijkstra算法，单源求最短路</p>
<pre><code>int g[N][N];
int dist[N];
bool st[N];
int dijkstra() &#123;
    memset(st, false, sizeof st);
    dist[1] = 0;
    for (int i = 0; i &lt; n; i++)
    &#123;
        int t = -1;
        for (int j =1; j &lt;=n; j++) &#123;
            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))
                t = j;
        &#125;
        st[t] = true;
        for (int j = 1; j &lt;= n; j++) &#123;
            dist[j] =min(dist[j], dist[t] + g[t][j]);
        &#125;
    &#125;
    if (dist[n] == 0x3f3f3f3f)return -1;
    else return dist[n];
&#125;
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m;
    memset(dist, 0x3f, sizeof dist);
    memset(g, 0x3f, sizeof g);
    while (m--) &#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        g[a][b] = min(g[a][b], c);
    &#125;
    int t = dijkstra();
    cout &lt;&lt; t;
&#125;
</code></pre>
<p>堆优化版本的dijkstra</p>
<pre><code>//有向图求最短路
//dijkstra算法
using namespace std;
const int N = 510;
int n, m;
int w[N], h[N], e[N], ne[N], idx;
int dist[N];
bool st[N];
typedef pair&lt;int, int&gt; pii;
priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; heap;
void add(int a,int b,int c) &#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
int dijkstra() &#123;
    memset(dist ,0x3f,sizeof dist);
    memset(st, false, sizeof st);
    heap.push(&#123; 0,1 &#125;);//0表示dist【】，
    while (heap.size()) &#123;
     auto t = heap.top();
     heap.pop();
     int distance = t.first, val = t.second;
     if (st[val])continue;
       for (int i = h[val]; ~i; i = ne[i]) &#123;
          int j = e[i];
           if (dist[j] &gt; distance+w[i])  &#123; 
                      dist[j] = distance + w[i];
                    heap.push(&#123; dist[j],j &#125;);//前一项表示到1的距离，后一项表示这个点
                  &#125;   
              &#125;
         &#125;
     if (dist[n] == 0x3f3f3f3f)return -1;
     else return dist[n];
    &#125;
</code></pre>
<p>spfa算法</p>
<pre><code>//spfa算法
#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 10010;
int ne[N], idx, e[N], h[N], w[N];
int dist[N];
bool st[N];
int n, m;
void add(int a, int b, int  c) &#123;
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;
&#125;
int spfa() &#123;
    memset(st, false, sizeof st);
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    queue&lt;int&gt; q;
    q.push(1);
    st[1] = true;
    while (q.size()) &#123;
        int t = q.front();
            q.pop();
            st[t] = false;
            for (int i = h[t]; ~i; i = ne[i]) &#123;
                int j = e[i];
                if (dist[j] &gt; dist[t] + w[i]) &#123;
                    dist[j] = dist[t] + w[i];
                    //cnt[j]=cnt[t]+1; if(cnt[j]&gt;=n)return true;判断负环
                    if (!st[j]) &#123;
                        q.push(j);
                        st[j] = true;
                    &#125;
                &#125;	
            &#125;
    &#125;
    if (dist[n] == 0x3f3f3f3f)return -1;
    else return dist[n];
&#125;
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof h);
    for (int i = 1; i &lt;= m; i++) &#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c);
    &#125;
    int t = spfa();
    if (t == -1)cout &lt;&lt; &quot; no&quot;;
    else cout &lt;&lt; t;
&#125;
</code></pre>
<p>有边数限制的最短路</p>
<pre><code>//在边数限定条件的最短路
using namespace std;
const int  N = 10010;
int dist[N], backup[N];
int n, m, k;
struct Edge &#123;
    int a, b, w;
&#125;edge[N];
int bellman_ford() &#123;
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    for (int i = 0; i &lt; k; i++) &#123;
        memcpy(backup, dist, sizeof dist);
        for (int j = 1; j &lt;= m; j++) &#123;
            int x = edge[j].a, y = edge[j].b, z = edge[j].w;
            dist[y] = min(dist[y], backup[x] + z);
        &#125;
    &#125;
    if (dist[n] &gt;0x3f3f3f3f / 2)return -1;//存在负权，有可能是0x3f3f3f3f-2，小于0x3f3f3f3f
    else return dist[n];
&#125;
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    for (int i = 1; i &lt;= m; i++) &#123;
        int x, y, z;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
        edge[i] = &#123; x,y,z &#125;;
    &#125;
    int t = bellman_ford();
    if (t == -1)cout &lt;&lt; &quot;impossible&quot;;
    else cout &lt;&lt; t;
&#125;
</code></pre>
<p>floyd算法求多源最短路</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
const int N = 210,inf=0x3f3f3f3f;
int n, m, q;
int dist[N][N];
void floyd() &#123;//基于动态规划的算法的k次前k-1次的点有关
    for (int k = 1; k &lt;= n; k++)
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= n; j++)
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
&#125;
int main() &#123;
    std::ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
    for (int i = 1; i &lt;= n; i++) &#123;
        for (int j = 1; j &lt;= n; j++) &#123;			
            if (i == j)dist[i][j] == 0;
            else dist[i][j] = inf;
         &#125;
    &#125;
    while (m--) &#123;//录入防止重边
        int x, y, z;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
        dist[x][y] = min(dist[x][y],z);
    &#125;
    floyd();
    while (q--) &#123;//输出多源最短路
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        if (dist[a][b] &gt; inf / 2)cout &lt;&lt; &quot;impossible&quot;;
        else cout &lt;&lt; dist[a][b];
    &#125;	
&#125;
</code></pre>
<p>kruskal求最小生成树</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 200010;
int p[N];
int n, m;
struct Edge &#123;
    int a, b, w;
    bool operator&lt; (const Edge &amp;W)const &#123;
        return w &lt; W.w;
    &#125;//在之后针对w进行排序
&#125;edges[N];
int find(int x) &#123;
    if (p[x] != x)p[x] = find(p[x]);
    return p[x];
&#125;
int main() &#123;
    cin &gt;&gt;n &gt;&gt; m;
    for (int i = 0; i &lt;= n; i++) &#123;
        int a, b, w;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;
        edges[i] = &#123; a,b,w &#125;;
    &#125;
    sort(edges, edges + m);//按w的权重进行排序
    int res = 0, cnt = 0;
    for (int i = 1; i &lt;= n; i++)p[i] = i;
    for (int i = 0; i &lt;m; i++) &#123;
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
        a=find(a); 
        b = find(b);
        if (a != b) &#123;
            p[a] = b;
            res += w;
            cnt++;
        &#125;
    &#125;
    if (cnt &lt; n - 1)cout &lt;&lt; &quot;impossible&quot;;
    else cout &lt;&lt; res;
&#125;
</code></pre>
<p>prim求最小生成树</p>
<pre><code>//在最小生成树中无所为边的权重是正还是负
const int N = 510,inf=0x3f3f3f3f;
int n, m;  
int g[N][N];
int dist[N];
bool st[N];
int prim() &#123;
    memset(dist, inf, sizeof dist);
    int res = 0;
    for (int i = 0; i &lt; n; i++) &#123;
        int t = -1;
        for (int j = 1; j &lt;= n; j++) 
            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))
                t = j;
            if (i&gt;0 &amp;&amp; dist[t] == inf)return inf;//因为第一次i=0的循环所有dist都是inf，只是为了第一次更新所有的dist为到1的最短距离
            if (i&gt;0)res += dist[t];//先累加再更新
            for (int j = 1; j &lt;= n; j++)
                dist[j] = min(dist[j],g[t][j]);
            st[t] = true;  
    &#125;
    return res;
&#125;
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m;
    memset(g, 0x3f3f3f3f, sizeof g);
    for (int i = 1; i &lt;= m; i++) &#123;
        int x, y, c;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;
        g[x][y] = g[y][x] = min(g[x][y],c);//取得是边长的最小值，同时构建无向图
    &#125;
   int t= prim();
   if (t == inf)cout &lt;&lt; &quot;impossible&quot;;
   else cout &lt;&lt; t;
&#125;
</code></pre>
<p>染色法判定二分图</p>
<pre><code>void add(int a, int b) &#123;
    e[idx] = b, ne[idx] = h[a], h[a] =idx++;//链表
&#125;
bool dfs(int u, int c) &#123;
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i]) &#123;
        int j = e[i];
        if (!color[j]) &#123;
            if (!dfs(j, 3 - c)) &#123;
                return false;
            &#125;    
        &#125;
        else if (color[j] == c)return false;
    &#125;  
    return true;
&#125;
int main() &#123;//以邻接表的形式存储
    memset(h, -1, sizeof h);
    bool flag = true;
    for (int i = 1; i &lt;= n; i++) &#123;
        if (!color[i]) &#123;  
            if (!dfs(i, 1)) &#123;
                flag = false;
                break;
           &#125;
        &#125;
    &#125;
    if (flag)cout &lt;&lt; &quot;yes&quot;;
    else cout &lt;&lt; &quot;no&quot;;
&#125;
</code></pre>
<p>二分图的最大匹配</p>
<pre><code>void add(int a, int b) &#123;
    e[idx] = a, ne[idx] = h[a], h[a] = idx++;
&#125;
bool find(int x) &#123;
    for (int i = h[x]; ~i; i = ne[i]) &#123;
        int j = e[i];
        if (!st[j]) &#123;
            st[j] = true;
            if (match[j] == 0 || find(match[j])) &#123;
                match[j] = x;
                return true;
            &#125;
        &#125;
    &#125;
    return false;
&#125;
int main() &#123;
    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m;
    while (m--) &#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        add(a, b);
    &#125;
    for (int i = 1; i &lt;= n1; i++) &#123;
        memset(st, false, sizeof st);
        if (find(i))res++;
    &#125;
    cout &lt;&lt; res;
    return 0;
&#125;
</code></pre>
<p>动态规划<br>01背包</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 1010;
int v[N], w[N];
int f[N];//本来是二维这里对其进行优化
int n, m;
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++)cin &gt;&gt; v[i] &gt;&gt; w[i];//从第一个开始存放
    for (int i = 1; i &lt;= n; i++) &#123;
        for (int j = m; j &gt;=v[i]; j--) &#123;
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        &#125;
    &#125;cout &lt;&lt; f[m];//返回的是体的最积最大为m时的最大价值
&#125;
</code></pre>
<p>多重背包</p>
<pre><code>//多重背包问题，多重背包是单重背包的变式，同时是完全背包问题加了部分约束
//这里是暴力做法加上一点维数优化
const int N = 1e4+10;
int a[N], b[N], s[N];
int f[N];//这是对二维的优化
int n, x,sum;
int main() &#123;
    cin &gt;&gt; n &gt;&gt; x ;
    f[0] = 1;
    for (int i = 1; i &lt;= n; i++)cin &gt;&gt; a[i] &gt;&gt; b[i];//将a[i],b[i]输入
    for (int i = 1; i &lt;= n; i++) &#123;
        for (int j = x; j &gt;= 0;j--) &#123;
            for (int k = 1; k &lt;= b[i]; k++) &#123;
                if (k * a[i] &lt;= j)&#123;
               f[j] =max( f[j],f[j - k * a[i]]);		 
                &#125;		
            &#125;
        &#125;
    &#125;
    if (f[x])cout &lt;&lt; &quot;Yes&quot;;
    else cout &lt;&lt; &quot;No&quot;;
&#125;
//优化思路，例如有s=200，可以把他降成多个2的几次幂和加上一个差的数，从而将较大的数转化成要不要选较少的几个选项及01背包变式,即二进制优化
//多重背包的优化,是将这么多件商品进行二进制化,, 每个件数都可以表示为多个2的不同次幂加上最后一个小于2^k+1的c值,将新的件数,放进质量和体积中,成为一个新的整体
const int N = 25000;
int n, m;
int v[N], w[N];//以v[i]表示体积,另一个表示权重即价值
int dp[N];
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m;
    int cnt=0;
    for (int i = 1; i &lt;= n; i++) &#123;
        int a, b, s;
        cin &gt;&gt; a&gt;&gt;b&gt;&gt;s; 
        int k = 1;
        if (k &lt;= s) &#123;
            cnt++,v[cnt] = k * a,w[cnt] = k * b,s -= k,k *= 2;
        &#125;
        if (s &gt; 0) &#123;
            cnt++,v[cnt] = s*a,w[cnt] = s * b;
        &#125;
    &#125;
    n = cnt;//更换新的件数
    //即将多重背包转化成01背包
    for (int i = 1; i &lt;= n; i++)
        for (int j = m; j &gt;= v[i]; j--)
            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    int maxn=0;
    for (int i = 1; i &lt;= m; i++) &#123;
        maxn = max(maxn, dp[m]);
    &#125;
    cout &lt;&lt; maxn;
    return 0;
&#125; 
</code></pre>
<p>完全背包</p>
<pre><code>//一维优化
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
const int N = 1010;
int n, m;
int v[N], w[N];
int dp[N];
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; w[i] &gt;&gt; v[i];
    &#125;
    for (int i = 0; i &lt;= n; i++)dp[i] = 0;
    for (int i = 1; i &lt;= n; i++) &#123;
        for (int j = w[i]; j &lt;= m; j++) &#123;
            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);//数学上的化简
        &#125;
    &#125;
    cout &lt;&lt; dp[m] &lt;&lt; endl;
&#125;
</code></pre>
<p>最长上升子序列</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 100010;
int n;
int f[N], a[N];
int main()
&#123;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)
    &#123;
        cin &gt;&gt; a[i];
    &#125;
    int len = 0;
    f[0] = -2e9;
    for(int i = 1; i &lt;= n; i++)
    &#123;
        int l = 0, r = len;
        while(l &lt; r)
        &#123;
            int mid = l + r + 1 &gt;&gt; 1;
            if(f[mid] &lt; a[i])
                l = mid;
            else
                r = mid - 1;
        &#125;
        len = max(len, r + 1);
        f[r + 1] = a[i];
    &#125;
    cout &lt;&lt; len &lt;&lt; endl;
    return 0;
&#125; 
</code></pre>
<p>最长公共子序列（非优化）</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 1010;
int n, m;
int a[N], b[N];
int f[N][N];
int main()
&#123;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    scanf(&quot;%s %s&quot;, a+1, b+1);
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt;= m; j++)
        &#123;
            f[i][j] = max(f[i-1][j], f[i][j-1]);
            if(a[i] == b[j]) f[i][j] = max(f[i][j], f[i-1][j-1] + 1);
        &#125;
    cout &lt;&lt; f[n][m];
    return 0;
&#125;
</code></pre>
<p>数学快速幂</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
int a, b;
int qpow(int a, int b) &#123;
    int ans = 1;
    while (b) &#123;
        if (b &amp; 1) 
            ans = ans * a;
        a *= a;
        b &gt;&gt;= 1;	
    &#125;
    return ans;
&#125;
int main() &#123;
    cin &gt;&gt; a &gt;&gt; b;
    cout &lt;&lt; qpow(a, b);
&#125;
</code></pre>
<p>筛质数</p>
<pre><code>int p[N], cnt;
bool st[N];
void get_primes(int n) &#123;//埃氏筛
    for (int i = 2; i &lt;= n; i++) &#123;
        if (!st[i]) &#123;
            p[cnt++] = n;
            for (int j = i + i; i &lt;= n; j +=i)st[j] = true;
        &#125;
    &#125;
&#125;
void get_primes1(int n) &#123;//线性筛
    for ( int i = 2; i &lt;= n; i++) &#123;
        if (!st[i])p[cnt++] = i;
        for (int j = 0; p[j] &lt;= n / i; j++) &#123;
            st[p[j] * i] = true;
            if (i % p[j] == 0)break;//p[j]一定是i的最小质因子
        &#125;
    &#125;
&#125;
</code></pre>
<p>最大公约数欧几里得</p>
<pre><code>int gcd(int a, int b) &#123;
    return b ? (b, a % b) : a;//如果b不是0，返回(b, a % b)，如果b是0，返回a
&#125;
</code></pre>
<p>求约数个数，求约数之和</p>
<pre><code>//给定n个正整数，输出这些数字乘积的约数个数，答案对1e9+7取模
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;unordered_map&gt;
using namespace std;
typedef long long ll;
const int mod = 1e9 + 7;
int main() &#123;
    int n;
    cin &gt;&gt; n;
    unordered_map&lt;int, int &gt; primes;
    while (n--) &#123;
        int x;
        cin &gt;&gt; x;
        for (int i = 2; i &lt;= x / i; i++) &#123;
            while (x % i == 0) &#123;
                primes[i]++;
                x /= i;
            &#125;
        &#125;
        if (x &gt; 1)primes[x]++;
    &#125;
    ll res = 1;
    //for (auto tt : primes)res = res * (tt.second + 1) % mod;//求约数的个数
    //求约数之和
    for (auto tt : primes) &#123;
        int p = tt.first, a = tt.second;
        ll t = 1;
        while (a--)t = (t * p + 1) % mod;
        res = res * t % mod;
    &#125;
    cout &lt;&lt; res &lt;&lt; endl;
&#125;
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 vite的避难所
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Zhz-Vite
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
