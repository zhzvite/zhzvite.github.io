
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>第一个板子 | vite的避难所</title>
    <meta name="author" content="Zhz-Vite" />
    <meta name="description" content="认真做好每件事" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>VITE的避难所</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;VITE的避难所</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>第一个板子</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/10/24
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="color: #ff7d73">学习笔记</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h2 id="缺省源"><a href="#缺省源" class="headerlink" title="缺省源"></a>缺省源</h2><pre><code class="c++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;iomanip&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;ctime&gt;
#include&lt;stack&gt;
using namespace std;
template&lt;typename T&gt;
inline void read(T&amp; x) &#123;
    x = 0;
    bool flg = 0;
    char c = getchar();
    for (; !isdigit(c); c = getchar())
        if (c == &#39;-&#39;)flg = 1;
    for (; isdigit(c); c = getchar())x = x * 10 + (c ^ 48);
    if (flg)x = -x;
&#125;
</code></pre>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><pre><code class="c++">//l=第一个存放的位置,r=最后一个存放的位置
void quick_sort(long long int a[], int l, int r) &#123;
    int x = a[(r+l)/2];
    int i = l-1;
    int j = r+1 ;
    if (l &gt;= r)return;
    while (i &lt;j) &#123;
        do i++; while (a[i] &lt; x);
        do j--; while (a[j] &gt; x);//一定要记住这个do while他和while 不一样，写while会死，直接咋-1死掉
        if (i &lt; j) &#123;
            swap(a[i], a[j]);
        &#125;
    &#125;quick_sort(a, l, j);
    quick_sort(a, j+1, r);
    
&#125;
</code></pre>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><pre><code class="c++">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int N = 100000;
int n;
int q[N], tmp[N];
void merge_sort(int q[], int l, int r)
&#123;
    if(l &gt;= r) return;
    int mid = l + r &gt;&gt;1;
    merge_sort(q, l, mid);
    merge_sort(q, mid+1, r);
    int k = 0, i = l, j = mid+1;
    while(i &lt;= mid &amp;&amp; j &lt;= r)
    &#123;
        if(q[i] &lt;= q[j]) tmp[k++] = q[i++];
        else tmp[k++] = q[j++];
    &#125;
    while(i &lt;= mid) tmp[k++] = q[i++];
    while(j &lt;= r) tmp[k++] = q[j++];
    for(i = l, j = 0; i &lt;= r; i++, j++) q[i] = tmp[j];
&#125;
int main()
&#123;
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;q[i]);
    merge_sort(q, 0, n-1);
    for(int i = 0; i &lt;n ; i++) printf(&quot;%d&quot;, q[i]);
    return 0;
&#125;
</code></pre>
<h2 id="二分法-整数二分"><a href="#二分法-整数二分" class="headerlink" title="二分法(整数二分)"></a>二分法(整数二分)</h2><pre><code class="c++">sort(a, a + n, less&lt;int&gt;());//进行升序排序
sort(a, a + n, greater&lt;int&gt;());//降序排序
int i = -1, j = n;//这是重点,把起点放在数组外面
if (i + 1 == j)&#123;
    cout &lt;&lt; &quot; false&quot; &lt;&lt; endl; return 0;
  &#125;//判断空

if (k&lt;a[0] || k&gt;a[n - 1]) &#123;
    cout &lt;&lt; &quot; out&quot; &lt;&lt; endl;
    return 0;//判断极端情况,k为flag
&#125;
while (i+1!=j) &#123;
    int x = (i + j) / 2;
    if (k &lt;= a[x])j = x;//这些不等关系要依据条件,根据红区蓝区来分析
    if (k &gt; a[x])i = x;
&#125;
</code></pre>
<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><pre><code class="c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
bool cmp(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)
&#123;
    if(A.size() != B.size()) return A.size() &gt; B.size();
    for(int i = A.size() -1; i &gt;= 0; i--)
        if(A[i] != B[i])
            return A[i] &gt; B[i];
    return true;
&#125;//比较大小
vector&lt;int&gt; div1(vector&lt;int&gt; &amp;A, int b, int&amp; r)
&#123;
    vector&lt;int&gt; C;
    r = 0;
    for(int i = A.size() - 1; i &gt;= 0; i--)
    &#123;
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b; 
    &#125;
    reverse(C.begin(), C.end());
    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back() ;
    return C;
&#125;
vector&lt;int&gt; mul1(vector&lt;int&gt; &amp;A, int b)
&#123;
    vector&lt;int&gt; C;
    int t = 0;
    for(int i = 0; i &lt; A.size() || t; i++)
    &#123;
         if(i &lt; A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10; 
    &#125;
    return C;
&#125;
vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)
&#123;
    vector&lt;int&gt; C;
    for(int i = 0, t = 0; i &lt; A.size(); i++)
    &#123;
        t = A[i] - t;
        if(i &lt; B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if(t &lt; 0) t = 1;
        else t = 0;  
    &#125;
    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();
    return C;
&#125;
vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)
&#123;
    vector&lt;int&gt; C;
    int t = 0;
    for(int i = 0; i &lt; A.size() || i &lt; B.size(); i++)
    &#123;
        if(i &lt; A.size()) t += A[i];
        if(i &lt; B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;  
    &#125;
    if(t) C.push_back(1);
    return C;
&#125;
int main()
&#123;
    string a, b;
    vector&lt;int&gt; A, B;
    cin &gt;&gt; a &gt;&gt; b;
    //scanf(&quot;%s%s&quot;, &amp;a, &amp;b);
    for(int i = a.size() - 1; i &gt;= 0; i--) A.push_back(a[i] - &#39;0&#39;);
    for(int i = b.size() - 1; i &gt;= 0; i--) B.push_back(b[i] - &#39;0&#39;);
    
    vector&lt;int&gt; Ca = add(A, B);
    for(int i = Ca.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, Ca[i]);//+
    printf(&quot;\n&quot;);

    if(cmp(A, B))&#123;
        vector&lt;int&gt; Cb = sub(A, B);
        for(int i = Cb.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, Cb[i]);
    &#125; else&#123;
        vector&lt;int&gt; Cb = sub(B, A);
        printf(&quot;-&quot;);
        for(int i = Cb.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, Cb[i]);//-
        printf(&quot;\n&quot;);
    &#125; 
    int n = 0;
    scanf(&quot;%d&quot;, &amp;n);
    vector&lt;int&gt; Cc = mul1(A, n);
    for(int i = Cc.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, Cc[i]);//*
    printf(&quot;\n&quot;);
    int m = 0, r = 0;
    scanf(&quot;%d&quot;, &amp;m);
    vector&lt;int&gt; Cd = div1(A, m, r);
    for(int i = Cd.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, Cd[i]);///
    printf(&quot; %d\n&quot;, r);
    return 0;
&#125;
</code></pre>
<h2 id="二维前缀和差分"><a href="#二维前缀和差分" class="headerlink" title="二维前缀和差分"></a>二维前缀和差分</h2><pre><code>//要有开始，要有结尾
void insert(int x1, int y1, int x2, int y2, int c) &#123;
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;//这是一个重要的预处理步骤
    //不仅在前面完成了b数组的初始化，并且在插入过程中完成的b的增值
&#125;
int main() &#123;
    int n, m,q, x1, x2, y1, y2,c;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
    for (int i = 1; i &lt;= n; i++) &#123;
        for (int j = 1; j &lt;= m; j++) &#123;
            cin &gt;&gt; a[i][j];
        &#125;
    &#125;//初始化a数组
    for (int i = 1; i &lt;= n; i++) &#123;
        for (int j = 1; j &lt;= m; j++) &#123;
            insert( i,  j,  i,  j, a[i][j]);//先遍历一遍数组b，进行插入,使得b是a的差分
        &#125;
    &#125;
    while (q--)
    &#123;
        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;
        insert(x1, y1, x2, y2, c);
        //再求b的前缀和
    &#125;
    for (int i = 1; i &lt;= n; i++) &#123;
        for (int j = 1; j &lt;= m; j++) &#123;
            //求数组b的前缀和
            b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];
            // 因为我们最后要求的是加完了c后的a数组，而b的前缀和是a数组，所以我们直接算出b的前缀和就行
        &#125;
    &#125;
    for (int i = 1; i &lt;= n; i++) &#123;
        for (int j = 1; j &lt;= m; j++) &#123;
            cout &lt;&lt; b[i][j] &lt;&lt; &quot; &quot;;
        &#125;cout &lt;&lt; endl;
    &#125;
&#125;
</code></pre>
<h2 id="最长连续不重复子序列"><a href="#最长连续不重复子序列" class="headerlink" title="最长连续不重复子序列"></a>最长连续不重复子序列</h2><pre><code>//用两个指针，降低暴力枚举的O(n^2)的时间复杂度
//解决重复数字，输出不重复数字的总数
int main() &#123;
    int a[N], s[N];
    memset(s,0,sizeof 0);
    int n;
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++)cin &gt;&gt; a[i];
    int res = 0;
    for (int i = 0, j = 0; i &lt; n; i++) &#123;
        s[a[i]]++;
        while (s[a[i]] &gt; 1) &#123;
            s[a[j]]--;//以s的数组来记录次数
            j++;
        &#125;
        res = max(res, i - j + 1);
    &#125;cout &lt;&lt; res &lt;&lt; &quot; &quot;;
&#125;
</code></pre>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><pre><code>//这里重点记录以下位运算的基本和应用
int lowbit(int x) &#123;
     return x &amp; (-x);
&#125;//巧妙的利用了源码和补码的性质，返回x的二进制最后以一结尾的一串二进制码
int main()
&#123;       int x=10;
for (int i = 0; i &lt; 4; i++) &#123;
cout &lt;&lt; (x &lt;&lt; i)&lt;&lt;endl;//将x左移i位,即以2倍式递增&#125;
        cin &gt;&gt; x;
        int res = 0;
        while (x) &#123;
            x -= lowbit(x);
            res++;
        &#125;
        cout &lt;&lt; res &lt;&lt; &quot; &quot;;//利用此段程序，算出录入的每个数字的二进制一有多少个
&#125;
</code></pre>
<h2 id="离散化-适用于值域很大-数据量很小"><a href="#离散化-适用于值域很大-数据量很小" class="headerlink" title="离散化(适用于值域很大,数据量很小)"></a>离散化(适用于值域很大,数据量很小)</h2><pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef pair&lt;int ,int &gt; pii;
vector&lt;int&gt; alls;
vector&lt;pii&gt; add, query;
const int N = 300010;
int n, m;
int a[N], s[N];//a[存放数组离散前的]s算前缀和
int find(int x) &#123;
    int l = -1; int r = alls.size();
    while (l + 1 != r) &#123;//采用二分寻找答案,找到第一个大于等于x的位置
        int mid = (r + l) &gt;&gt; 1;
        if (alls[mid]&gt;=x)r = mid;
        else l = mid;
    &#125;return r + 1;//将x映射到1-alls.size,x表示位置
&#125;
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 0; i &lt; n; i++) &#123;
        int x, c;
        cin &gt;&gt; x &gt;&gt; c;
        alls.push_back(x);
        add.push_back(&#123; x,c &#125;);//数据存入
    &#125;
    for (int i = 0; i &lt; m; i++) &#123;
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        query.push_back(&#123; l,r &#125;);
        alls.push_back(l);
        alls.push_back(r);//将数据分别存到三个数组当中

    &#125;
    //去重
    sort(alls.begin(), alls.end());//排序
    alls.erase(unique(alls.begin(), alls.end()), alls.end());//去重，返回去重完alls的末尾位置,必须要先排序再去重
    for (auto item : add) &#123;//对add中的每个元素进行迭代
        int x = find(item.first);
        a[x] += item.second;
    &#125;
    //预处理前缀和 
    for (int i = 1; i &lt;= alls.size(); i++)s[i] = s[i - 1] + a[i];//位置寄托在alls中，数寄托在a【i】中
    //处理询问
    for (auto item : query) &#123;
        int l = find(item.first), r = find(item.second);//将l和r在alls里面映射
        cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl;
    &#125;
&#125;
</code></pre>
<h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><pre><code>typedef pair &lt;int, int &gt;  pii;
const int N = 100010;
int n;
vector&lt;pii&gt; segs;
void merge(vector&lt;pii&gt;&amp; segs) &#123;//解决不同的三种情况分别是无交集，有交集，在里面；(引用,占用空间少一点)
    vector&lt;pii&gt;  res;
    sort(segs.begin(), segs.end());
    int st = -2e9, ed = -2e9;
    for (auto seg : segs)&#123;
        if (ed &lt; seg.first) &#123;
            if (st != -2e9)res.push_back(&#123; st,ed &#125;);
            st = seg.first, ed = seg.second;
            &#125;
        else ed = max(ed, seg.second);
&#125;
        if (st != -2e9)res.push_back(&#123; st,ed &#125;);//用在最后退出循环后，把st和ed的值录进数组
        segs = res;//把res的结果丢到seg里面，即最后合并后的区间数
    
&#125;
int main() &#123;
    cin &gt;&gt; n;
    while (n--) &#123;
        int l, r;
        cin &gt;&gt; l &gt;&gt; r;
        segs.push_back(&#123; l,r &#125;);//存放的是坐标
    &#125;
    merge(segs);
    cout &lt;&lt; segs.size() &lt;&lt; endl;
&#125;
</code></pre>
<h2 id="单调队列之滑动窗口"><a href="#单调队列之滑动窗口" class="headerlink" title="单调队列之滑动窗口"></a>单调队列之滑动窗口</h2><pre><code>int a[N], q[N];//a[N]表示数的存放集合,q[N]表示数的下标的集合
int main() &#123;
    int hh = 0;//hh判断队列长度，hh是队尾
    int tt = -1;//tt表示次序，tt是对头
    for (int i = 0; i &lt; n; i++) &#123;
        //判断对头是否已经滑出窗口
        while (hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh])hh++;//while肯定行,但一次肯定是一个出,所以用if也行
        while (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i])tt--;//要构造一个单调递增数列
        q[++tt] = i;//把下标该放的位置
        if (i &gt;= k - 1)cout &lt;&lt; a[q[hh]] &lt;&lt;&quot; &quot;;
    &#125;
&#125;
</code></pre>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><pre><code>//这里努力写个程序实现静态链表（以数组构成链表
//还是要画图理解
#include&lt;iostream&gt;
using namespace std;
const int N = 100010;
//head=头结点,e[i]表示节点i的值,ne【i】表示节点i的next指针,idx表示储存的点的次序
int head, e[N], ne[N], idx;
void init() &#123;
    head = -1;
    idx = 0;
&#125;//对head和idx进行初始化
//将x插到头结点
void addhead(int x) &#123;
    e[idx] = x, ne[idx] = head, head = idx++;
&#125;
void addk(int k,int x) &#123;
    e[idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx;
    idx++;
&#125;//将x插到k后面，和头插法没什么区别
//将下标是k后面的一个点删掉
void remove(int k) &#123;
    ne[k] = ne[ne[k]];//链表是一个递归，可以理解为ne记录的是下一个数据的idx
&#125;
</code></pre>
<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><pre><code>int m,k,x;
int e[N], l[N], r[N], idx;
//类似单链表进行初始化
void init() &#123;
    //0表示左端点，1表示右端点
    l[1] = 0;
    r[0] = 1;//r表示从左往右，l表示从右往左
    idx = 2;
&#125;
//在下表是k的右边边插入一个点
void addk(int k, int x) &#123;
    e[idx] = x;
    r[idx] = r[k];
    l[idx] = k;
    l[r[k]] = idx;
    r[k] = idx;
    idx++;
&#125;
//删除第k个点
void remove(int k) &#123;
    r[l[k]] = r[k];
    l[r[k]] = l[k];
&#125;
</code></pre>
<h2 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h2><pre><code>//p是模板串,s是长文本
char p[N], s[M];
int ne[N];
int main() &#123;
    cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;//p+1是指从第一位开始存
    //求next的过程,模板串
    for (int i = 2, j = 0; i &lt;= n; i++) &#123;//这里的ne【i】指的是前1-i项构成的序列中前缀和后缀相同的长度
        while (j &amp;&amp; p[i] != p[j + 1])j = ne[j];
        if (p[i] == p[j + 1])j++;
        ne[i] = j;
    &#125;
    //kmp 匹配过程
    for (int i = 1, j = 0; i &lt;= m; i++) &#123;
        while (j &amp;&amp; s[i] != p[j + 1])j = ne[j];
        if (s[i] == p[j + 1])j++;
        if (j == n) &#123;
            cout &lt;&lt; i - n&lt;&lt;&quot; &quot;;
            j = ne[j];//匹配成功
        &#125;
    &#125;
    return 0;
&#125;									
</code></pre>
<h2 id="trie字典树"><a href="#trie字典树" class="headerlink" title="trie字典树"></a>trie字典树</h2><pre><code>//高效存储和查询字符串集合的数据结构
//通过一颗多分枝的树来高效存储,每一个分支都是一个字符串
int son[N][26],cnt[N],idx;//下标是0的点,既是空节点,又是根节点
char str[N];//输入字符串
void insert(char str[]) &#123;//输入一整个字符串
    int p = 0;
    for (int i = 0; str[i]; i++) &#123;
        int u = str[i] - &#39;a&#39;;//将字符串转化成数字
        if (!son[p][u])son[p][u] = ++idx;//idx储存的是当前用到的下标,下标唯一，往里面存储位置
        p = son[p][u];
    &#125;
    cnt[p]++;//p是标记，类似于终止标记
    //注意这里son[0][]存的是字符串的第一个字母，之后p会++，若该存的位置有被占用了，则会跳过，p自动继承，进行下一次循环
&#125;
int query(char str[]) &#123;
    int p = 0;
    for (int i = 0; str[i]; i++) &#123;
        int u = str[i] - &#39;a&#39;;
        if (!son[p][u])return 0;
        p = son[p][u];
    &#125;
    return cnt[p];
&#125;
int main() &#123;
    int n;
    cin &gt;&gt; n;//n为n次操作
    while (n--) &#123;
        char op[2];
        cin &gt;&gt; op;
        cin &gt;&gt; str;
        if (op[0] == &#39;I&#39;)insert(str);//执行插入操作
        else cout &lt;&lt; query(str);//执行寻找操作
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><pre><code>//反集,将a和n+b,n+a和b分别合并
//并查集巧妙地利用了递归，每次更新后都会形成新的集合，同时用递归对路迳进行了压缩
int n, m;
int p[N];
int find(int x) &#123;//返回x的祖宗节点,同时对路径进行压缩
    if (p[x] != x)p[x] = find(p[x]);//采用递归,找到他的父节点,同时进行了路径压缩,便于优化后面的索
    return p[x];//最后求出祖宗节点
 &#125;
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++)p[i]=i;//初始化数组p,使得每个都是其父节点,从i等于1开始
    while (m--) &#123;
        char op[2];
        int a, b;
        cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;
        if (op[0] == &#39;M&#39;)p[find(a)] = find(b);//祖宗节点的父节点为b的祖宗节点,使得a的祖宗节点放在b的祖宗节点下达到合并集合的效果
        else &#123;
            if (find(a) == find(b))cout &lt;&lt; &quot;Yes&quot;;
            else cout &lt;&lt; &quot;No&quot;;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="size的维护"><a href="#size的维护" class="headerlink" title="size的维护"></a>size的维护</h2><pre><code>//p[]存每个点的祖宗节点，size[]只有祖宗节点的有意义，表示祖宗节点所在集合中点的数量
int p[N],size[N];
//返回x的祖宗节点
int find(int x)&#123;
    if(p[x]!=x) p[x]=find(p[x]);
    return p[x];
&#125;
//初始化，假定节点编号为1~n
for(int i=1;i&lt;=n;i++)&#123;
    p[i]=i;
    size[i]=1;
&#125;
//合并a和b所在的两个集合
size[find(b)]+=size[find(a)];
p[find(a)]=find(b);
</code></pre>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><pre><code>//堆排序
/*
1.插入一个数heap[++size]=x;up(size);
2.求集合中最小值 heap(1);heap从零开始则左右子树不一致，不太方便
3.删除最小值     heapp[1]=heap[size];size--;down(1);	
4.删除任意一个元素 heap[k]=heap[size];size--;down(k)/up(k
5.修改任意一个元素heap(k)=x；down(k)/up(k)
小根堆：每个点都满足小于等于左右两边的son
存储方式：用一个一维数组来存，一号点为根节点
*/
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 100010;
int h[N], s,m,n;
void down(int u) &#123;
    int t = u;
    if (u * 2 &lt;= s &amp;&amp; h[u * 2] &lt; h[t])t = u * 2;
    if (u * 2 + 1 &lt;= s &amp;&amp; h[u * 2 + 1] &lt; h[t])t = u * 2 + 1;
    if (t != u) &#123;
        swap(h[t], h[u]);
        down(t);
    &#125;
&#125;
void  up(int u) &#123;
    while (u / 2 &amp;&amp; h[u / 2] &gt; h[u])
    &#123;
        swap(h[u / 2], h[u]);
        u /= 2;   
    &#125;
&#125;
int main() &#123;
    cin &gt;&gt; n&gt;&gt;m;
    for (int i = 1; i &lt;= n; i++)cin &gt;&gt; h[i];
    s = n;
    for (int i = n/2 ; i; i--)down(i);// 用n/2是为了因为降低时间复杂度，因为最后一层二叉树占接近全部的一半
    while (m--) &#123;
        cout &lt;&lt; h[1];
        h[1]=h[s];
        s--;
        down(1);
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="堆模拟"><a href="#堆模拟" class="headerlink" title="堆模拟"></a>堆模拟</h2><pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 100010;
int  m;
int h[N], ph[N], hp[N], s;
void hswap(int a, int b) &#123;
    swap(ph[hp[a]], ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
&#125;
void down(int u) &#123;
    int t = u;
    if (u * 2 &lt;= s &amp;&amp; h[u * 2] &lt; h[t])t == u * 2;
    if (u * 2 + 1 &lt;= s &amp;&amp; h[u * 2 + 1] &lt; h[t])t == u * 2 + 1;
    if (u != t) &#123;
        hswap(t, u);
        down(t);
    &#125;
&#125;
void up(int u) &#123;
    while (u / 2 &amp;&amp; h[u / 2] &gt; h[u])
    &#123;
        hswap(u / 2, u);
        u /= 2;
    &#125;
&#125;
int main() &#123;
    int n,k,x;
    cin &gt;&gt; n;
    while (n--) &#123;
        char op[3];
        cin &gt;&gt; op;
        if (op[0] == &#39;I&#39;) &#123;
            cin &gt;&gt; x;
            s++;//在堆中的位置
            m++;//在次序中的位置
            ph[m] = s;
            hp[s] = m;//两者类似反函数，互相映射
            h[s] = x;
            up(s);//最末尾往上up
        &#125;
        else if (op[0] == &#39;P&#39; &amp;&amp; op[1] == &#39;M&#39;) cout &lt;&lt; h[1];//输出集合中最小值
        else if (op[0] == &#39;D&#39; &amp;&amp; op[1] == &#39;M&#39;) &#123;//删除集合中最小值
            hswap(1, s);
            s--;
            down(1);
        &#125;
        else if (op[0] == &#39;D&#39;) &#123;//删除第k个插入的数
            cin &gt;&gt; k;
            k = ph[k];//新的位置
            hswap(k, s);
            s--;
            down(k), up(k);
        &#125;
        else &#123;// C  修改第k个插入的数
            cin &gt;&gt; k &gt;&gt; x;
            k = ph[k];
            h[k] = x;
            down(k), up(k);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="一般哈希"><a href="#一般哈希" class="headerlink" title="一般哈希"></a>一般哈希</h2><p><strong>拉链法</strong></p>
<pre><code>const int N = 100003;//一般mol的数要选择一个质数
int h[N],e[N],ne[N],idx;
void insert(int x) &#123;
    //将x映射到哈希函数上
    int k = (x % N + N) % N;
    e[idx] = x, ne[idx] = h[k], h[k] = idx++;//单链表的插入
&#125;
bool find(int x) &#123;
    int k = (x % N + N) % N;//k是映射到哈希函数上的值，使得复数mol完后变成一个整数，在c++中负数mol完会变成负数
    for (int i = h[k]; i != -1; i = ne[i]) &#123;
        if (e[i] == x)
            return true;&#125;
    return false;//return false 是最后的判断，若是找不到就返回false
&#125;
int main() &#123;
    int n;
    cin &gt;&gt; n;
    memset(h, -1, sizeof h);//所有初始化,初始化为-1,拉链法
    while (n--) &#123;
        char op[2];
        int x;
        cin &gt;&gt; op &gt;&gt; x;
        if (op[0] == &#39;I&#39;)insert(x);
        else &#123;
            if (find(x))cout &lt;&lt; &quot;yes&quot;&lt;&lt;endl;
            else cout &lt;&lt; &quot;No&quot;&lt;&lt;endl;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<p><strong>开放寻址法</strong></p>
<pre><code class="c++">const int N = 200003, null = 0x3f3f3f3f;//null是数据取不到的，开了两倍的坑位
int h[N];
int find(int x) &#123;//上厕所法，返回要存放的位置或者是他在的地方
    int k = (x % N + N) % N;   
    while (h[k] != null &amp;&amp; h[k] != x) &#123;
        k++;
        if (k == N)k = 0;
    &#125;
    return k;
&#125;
int main() &#123;
    int n;
    cin &gt;&gt; n;
    memset(h, 0x3f, sizeof h);//memset是针对字节memset，h数组有四个字节，每个字节都是ox3f 
    while (n--) &#123;
        char op[2];
        int x;
        cin &gt;&gt; op&gt;&gt;x;
        int k = find(x);
        if (op[0] == &#39;I&#39;)h[k] = x;
        else &#123;if (h[k] != null)cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl;
            else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><pre><code class="c++">//思路:存放str，同时进行m次询问，利用前缀和预处理，进行p进制转换
const int N = 100010,t=131;//将字母转化为t进制的数，将字符串的哈希值进行比较
typedef unsigned long long ull;//用ull则溢出的话就认为是取模于2的64次方
int n, m;
char str[N];
ull h[N], p[N];
ull get(int l, int r) &#123;
    return h[r] - h[l - 1] * p[r - l + 1];//求l和r之间字符串的哈希值
&#125;
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; str+1;//str+1表示第0位不放数据
    p[0] = 1;
    for (int i = 1; i &lt;= n; i++) &#123;
        p[i] = p[i - 1] * t;//表示次方
        h[i] = h[i - 1] * t + str[i];//将他变为数字
    //	cout &lt;&lt; str[1] &lt;&lt; &quot; &quot; &lt;&lt; h[1];
    &#125;
    while (m--) &#123;
        int l1, r1, l2, r2;
        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;
        if (get(l1, r1) == get(l2, r2)) cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl;
        else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;	
    &#125;
&#125;
</code></pre>
<h2 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h2><pre><code class="c++">const int N = 110;
typedef pair&lt;int, int&gt; pii;
int n, m;
int g[N][N], d[N][N];//g负责存地图，d负责记录有没有走过
pii q[N * N],p[N ][N];
int bfs() &#123;
    int dx[4] = &#123; -1,0,1,0 &#125;, dy[4] = &#123; 0,1,0,-1 &#125;;
    int hh = 0, tt = 0;//采用栈的形式进行数据的堆叠
    memset(d, -1, sizeof d);
    q[0] = &#123; 0,0 &#125;;
    d[0][0] = 0;
    while (hh &lt;= tt) &#123;
        auto t = q[hh++];
        for (int i = 0; i &lt; 4; i++) &#123;
            int x = t.first + dx[i], y = t.second + dy[i];//上下左右遍历
            if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] == 0 &amp;&amp; d[x][y] == -1) &#123;
                d[x][y] = d[t.first][t.second] + 1;//记录他是几号点
            //	d[x][y] = 1;
                p[x][y] = t;//把上一个点塞进去了，类似于递归
                q[++tt] = &#123; x,y &#125;;//满足条件则往栈顶压入数据
            &#125;
        &#125;
    &#125;
    //输出路迳   
    int x = n - 1, y = m - 1;
    while (x || y) &#123;
        cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;
        auto t = p[x][y];
        x = t.first, y = t.second;
    &#125;
    return d[n - 1][m - 1];
&#125;
int main() &#123;
    cin &gt;&gt; n&gt;&gt;m;
    for (int i = 0; i &lt; n; i++) &#123;
        for (int j = 0; j &lt; m; j++)cin &gt;&gt; g[i][j];
    &#125;
    cout&lt;&lt;bfs()&lt;&lt;endl;
&#125;
</code></pre>
<h2 id="图的拓扑排序-有向无环图一定有拓扑序列"><a href="#图的拓扑排序-有向无环图一定有拓扑序列" class="headerlink" title="图的拓扑排序(有向无环图一定有拓扑序列)"></a>图的拓扑排序(有向无环图一定有拓扑序列)</h2><pre><code class="c++">int n, m;
int h[N], e[N], ne[N], idx;
int q[N], d[N];//q[N]为队列，d[N]是入度
void add(int a, int b)
&#123;
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
&#125;
bool topsort() &#123;//队列中hh是对头，tt是队尾
    int hh = 0, tt = -1;
    for (int i = 1; i &lt;= n; i++) &#123;
        if (!d[i])q[++tt] = i;&#125;//将入度为0的点放进队列
        while (hh &lt;= tt) &#123;
            int t = q[hh++];
            for (int i = h[t]; i != -1; i = ne[i]) &#123;
                int j = e[i];
                d[j]--;//让入度减减
                if (d[j] == 0)q[++tt] = j;//当入度减为零了，将他压入队列
            &#125;
        &#125;
    return tt == n - 1;//判断它是不是有向无环图
&#125;//q中存的就是拓扑排好的序列,d存的是每个点的入度
</code></pre>
<h2 id="朴素dijkstra算法，单源求最短路"><a href="#朴素dijkstra算法，单源求最短路" class="headerlink" title="朴素dijkstra算法，单源求最短路"></a>朴素dijkstra算法，单源求最短路</h2><pre><code class="c++">int g[N][N];
int dist[N];
bool st[N];
int dijkstra() &#123;
    memset(st, false, sizeof st);
    dist[1] = 0;
    for (int i = 0; i &lt; n; i++)
    &#123;
        int t = -1;
        for (int j =1; j &lt;=n; j++) &#123;
            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))
                t = j;
        &#125;
        st[t] = true;
        for (int j = 1; j &lt;= n; j++) &#123;
            dist[j] =min(dist[j], dist[t] + g[t][j]);
        &#125;
    &#125;
    if (dist[n] == 0x3f3f3f3f)return -1;
    else return dist[n];
&#125;
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m;
    memset(dist, 0x3f, sizeof dist);
    memset(g, 0x3f, sizeof g);
    while (m--) &#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        g[a][b] = min(g[a][b], c);
    &#125;
    int t = dijkstra();
    cout &lt;&lt; t;
&#125;
</code></pre>
<h2 id="堆优化版本的dijkstra"><a href="#堆优化版本的dijkstra" class="headerlink" title="堆优化版本的dijkstra"></a>堆优化版本的dijkstra</h2><pre><code class="c++">//有向图求最短路
using namespace std;
const int N = 510;
int n, m;
int w[N], h[N], e[N], ne[N], idx;
int dist[N];
bool st[N];
typedef pair&lt;int, int&gt; pii;
priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; heap;
void add(int a,int b,int c) &#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
&#125;
int dijkstra() &#123;
    memset(dist ,0x3f,sizeof dist);
    memset(st, false, sizeof st);
    heap.push(&#123; 0,1 &#125;);//0表示dist【】，
    while (heap.size()) &#123;
     auto t = heap.top();
     heap.pop();
     int distance = t.first, val = t.second;
     if (st[val])continue;
       for (int i = h[val]; ~i; i = ne[i]) &#123;
          int j = e[i];
           if (dist[j] &gt; distance+w[i])  &#123; 
                      dist[j] = distance + w[i];
                    heap.push(&#123; dist[j],j &#125;);//前一项表示到1的距离，后一项表示这个点
                  &#125;   
              &#125;
         &#125;
     if (dist[n] == 0x3f3f3f3f)return -1;
     else return dist[n];
    &#125;
</code></pre>
<h2 id="spfa算法-求单源最短路迳，可以有负环"><a href="#spfa算法-求单源最短路迳，可以有负环" class="headerlink" title="spfa算法&#x2F;&#x2F;求单源最短路迳，可以有负环"></a>spfa算法&#x2F;&#x2F;求单源最短路迳，可以有负环</h2><pre><code class="c++">//spfa算法
#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 10010;
int ne[N], idx, e[N], h[N], w[N];
int dist[N];
bool st[N];
int n, m;
void add(int a, int b, int  c) &#123;
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;
&#125;
int spfa() &#123;
    memset(st, false, sizeof st);
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    queue&lt;int&gt; q;
    q.push(1);
    st[1] = true;
    while (q.size()) &#123;
        int t = q.front();
            q.pop();
            st[t] = false;
            for (int i = h[t]; ~i; i = ne[i]) &#123;
                int j = e[i];
                if (dist[j] &gt; dist[t] + w[i]) &#123;
                    dist[j] = dist[t] + w[i];
                    //cnt[j]=cnt[t]+1; if(cnt[j]&gt;=n)return true;判断负环
                    if (!st[j]) &#123;
                        q.push(j);
                        st[j] = true;
                    &#125;
                &#125;	
            &#125;
    &#125;
    if (dist[n] == 0x3f3f3f3f)return -1;
    else return dist[n];
&#125;
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof h);
    for (int i = 1; i &lt;= m; i++) &#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a, b, c);
    &#125;
    int t = spfa();
    if (t == -1)cout &lt;&lt; &quot; no&quot;;
    else cout &lt;&lt; t;
&#125;
</code></pre>
<h2 id="有边数限制的最短路bell-man-ford算法"><a href="#有边数限制的最短路bell-man-ford算法" class="headerlink" title="有边数限制的最短路bell-man ford算法"></a>有边数限制的最短路bell-man ford算法</h2><pre><code class="c++">//在边数限定条件的最短路
using namespace std;
const int  N = 10010;
int dist[N], backup[N];
int n, m, k;
struct Edge &#123;
    int a, b, w;
&#125;edge[N];
int bellman_ford() &#123;
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    for (int i = 0; i &lt; k; i++) &#123;
        memcpy(backup, dist, sizeof dist);
        for (int j = 1; j &lt;= m; j++) &#123;
            int x = edge[j].a, y = edge[j].b, z = edge[j].w;
            dist[y] = min(dist[y], backup[x] + z);
        &#125;
    &#125;
    if (dist[n] &gt;0x3f3f3f3f / 2)return -1;//存在负权，有可能是0x3f3f3f3f-2，小于0x3f3f3f3f
    else return dist[n];
&#125;
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    for (int i = 1; i &lt;= m; i++) &#123;
        int x, y, z;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
        edge[i] = &#123; x,y,z &#125;;
    &#125;
    int t = bellman_ford();
    if (t == -1)cout &lt;&lt; &quot;impossible&quot;;
    else cout &lt;&lt; t;
&#125;
</code></pre>
<h2 id="floyd算法求多源最短路"><a href="#floyd算法求多源最短路" class="headerlink" title="floyd算法求多源最短路"></a>floyd算法求多源最短路</h2><pre><code class="c++">const int N = 210,inf=0x3f3f3f3f;
int n, m, q;
int dist[N][N];
void floyd() &#123;//基于动态规划的算法的k次前k-1次的点有关
    for (int k = 1; k &lt;= n; k++)
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= n; j++)
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
&#125;
int main() &#123;
    std::ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
    for (int i = 1; i &lt;= n; i++) &#123;
        for (int j = 1; j &lt;= n; j++) &#123;			
            if (i == j)dist[i][j] == 0;
            else dist[i][j] = inf;
         &#125;
    &#125;
    while (m--) &#123;//录入防止重边
        int x, y, z;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
        dist[x][y] = min(dist[x][y],z);
    &#125;
    floyd();
    while (q--) &#123;//输出多源最短路
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        if (dist[a][b] &gt; inf / 2)cout &lt;&lt; &quot;impossible&quot;;
        else cout &lt;&lt; dist[a][b];
    &#125;	
&#125;
</code></pre>
<h2 id="kruskal求最小生成树"><a href="#kruskal求最小生成树" class="headerlink" title="kruskal求最小生成树"></a>kruskal求最小生成树</h2><pre><code class="c++">const int N = 200010;
int p[N];
int n, m;
struct Edge &#123;
    int a, b, w;
    bool operator&lt; (const Edge &amp;W)const &#123;
        return w &lt; W.w;
    &#125;//在之后针对w进行排序
&#125;edges[N];
int find(int x) &#123;
    if (p[x] != x)p[x] = find(p[x]);
    return p[x];
&#125;
int main() &#123;
    cin &gt;&gt;n &gt;&gt; m;
    for (int i = 0; i &lt;= n; i++) &#123;
        int a, b, w;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;
        edges[i] = &#123; a,b,w &#125;;
    &#125;
    sort(edges, edges + m);//按w的权重进行排序
    int res = 0, cnt = 0;
    for (int i = 1; i &lt;= n; i++)p[i] = i;
    for (int i = 0; i &lt;m; i++) &#123;
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
        a=find(a); 
        b = find(b);
        if (a != b) &#123;
            p[a] = b;
            res += w;
            cnt++;
        &#125;
    &#125;
    if (cnt &lt; n - 1)cout &lt;&lt; &quot;impossible&quot;;
    else cout &lt;&lt; res;
&#125;
</code></pre>
<h2 id="prim求最小生成树"><a href="#prim求最小生成树" class="headerlink" title="prim求最小生成树"></a>prim求最小生成树</h2><pre><code class="c++">//在最小生成树中无所谓边的权重是正还是负
const int N = 510,inf=0x3f3f3f3f;
int n, m;  
int g[N][N];
int dist[N];
bool st[N];
int prim() &#123;
    memset(dist, inf, sizeof dist);
    int res = 0;
    for (int i = 0; i &lt; n; i++) &#123;
        int t = -1;
        for (int j = 1; j &lt;= n; j++) 
            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))
                t = j;
            if (i&gt;0 &amp;&amp; dist[t] == inf)return inf;//因为第一次i=0的循环所有dist都是inf，只是为了第一次更新所有的dist为到1的最短距离
            if (i&gt;0)res += dist[t];//先累加再更新
            for (int j = 1; j &lt;= n; j++)
                dist[j] = min(dist[j],g[t][j]);
            st[t] = true;  
    &#125;
    return res;
&#125;
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m;
    memset(g, 0x3f3f3f3f, sizeof g);
    for (int i = 1; i &lt;= m; i++) &#123;
        int x, y, c;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;
        g[x][y] = g[y][x] = min(g[x][y],c);//取得是边长的最小值，同时构建无向图
    &#125;
   int t= prim();
   if (t == inf)cout &lt;&lt; &quot;impossible&quot;;
   else cout &lt;&lt; t;
&#125;
</code></pre>
<h2 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h2><pre><code class="c++">void add(int a, int b) &#123;
    e[idx] = b, ne[idx] = h[a], h[a] =idx++;//链表
&#125;
bool dfs(int u, int c) &#123;
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i]) &#123;
        int j = e[i];
        if (!color[j]) &#123;
            if (!dfs(j, 3 - c)) &#123;
                return false;
            &#125;    
        &#125;
        else if (color[j] == c)return false;
    &#125;  
    return true;
&#125;
int main() &#123;//以邻接表的形式存储
    memset(h, -1, sizeof h);
    bool flag = true;
    for (int i = 1; i &lt;= n; i++) &#123;
        if (!color[i]) &#123;  
            if (!dfs(i, 1)) &#123;
                flag = false;
                break;
           &#125;
        &#125;
    &#125;
    if (flag)cout &lt;&lt; &quot;yes&quot;;
    else cout &lt;&lt; &quot;no&quot;;
&#125;
</code></pre>
<h2 id="二分图的最大匹配"><a href="#二分图的最大匹配" class="headerlink" title="二分图的最大匹配"></a>二分图的最大匹配</h2><pre><code class="c++">void add(int a, int b) &#123;
    e[idx] = a, ne[idx] = h[a], h[a] = idx++;
&#125;
bool find(int x) &#123;
    for (int i = h[x]; ~i; i = ne[i]) &#123;
        int j = e[i];
        if (!st[j]) &#123;
            st[j] = true;
            if (match[j] == 0 || find(match[j])) &#123;
                match[j] = x;
                return true;
            &#125;
        &#125;
    &#125;
    return false;
&#125;
int main() &#123;
    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m;
    while (m--) &#123;
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        add(a, b);
    &#125;
    for (int i = 1; i &lt;= n1; i++) &#123;
        memset(st, false, sizeof st);
        if (find(i))res++;
    &#125;
    cout &lt;&lt; res;
    return 0;
&#125;
</code></pre>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p><strong>01背包</strong></p>
<pre><code class="c++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 1010;
int v[N], w[N];
int f[N];//本来是二维这里对其进行优化
int n, m;
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++)cin &gt;&gt; v[i] &gt;&gt; w[i];//从第一个开始存放
    for (int i = 1; i &lt;= n; i++) &#123;
        for (int j = m; j &gt;=v[i]; j--) &#123;
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        &#125;
    &#125;cout &lt;&lt; f[m];//返回的是体的最积最大为m时的最大价值
&#125;
</code></pre>
<p><strong>多重背包</strong></p>
<pre><code class="c++">//多重背包问题，多重背包是单重背包的变式，同时是完全背包问题加了部分约束
//这里是暴力做法加上一点维数优化
const int N = 1e4+10;
int a[N], b[N], s[N];
int f[N];//这是对二维的优化
int n, x,sum;
int main() &#123;
    cin &gt;&gt; n &gt;&gt; x ;
    f[0] = 1;
    for (int i = 1; i &lt;= n; i++)cin &gt;&gt; a[i] &gt;&gt; b[i];//将a[i],b[i]输入
    for (int i = 1; i &lt;= n; i++) &#123;
        for (int j = x; j &gt;= 0;j--) &#123;
            for (int k = 1; k &lt;= b[i]; k++) &#123;
                if (k * a[i] &lt;= j)&#123;
               f[j] =max( f[j],f[j - k * a[i]]);		 
                &#125;		
            &#125;
        &#125;
    &#125;
    if (f[x])cout &lt;&lt; &quot;Yes&quot;;
    else cout &lt;&lt; &quot;No&quot;;
&#125;
</code></pre>
<p>优化思路，例如有s&#x3D;200，可以把他降成多个2的几次幂和加上一个差的数，从而将较大的数转化成要不要选较少的几个选项及01背包变式,即二进制优化<br>多重背包的优化,是将这么多件商品进行二进制化,, 每个件数都可以表示为多个2的不同次幂加上最后一个小于2^k+1的c值,将新的件数,放进质量和体积中,成为一个新的整体<br><em><strong>多重背包二进制优化版本</strong></em></p>
<pre><code class="c++">const int N = 25000;
int n, m;
int v[N], w[N];//以v[i]表示体积,另一个表示权重即价值
int dp[N];
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m;
    int cnt=0;
    for (int i = 1; i &lt;= n; i++) &#123;
        int a, b, s;
        cin &gt;&gt; a&gt;&gt;b&gt;&gt;s; 
        int k = 1;
        if (k &lt;= s) &#123;
            cnt++,v[cnt] = k * a,w[cnt] = k * b,s -= k,k *= 2;
        &#125;
        if (s &gt; 0) &#123;
            cnt++,v[cnt] = s*a,w[cnt] = s * b;
        &#125;
    &#125;
    n = cnt;//更换新的件数
    //即将多重背包转化成01背包
    for (int i = 1; i &lt;= n; i++)
        for (int j = m; j &gt;= v[i]; j--)
            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    int maxn=0;
    for (int i = 1; i &lt;= m; i++) &#123;
        maxn = max(maxn, dp[m]);
    &#125;
    cout &lt;&lt; maxn;
    return 0;
&#125; 
</code></pre>
<p><strong>完全背包</strong></p>
<pre><code class="c++">//一维优化
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
const int N = 1010;
int n, m;
int v[N], w[N];
int dp[N];
int main() &#123;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; w[i] &gt;&gt; v[i];
    &#125;
    for (int i = 0; i &lt;= n; i++)dp[i] = 0;
    for (int i = 1; i &lt;= n; i++) &#123;
        for (int j = w[i]; j &lt;= m; j++) &#123;
            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);//数学上的化简
        &#125;
    &#125;
    cout &lt;&lt; dp[m] &lt;&lt; endl;
&#125;
</code></pre>
<h2 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h2><pre><code class="c++">#include&lt;iostream&gt;
using namespace std;
const int N=510,inf=1e9;
int n,dp[N][N],a[N][N];
int main()&#123;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    for(int j=1;j&lt;=i;j++)
    cin&gt;&gt;a[i][j];
    for(int i=0;i&lt;=n;i++)
    for(int j=0;j&lt;=i+1;j++)//初始化要考虑边界问题,每行多初始化一个
    dp[i][j]=-inf;//题目要求要从最上层到最底层的最大路径,要考虑到数字可以为负数
    dp[1][1]=a[1][1];
    for(int i=2;i&lt;=n;i++)
    for(int j=1;j&lt;=i;j++)
    dp[i][j]=max(dp[i-1][j]+a[i][j],dp[i-1][j-1]+a[i][j]);
    int res=-inf;
    for(int i=1;i&lt;=n;i++)res=max(res,dp[n][i]);
    cout&lt;&lt;res;
    system(&quot;pause&quot;);
&#125;
</code></pre>
<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><pre><code class="c++">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 100010;
int n;
int f[N], a[N];
int main()
&#123;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++)
    &#123;
        cin &gt;&gt; a[i];
    &#125;
    int len = 0;
    f[0] = -2e9;
    for(int i = 1; i &lt;= n; i++)
    &#123;
        int l = 0, r = len;
        while(l &lt; r)
        &#123;
            int mid = l + r + 1 &gt;&gt; 1;
            if(f[mid] &lt; a[i])
                l = mid;
            else
                r = mid - 1;
        &#125;
        len = max(len, r + 1);
        f[r + 1] = a[i];
    &#125;
    cout &lt;&lt; len &lt;&lt; endl;
    return 0;
&#125; 
</code></pre>
<h3 id="最长上升子序列序列记录"><a href="#最长上升子序列序列记录" class="headerlink" title="最长上升子序列序列记录"></a>最长上升子序列序列记录</h3><pre><code class="c++">#include&lt;iostream&gt;
using namespace std;
const int N=1010;
int n,dp[N],a[N],g[N];
int main()&#123;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];
    for(int i=1;i&lt;=n;i++)&#123;
        dp[i]=1;//初始化
        g[i]=0;
        for(int j=1;j&lt;i;j++)      
            if(a[j]&lt;a[i])&#123;
                 if(dp[i]&lt;dp[j]+1)&#123;
                    dp[i]=dp[j]+1;
                    g[i]=j;
                 &#125;
            &#125;       
    &#125;
    int k=1;
    for(int i=1;i&lt;=n;i++)&#123;
        if(dp[i]&gt;dp[k])k=i;
    &#125;
    cout&lt;&lt;dp[k]&lt;&lt;endl;
    for(int i=0,len=dp[k];i&lt;len;i++)&#123;//要注意要确定以dp[k]为len
         cout&lt;&lt;a[k]&lt;&lt;&quot; &quot;; 
         k=g[k];   
    &#125;
    system(&quot;pause&quot;);
    return 0;
&#125;
</code></pre>
<p><strong>最长公共子序列（非优化）</strong></p>
<pre><code class="c++">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 1010;
int n, m;
int a[N], b[N];
int f[N][N];
int main()
&#123;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    scanf(&quot;%s %s&quot;, a+1, b+1);
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt;= m; j++)
        &#123;
            f[i][j] = max(f[i-1][j], f[i][j-1]);
            if(a[i] == b[j]) f[i][j] = max(f[i][j], f[i-1][j-1] + 1);
        &#125;
    cout &lt;&lt; f[n][m];
    return 0;
&#125;
</code></pre>
<h3 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h3><pre><code class="c++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=310;
int n,s[N],dp[N][N];
int main()&#123;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;s[i];
    for(int i=1;i&lt;=n;i++)s[i]=s[i-1]+s[i];
    for(int len=2;len&lt;=n;len++)&#123;//枚举区间长度
        for(int i=1;i+len-1&lt;=n;i++)&#123;
            int l=i,r=i+len-1;//循环区间的左端点
            dp[l][r]=1e8;//初始化
            for(int k=i;k&lt;=r-1;k++)&#123;//k是从i开始,不是从一开始
                dp[l][r]=min(dp[l][r],dp[l][k]+dp[k+1][r]+s[r]-s[l-1]);
            &#125;
        &#125;
    &#125;
    cout&lt;&lt;dp[1][n];
    system(&quot;pause&quot;);
    return 0;
&#125;
</code></pre>
<h2 id="数学快速幂"><a href="#数学快速幂" class="headerlink" title="数学快速幂"></a>数学快速幂</h2><pre><code class="c++">#include&lt;iostream&gt;
using namespace std;
int a, b;
int qpow(int a, int b) &#123;
    int ans = 1;
    while (b) &#123;
        if (b &amp; 1) 
            ans = ans * a;
        a *= a;
        b &gt;&gt;= 1;	
    &#125;
    return ans;
&#125;
int main() &#123;
    cin &gt;&gt; a &gt;&gt; b;
    cout &lt;&lt; qpow(a, b);
&#125;
</code></pre>
<h2 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h2><pre><code class="c++">int p[N], cnt;
bool st[N];
void get_primes(int n) &#123;//埃氏筛
    for (int i = 2; i &lt;= n; i++) &#123;
        if (!st[i]) &#123;
            p[cnt++] = n;
            for (int j = i + i; i &lt;= n; j +=i)st[j] = true;
        &#125;
    &#125;
&#125;
void get_primes1(int n) &#123;//线性筛
    for ( int i = 2; i &lt;= n; i++) &#123;
        if (!st[i])p[cnt++] = i;
        for (int j = 0; p[j] &lt;= n / i; j++) &#123;
            st[p[j] * i] = true;
            if (i % p[j] == 0)break;//p[j]一定是i的最小质因子
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="最大公约数欧几里得"><a href="#最大公约数欧几里得" class="headerlink" title="最大公约数欧几里得"></a>最大公约数欧几里得</h2><pre><code class="c++">int gcd(int a, int b) &#123;//输入时,b&gt;a
    return b ? gcd(b, a % b) : a;//如果b不是0，返回(b, a % b)，如果b是0，返回a
&#125;
</code></pre>
<h2 id="求约数个数，求约数之和"><a href="#求约数个数，求约数之和" class="headerlink" title="求约数个数，求约数之和"></a>求约数个数，求约数之和</h2><pre><code class="c++">//给定n个正整数，输出这些数字乘积的约数个数，答案对1e9+7取模
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;unordered_map&gt;
using namespace std;
typedef long long ll;
const int mod = 1e9 + 7;
int main() &#123;
    int n;
    cin &gt;&gt; n;
    unordered_map&lt;int, int &gt; primes;
    while (n--) &#123;
        int x;
        cin &gt;&gt; x;
        for (int i = 2; i &lt;= x / i; i++) &#123;
            while (x % i == 0) &#123;
                primes[i]++;
                x /= i;
            &#125;
        &#125;
        if (x &gt; 1)primes[x]++;
    &#125;
    ll res = 1;
    //for (auto tt : primes)res = res * (tt.second + 1) % mod;//求约数的个数
    //求约数之和
    for (auto tt : primes) &#123;
        int p = tt.first, a = tt.second;
        ll t = 1;
        while (a--)t = (t * p + 1) % mod;
        res = res * t % mod;
    &#125;
    cout &lt;&lt; res &lt;&lt; endl;
&#125;
</code></pre>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 vite的避难所
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Zhz-Vite
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
